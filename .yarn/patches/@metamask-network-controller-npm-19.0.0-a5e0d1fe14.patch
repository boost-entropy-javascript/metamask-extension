diff --git a/dist/NetworkController.js b/dist/NetworkController.js
index 330adcdc94693e5ba4321527a16175ef428fcf77..fdd8e81502824170e9d67d175f1e628cefd6d8b1 100644
--- a/dist/NetworkController.js
+++ b/dist/NetworkController.js
@@ -2,7 +2,7 @@
 
 
 
-var _chunk4ZD3DTQ7js = require('./chunk-4ZD3DTQ7.js');
+var _chunkPC5HTMUEjs = require('./chunk-PC5HTMUE.js');
 require('./chunk-ZKNI7MD3.js');
 require('./chunk-ZV34XXLT.js');
 require('./chunk-LDNWNT2P.js');
@@ -13,5 +13,5 @@ require('./chunk-Z4BLTVTB.js');
 
 
 
-exports.NetworkController = _chunk4ZD3DTQ7js.NetworkController; exports.defaultState = _chunk4ZD3DTQ7js.defaultState; exports.knownKeysOf = _chunk4ZD3DTQ7js.knownKeysOf;
+exports.NetworkController = _chunkPC5HTMUEjs.NetworkController; exports.defaultState = _chunkPC5HTMUEjs.defaultState; exports.knownKeysOf = _chunkPC5HTMUEjs.knownKeysOf;
 //# sourceMappingURL=NetworkController.js.map
\ No newline at end of file
diff --git a/dist/NetworkController.mjs b/dist/NetworkController.mjs
index 77720eaca62be7b5912d406bf96a3cbba8ba601a..3a5d21d5f30d22d62e499c7457f78145ae43c799 100644
--- a/dist/NetworkController.mjs
+++ b/dist/NetworkController.mjs
@@ -2,7 +2,7 @@ import {
   NetworkController,
   defaultState,
   knownKeysOf
-} from "./chunk-UG2NYGJD.mjs";
+} from "./chunk-6EXWS63D.mjs";
 import "./chunk-2QJYHWIP.mjs";
 import "./chunk-G5HYTGGH.mjs";
 import "./chunk-TPYFTFZ2.mjs";
diff --git a/dist/chunk-4ZD3DTQ7.js b/dist/chunk-4ZD3DTQ7.js
deleted file mode 100644
index e172d15715b3cb4f26c42e51f8c7ff7394075bfe..0000000000000000000000000000000000000000
--- a/dist/chunk-4ZD3DTQ7.js
+++ /dev/null
@@ -1,1017 +0,0 @@
-"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
-
-var _chunkZKNI7MD3js = require('./chunk-ZKNI7MD3.js');
-
-
-var _chunkZV34XXLTjs = require('./chunk-ZV34XXLT.js');
-
-
-
-var _chunkVGYLDDJBjs = require('./chunk-VGYLDDJB.js');
-
-
-
-
-
-var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
-
-// src/NetworkController.ts
-var _basecontroller = require('@metamask/base-controller');
-
-
-
-
-
-
-
-
-var _controllerutils = require('@metamask/controller-utils');
-var _ethquery = require('@metamask/eth-query'); var _ethquery2 = _interopRequireDefault(_ethquery);
-var _rpcerrors = require('@metamask/rpc-errors');
-var _swappableobjproxy = require('@metamask/swappable-obj-proxy');
-
-
-
-
-var _utils = require('@metamask/utils');
-var _assert = require('assert');
-var _uuid = require('uuid');
-var log = _chunkVGYLDDJBjs.createModuleLogger.call(void 0, _chunkVGYLDDJBjs.projectLogger, "NetworkController");
-function knownKeysOf(object) {
-  return Object.keys(object);
-}
-function assertOfType(value, validate, message) {
-  _assert.strict.ok(validate(value), message);
-}
-function pick(object, keys) {
-  const pickedObject = keys.reduce(
-    (finalObject, key) => {
-      return { ...finalObject, [key]: object[key] };
-    },
-    {}
-  );
-  assertOfType(
-    pickedObject,
-    () => keys.every((key) => key in pickedObject),
-    "The reduce did not produce an object with all of the desired keys."
-  );
-  return pickedObject;
-}
-function isErrorWithCode(error) {
-  return typeof error === "object" && error !== null && "code" in error;
-}
-function buildInfuraNetworkClientId(infuraNetworkOrProviderConfig) {
-  if (typeof infuraNetworkOrProviderConfig === "string") {
-    return infuraNetworkOrProviderConfig;
-  }
-  return infuraNetworkOrProviderConfig.type;
-}
-function buildCustomNetworkClientId(...args) {
-  if (args.length === 1) {
-    return args[0];
-  }
-  const [{ id, rpcUrl }, networkConfigurations] = args;
-  if (id === void 0) {
-    const matchingNetworkConfiguration = Object.values(
-      networkConfigurations
-    ).find((networkConfiguration) => {
-      return networkConfiguration.rpcUrl === rpcUrl.toLowerCase();
-    });
-    if (matchingNetworkConfiguration) {
-      return matchingNetworkConfiguration.id;
-    }
-    return rpcUrl.toLowerCase();
-  }
-  return id;
-}
-function isInfuraProviderConfig(providerConfig) {
-  return _controllerutils.isInfuraNetworkType.call(void 0, providerConfig.type);
-}
-function isCustomProviderConfig(providerConfig) {
-  return providerConfig.type === _controllerutils.NetworkType.rpc;
-}
-function validateCustomProviderConfig(providerConfig) {
-  if (providerConfig.chainId === void 0) {
-    throw new Error("chainId must be provided for custom RPC endpoints");
-  }
-  if (providerConfig.rpcUrl === void 0) {
-    throw new Error("rpcUrl must be provided for custom RPC endpoints");
-  }
-}
-var name = "NetworkController";
-var defaultState = {
-  selectedNetworkClientId: _controllerutils.NetworkType.mainnet,
-  providerConfig: {
-    type: _controllerutils.NetworkType.mainnet,
-    chainId: _controllerutils.ChainId.mainnet,
-    ticker: _controllerutils.NetworksTicker.mainnet
-  },
-  networksMetadata: {},
-  networkConfigurations: {}
-};
-var _ethQuery, _infuraProjectId, _trackMetaMetricsEvent, _previousProviderConfig, _providerProxy, _blockTrackerProxy, _autoManagedNetworkClientRegistry, _refreshNetwork, refreshNetwork_fn, _getLatestBlock, getLatestBlock_fn, _determineEIP1559Compatibility, determineEIP1559Compatibility_fn, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn, _createAutoManagedNetworkClientRegistry, createAutoManagedNetworkClientRegistry_fn, _buildIdentifiedInfuraNetworkClientConfigurations, buildIdentifiedInfuraNetworkClientConfigurations_fn, _buildIdentifiedCustomNetworkClientConfigurations, buildIdentifiedCustomNetworkClientConfigurations_fn, _buildIdentifiedNetworkClientConfigurationsFromProviderConfig, buildIdentifiedNetworkClientConfigurationsFromProviderConfig_fn, _applyNetworkSelection, applyNetworkSelection_fn;
-var NetworkController = class extends _basecontroller.BaseController {
-  constructor({
-    messenger,
-    state,
-    infuraProjectId,
-    trackMetaMetricsEvent
-  }) {
-    super({
-      name,
-      metadata: {
-        selectedNetworkClientId: {
-          persist: true,
-          anonymous: false
-        },
-        networksMetadata: {
-          persist: true,
-          anonymous: false
-        },
-        providerConfig: {
-          persist: true,
-          anonymous: false
-        },
-        networkConfigurations: {
-          persist: true,
-          anonymous: false
-        }
-      },
-      messenger,
-      state: { ...defaultState, ...state }
-    });
-    /**
-     * Executes a series of steps to apply the changes to the provider config:
-     *
-     * 1. Notifies subscribers that the network is about to change.
-     * 2. Looks up a known and preinitialized network client matching the provider
-     * config and re-points the provider and block tracker proxy to it.
-     * 3. Notifies subscribers that the network has changed.
-     */
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _refreshNetwork);
-    /**
-     * Fetches the latest block for the network.
-     *
-     * @param networkClientId - The networkClientId to fetch the correct provider against which to check the latest block. Defaults to the selectedNetworkClientId.
-     * @returns A promise that either resolves to the block header or null if
-     * there is no latest block, or rejects with an error.
-     */
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getLatestBlock);
-    /**
-     * Retrieves and checks the latest block from the currently selected
-     * network; if the block has a `baseFeePerGas` property, then we know
-     * that the network supports EIP-1559; otherwise it doesn't.
-     *
-     * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility
-     * @returns A promise that resolves to `true` if the network supports EIP-1559,
-     * `false` otherwise, or `undefined` if unable to retrieve the last block.
-     */
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _determineEIP1559Compatibility);
-    /**
-     * Before accessing or switching the network, the registry of network clients
-     * needs to be populated. Otherwise, `#applyNetworkSelection` and
-     * `getNetworkClientRegistry` will throw an error. This method checks to see if the
-     * population step has happened yet, and if not, makes it happen.
-     *
-     * @returns The populated network client registry.
-     */
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _ensureAutoManagedNetworkClientRegistryPopulated);
-    /**
-     * Constructs the registry of network clients based on the set of built-in
-     * networks as well as the custom networks in state.
-     *
-     * @returns The network clients keyed by ID.
-     */
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _createAutoManagedNetworkClientRegistry);
-    /**
-     * Constructs the list of network clients for built-in networks (that is,
-     * the subset of the networks we know Infura supports that consumers do not
-     * need to explicitly add).
-     *
-     * @returns The network clients.
-     */
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _buildIdentifiedInfuraNetworkClientConfigurations);
-    /**
-     * Constructs the list of network clients for custom networks (that is, those
-     * which consumers have added via `networkConfigurations`).
-     *
-     * @returns The network clients.
-     */
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _buildIdentifiedCustomNetworkClientConfigurations);
-    /**
-     * Converts the provider config object in state to a network client
-     * configuration object.
-     *
-     * @returns The network client config.
-     * @throws If the provider config is of type "rpc" and lacks either a
-     * `chainId` or an `rpcUrl`.
-     */
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _buildIdentifiedNetworkClientConfigurationsFromProviderConfig);
-    /**
-     * Uses the information in the provider config object to look up a known and
-     * preinitialized network client. Once a network client is found, updates the
-     * provider and block tracker proxy to point to those from the network client,
-     * then finally creates an EthQuery that points to the provider proxy.
-     *
-     * @throws If no network client could be found matching the current provider
-     * config.
-     */
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _applyNetworkSelection);
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _ethQuery, void 0);
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _infuraProjectId, void 0);
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _trackMetaMetricsEvent, void 0);
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _previousProviderConfig, void 0);
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _providerProxy, void 0);
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _blockTrackerProxy, void 0);
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _autoManagedNetworkClientRegistry, void 0);
-    if (!infuraProjectId || typeof infuraProjectId !== "string") {
-      throw new Error("Invalid Infura project ID");
-    }
-    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _infuraProjectId, infuraProjectId);
-    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _trackMetaMetricsEvent, trackMetaMetricsEvent);
-    this.messagingSystem.registerActionHandler(
-      `${this.name}:getProviderConfig`,
-      () => {
-        return this.state.providerConfig;
-      }
-    );
-    this.messagingSystem.registerActionHandler(
-      `${this.name}:getEthQuery`,
-      () => {
-        return _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _ethQuery);
-      }
-    );
-    this.messagingSystem.registerActionHandler(
-      `${this.name}:getNetworkClientById`,
-      this.getNetworkClientById.bind(this)
-    );
-    this.messagingSystem.registerActionHandler(
-      `${this.name}:getEIP1559Compatibility`,
-      this.getEIP1559Compatibility.bind(this)
-    );
-    this.messagingSystem.registerActionHandler(
-      `${this.name}:setActiveNetwork`,
-      this.setActiveNetwork.bind(this)
-    );
-    this.messagingSystem.registerActionHandler(
-      `${this.name}:setProviderType`,
-      this.setProviderType.bind(this)
-    );
-    this.messagingSystem.registerActionHandler(
-      `${this.name}:findNetworkClientIdByChainId`,
-      this.findNetworkClientIdByChainId.bind(this)
-    );
-    this.messagingSystem.registerActionHandler(
-      `${this.name}:getNetworkConfigurationByNetworkClientId`,
-      this.getNetworkConfigurationByNetworkClientId.bind(this)
-    );
-    this.messagingSystem.registerActionHandler(
-      `${this.name}:getSelectedNetworkClient`,
-      this.getSelectedNetworkClient.bind(this)
-    );
-    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _previousProviderConfig, this.state.providerConfig);
-  }
-  /**
-   * Accesses the provider and block tracker for the currently selected network.
-   * @returns The proxy and block tracker proxies.
-   * @deprecated This method has been replaced by `getSelectedNetworkClient` (which has a more easily used return type) and will be removed in a future release.
-   */
-  getProviderAndBlockTracker() {
-    return {
-      provider: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _providerProxy),
-      blockTracker: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _blockTrackerProxy)
-    };
-  }
-  /**
-   * Accesses the provider and block tracker for the currently selected network.
-   *
-   * @returns an object with the provider and block tracker proxies for the currently selected network.
-   */
-  getSelectedNetworkClient() {
-    if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _providerProxy) && _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _blockTrackerProxy)) {
-      return {
-        provider: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _providerProxy),
-        blockTracker: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _blockTrackerProxy)
-      };
-    }
-    return void 0;
-  }
-  /**
-   * Returns all of the network clients that have been created so far, keyed by
-   * their identifier in the network client registry. This collection represents
-   * not only built-in networks but also any custom networks that consumers have
-   * added.
-   *
-   * @returns The list of known network clients.
-   */
-  getNetworkClientRegistry() {
-    const autoManagedNetworkClientRegistry = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
-    return Object.assign(
-      {},
-      autoManagedNetworkClientRegistry["infura" /* Infura */],
-      autoManagedNetworkClientRegistry["custom" /* Custom */]
-    );
-  }
-  getNetworkClientById(networkClientId) {
-    if (!networkClientId) {
-      throw new Error("No network client ID was provided.");
-    }
-    const autoManagedNetworkClientRegistry = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
-    if (_controllerutils.isInfuraNetworkType.call(void 0, networkClientId)) {
-      const infuraNetworkClient = autoManagedNetworkClientRegistry["infura" /* Infura */][networkClientId];
-      if (!infuraNetworkClient) {
-        throw new Error(
-          `No Infura network client was found with the ID "${networkClientId}".`
-        );
-      }
-      return infuraNetworkClient;
-    }
-    const customNetworkClient = autoManagedNetworkClientRegistry["custom" /* Custom */][networkClientId];
-    if (!customNetworkClient) {
-      throw new Error(
-        `No custom network client was found with the ID "${networkClientId}".`
-      );
-    }
-    return customNetworkClient;
-  }
-  /**
-   * Populates the network clients and establishes the initial network based on
-   * the provider configuration in state.
-   */
-  async initializeProvider() {
-    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
-    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _applyNetworkSelection, applyNetworkSelection_fn).call(this);
-    await this.lookupNetwork();
-  }
-  /**
-   * Refreshes the network meta with EIP-1559 support and the network status
-   * based on the given network client ID.
-   *
-   * @param networkClientId - The ID of the network client to update.
-   */
-  async lookupNetworkByClientId(networkClientId) {
-    const isInfura = _controllerutils.isInfuraNetworkType.call(void 0, networkClientId);
-    let updatedNetworkStatus;
-    let updatedIsEIP1559Compatible;
-    try {
-      updatedIsEIP1559Compatible = await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _determineEIP1559Compatibility, determineEIP1559Compatibility_fn).call(this, networkClientId);
-      updatedNetworkStatus = "available" /* Available */;
-    } catch (error) {
-      if (isErrorWithCode(error)) {
-        let responseBody;
-        if (isInfura && _utils.hasProperty.call(void 0, error, "message") && typeof error.message === "string") {
-          try {
-            responseBody = JSON.parse(error.message);
-          } catch {
-          }
-        }
-        if (_utils.isPlainObject.call(void 0, responseBody) && responseBody.error === _chunkZKNI7MD3js.INFURA_BLOCKED_KEY) {
-          updatedNetworkStatus = "blocked" /* Blocked */;
-        } else if (error.code === _rpcerrors.errorCodes.rpc.internal) {
-          updatedNetworkStatus = "unknown" /* Unknown */;
-        } else {
-          updatedNetworkStatus = "unavailable" /* Unavailable */;
-        }
-      } else if (typeof Error !== "undefined" && _utils.hasProperty.call(void 0, error, "message") && typeof error.message === "string" && error.message.includes(
-        "No custom network client was found with the ID"
-      )) {
-        throw error;
-      } else {
-        log("NetworkController - could not determine network status", error);
-        updatedNetworkStatus = "unknown" /* Unknown */;
-      }
-    }
-    this.update((state) => {
-      if (state.networksMetadata[networkClientId] === void 0) {
-        state.networksMetadata[networkClientId] = {
-          status: "unknown" /* Unknown */,
-          EIPS: {}
-        };
-      }
-      const meta = state.networksMetadata[networkClientId];
-      meta.status = updatedNetworkStatus;
-      if (updatedIsEIP1559Compatible === void 0) {
-        delete meta.EIPS[1559];
-      } else {
-        meta.EIPS[1559] = updatedIsEIP1559Compatible;
-      }
-    });
-  }
-  /**
-   * Performs side effects after switching to a network. If the network is
-   * available, updates the network state with the network ID of the network and
-   * stores whether the network supports EIP-1559; otherwise clears said
-   * information about the network that may have been previously stored.
-   *
-   * @param networkClientId - (Optional) The ID of the network client to update.
-   * If no ID is provided, uses the currently selected network.
-   * @fires infuraIsBlocked if the network is Infura-supported and is blocking
-   * requests.
-   * @fires infuraIsUnblocked if the network is Infura-supported and is not
-   * blocking requests, or if the network is not Infura-supported.
-   */
-  async lookupNetwork(networkClientId) {
-    if (networkClientId) {
-      await this.lookupNetworkByClientId(networkClientId);
-      return;
-    }
-    if (!_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _ethQuery)) {
-      return;
-    }
-    const isInfura = isInfuraProviderConfig(this.state.providerConfig);
-    let networkChanged = false;
-    const listener = () => {
-      networkChanged = true;
-      this.messagingSystem.unsubscribe(
-        "NetworkController:networkDidChange",
-        listener
-      );
-    };
-    this.messagingSystem.subscribe(
-      "NetworkController:networkDidChange",
-      listener
-    );
-    let updatedNetworkStatus;
-    let updatedIsEIP1559Compatible;
-    try {
-      const isEIP1559Compatible = await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _determineEIP1559Compatibility, determineEIP1559Compatibility_fn).call(this, this.state.selectedNetworkClientId);
-      updatedNetworkStatus = "available" /* Available */;
-      updatedIsEIP1559Compatible = isEIP1559Compatible;
-    } catch (error) {
-      if (isErrorWithCode(error)) {
-        let responseBody;
-        if (isInfura && _utils.hasProperty.call(void 0, error, "message") && typeof error.message === "string") {
-          try {
-            responseBody = JSON.parse(error.message);
-          } catch {
-          }
-        }
-        if (_utils.isPlainObject.call(void 0, responseBody) && responseBody.error === _chunkZKNI7MD3js.INFURA_BLOCKED_KEY) {
-          updatedNetworkStatus = "blocked" /* Blocked */;
-        } else if (error.code === _rpcerrors.errorCodes.rpc.internal) {
-          updatedNetworkStatus = "unknown" /* Unknown */;
-        } else {
-          updatedNetworkStatus = "unavailable" /* Unavailable */;
-        }
-      } else {
-        log("NetworkController - could not determine network status", error);
-        updatedNetworkStatus = "unknown" /* Unknown */;
-      }
-    }
-    if (networkChanged) {
-      return;
-    }
-    this.messagingSystem.unsubscribe(
-      "NetworkController:networkDidChange",
-      listener
-    );
-    this.update((state) => {
-      const meta = state.networksMetadata[state.selectedNetworkClientId];
-      meta.status = updatedNetworkStatus;
-      if (updatedIsEIP1559Compatible === void 0) {
-        delete meta.EIPS[1559];
-      } else {
-        meta.EIPS[1559] = updatedIsEIP1559Compatible;
-      }
-    });
-    if (isInfura) {
-      if (updatedNetworkStatus === "available" /* Available */) {
-        this.messagingSystem.publish("NetworkController:infuraIsUnblocked");
-      } else if (updatedNetworkStatus === "blocked" /* Blocked */) {
-        this.messagingSystem.publish("NetworkController:infuraIsBlocked");
-      }
-    } else {
-      this.messagingSystem.publish("NetworkController:infuraIsUnblocked");
-    }
-  }
-  /**
-   * Convenience method to update provider network type settings.
-   *
-   * @param type - Human readable network name.
-   * @deprecated This has been replaced by `setActiveNetwork`, and will be
-   * removed in a future release
-   */
-  async setProviderType(type) {
-    _assert.strict.notStrictEqual(
-      type,
-      _controllerutils.NetworkType.rpc,
-      `NetworkController - cannot call "setProviderType" with type "${_controllerutils.NetworkType.rpc}". Use "setActiveNetwork"`
-    );
-    _assert.strict.ok(
-      _controllerutils.isInfuraNetworkType.call(void 0, type),
-      `Unknown Infura provider type "${type}".`
-    );
-    await this.setActiveNetwork(type);
-  }
-  /**
-   * Convenience method to update provider RPC settings.
-   *
-   * @param networkConfigurationIdOrType - The unique id for the network configuration to set as the active provider,
-   * or the type of a built-in network.
-   */
-  async setActiveNetwork(networkConfigurationIdOrType) {
-    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _previousProviderConfig, this.state.providerConfig);
-    let targetNetwork;
-    if (_controllerutils.isInfuraNetworkType.call(void 0, networkConfigurationIdOrType)) {
-      const ticker = _controllerutils.NetworksTicker[networkConfigurationIdOrType];
-      targetNetwork = {
-        chainId: _controllerutils.ChainId[networkConfigurationIdOrType],
-        id: void 0,
-        rpcPrefs: _controllerutils.BUILT_IN_NETWORKS[networkConfigurationIdOrType].rpcPrefs,
-        rpcUrl: void 0,
-        nickname: void 0,
-        ticker,
-        type: networkConfigurationIdOrType
-      };
-    } else {
-      if (!Object.keys(this.state.networkConfigurations).includes(
-        networkConfigurationIdOrType
-      )) {
-        throw new Error(
-          `networkConfigurationId ${networkConfigurationIdOrType} does not match a configured networkConfiguration or built-in network type`
-        );
-      }
-      targetNetwork = {
-        ...this.state.networkConfigurations[networkConfigurationIdOrType],
-        type: _controllerutils.NetworkType.rpc
-      };
-    }
-    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
-    this.update((state) => {
-      state.providerConfig = targetNetwork;
-    });
-    await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _refreshNetwork, refreshNetwork_fn).call(this);
-  }
-  /**
-   * Determines whether the network supports EIP-1559 by checking whether the
-   * latest block has a `baseFeePerGas` property, then updates state
-   * appropriately.
-   *
-   * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility.
-   * @returns A promise that resolves to true if the network supports EIP-1559
-   * , false otherwise, or `undefined` if unable to determine the compatibility.
-   */
-  async getEIP1559Compatibility(networkClientId) {
-    if (networkClientId) {
-      return this.get1559CompatibilityWithNetworkClientId(networkClientId);
-    }
-    if (!_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _ethQuery)) {
-      return false;
-    }
-    const { EIPS } = this.state.networksMetadata[this.state.selectedNetworkClientId];
-    if (EIPS[1559] !== void 0) {
-      return EIPS[1559];
-    }
-    const isEIP1559Compatible = await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _determineEIP1559Compatibility, determineEIP1559Compatibility_fn).call(this, this.state.selectedNetworkClientId);
-    this.update((state) => {
-      if (isEIP1559Compatible !== void 0) {
-        state.networksMetadata[state.selectedNetworkClientId].EIPS[1559] = isEIP1559Compatible;
-      }
-    });
-    return isEIP1559Compatible;
-  }
-  async get1559CompatibilityWithNetworkClientId(networkClientId) {
-    let metadata = this.state.networksMetadata[networkClientId];
-    if (metadata === void 0) {
-      await this.lookupNetwork(networkClientId);
-      metadata = this.state.networksMetadata[networkClientId];
-    }
-    const { EIPS } = metadata;
-    return EIPS[1559];
-  }
-  /**
-   * Re-initializes the provider and block tracker for the current network.
-   */
-  async resetConnection() {
-    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
-    await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _refreshNetwork, refreshNetwork_fn).call(this);
-  }
-  /**
-   * Returns a configuration object for the network identified by the given
-   * network client ID. If given an Infura network type, constructs one based on
-   * what we know about the network; otherwise attempts locates a network
-   * configuration in state that corresponds to the network client ID.
-   *
-   * @param networkClientId - The network client ID.
-   * @returns The configuration for the referenced network if one exists, or
-   * undefined otherwise.
-   */
-  getNetworkConfigurationByNetworkClientId(networkClientId) {
-    if (_controllerutils.isInfuraNetworkType.call(void 0, networkClientId)) {
-      const rpcUrl = `https://${networkClientId}.infura.io/v3/${_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _infuraProjectId)}`;
-      return {
-        rpcUrl,
-        ..._controllerutils.BUILT_IN_NETWORKS[networkClientId]
-      };
-    }
-    return this.state.networkConfigurations[networkClientId];
-  }
-  /**
-   * Adds a new custom network or updates the information for an existing
-   * network.
-   *
-   * This may involve updating the `networkConfigurations` property in
-   * state as well and/or adding a new network client to the network client
-   * registry. The `rpcUrl` and `chainId` of the given object are used to
-   * determine which action to take:
-   *
-   * - If the `rpcUrl` corresponds to an existing network configuration
-   * (case-insensitively), then it is overwritten with the object. Furthermore,
-   * if the `chainId` is different from the existing network configuration, then
-   * the existing network client is replaced with a new one.
-   * - If the `rpcUrl` does not correspond to an existing network configuration
-   * (case-insensitively), then the object is used to add a new network
-   * configuration along with a new network client.
-   *
-   * @param networkConfiguration - The network configuration to add or update.
-   * @param options - Additional configuration options.
-   * @param options.referrer - Used to create a metrics event; the site from which the call originated, or 'metamask' for internal calls.
-   * @param options.source - Used to create a metrics event; where the event originated (i.e. from a dapp or from the network form).
-   * @param options.setActive - If true, switches to the network upon adding or updating it (default: false).
-   * @returns The ID for the added or updated network configuration.
-   */
-  async upsertNetworkConfiguration(networkConfiguration, {
-    referrer,
-    source,
-    setActive = false
-  }) {
-    const sanitizedNetworkConfiguration = pick(
-      networkConfiguration,
-      ["rpcUrl", "chainId", "ticker", "nickname", "rpcPrefs"]
-    );
-    const { rpcUrl, chainId, ticker } = sanitizedNetworkConfiguration;
-    _utils.assertIsStrictHexString.call(void 0, chainId);
-    if (!_controllerutils.isSafeChainId.call(void 0, chainId)) {
-      throw new Error(
-        `Invalid chain ID "${chainId}": numerical value greater than max safe value.`
-      );
-    }
-    if (!rpcUrl) {
-      throw new Error(
-        "An rpcUrl is required to add or update network configuration"
-      );
-    }
-    if (!referrer || !source) {
-      throw new Error(
-        "referrer and source are required arguments for adding or updating a network configuration"
-      );
-    }
-    try {
-      new URL(rpcUrl);
-    } catch (e) {
-      if (e.message.includes("Invalid URL")) {
-        throw new Error("rpcUrl must be a valid URL");
-      }
-    }
-    if (!ticker) {
-      throw new Error(
-        "A ticker is required to add or update networkConfiguration"
-      );
-    }
-    const autoManagedNetworkClientRegistry = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
-    const existingNetworkConfiguration = Object.values(
-      this.state.networkConfigurations
-    ).find(
-      (networkConfig) => networkConfig.rpcUrl.toLowerCase() === rpcUrl.toLowerCase()
-    );
-    const upsertedNetworkConfigurationId = existingNetworkConfiguration ? existingNetworkConfiguration.id : _uuid.v4.call(void 0, );
-    const networkClientId = buildCustomNetworkClientId(
-      upsertedNetworkConfigurationId
-    );
-    const customNetworkClientRegistry = autoManagedNetworkClientRegistry["custom" /* Custom */];
-    const existingAutoManagedNetworkClient = customNetworkClientRegistry[networkClientId];
-    const shouldDestroyExistingNetworkClient = existingAutoManagedNetworkClient && existingAutoManagedNetworkClient.configuration.chainId !== chainId;
-    if (shouldDestroyExistingNetworkClient) {
-      existingAutoManagedNetworkClient.destroy();
-    }
-    if (!existingAutoManagedNetworkClient || shouldDestroyExistingNetworkClient) {
-      customNetworkClientRegistry[networkClientId] = _chunkZV34XXLTjs.createAutoManagedNetworkClient.call(void 0, {
-        type: "custom" /* Custom */,
-        chainId,
-        rpcUrl,
-        ticker
-      });
-    }
-    this.update((state) => {
-      state.networkConfigurations[upsertedNetworkConfigurationId] = {
-        id: upsertedNetworkConfigurationId,
-        ...sanitizedNetworkConfiguration
-      };
-    });
-    if (!existingNetworkConfiguration) {
-      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _trackMetaMetricsEvent).call(this, {
-        event: "Custom Network Added",
-        category: "Network",
-        referrer: {
-          url: referrer
-        },
-        properties: {
-          chain_id: chainId,
-          symbol: ticker,
-          source
-        }
-      });
-    }
-    if (setActive) {
-      await this.setActiveNetwork(upsertedNetworkConfigurationId);
-    }
-    return upsertedNetworkConfigurationId;
-  }
-  /**
-   * Removes a custom network from state.
-   *
-   * This involves updating the `networkConfigurations` property in state as
-   * well and removing the network client that corresponds to the network from
-   * the client registry.
-   *
-   * @param networkConfigurationId - The ID of an existing network
-   * configuration.
-   */
-  removeNetworkConfiguration(networkConfigurationId) {
-    if (!this.state.networkConfigurations[networkConfigurationId]) {
-      throw new Error(
-        `networkConfigurationId ${networkConfigurationId} does not match a configured networkConfiguration`
-      );
-    }
-    const autoManagedNetworkClientRegistry = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
-    const networkClientId = buildCustomNetworkClientId(networkConfigurationId);
-    this.update((state) => {
-      delete state.networkConfigurations[networkConfigurationId];
-    });
-    const customNetworkClientRegistry = autoManagedNetworkClientRegistry["custom" /* Custom */];
-    const existingAutoManagedNetworkClient = customNetworkClientRegistry[networkClientId];
-    existingAutoManagedNetworkClient.destroy();
-    delete customNetworkClientRegistry[networkClientId];
-  }
-  /**
-   * Switches to the previously selected network, assuming that there is one
-   * (if not and `initializeProvider` has not been previously called, then this
-   * method is equivalent to calling `resetConnection`).
-   */
-  async rollbackToPreviousProvider() {
-    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
-    this.update((state) => {
-      state.providerConfig = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _previousProviderConfig);
-    });
-    await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _refreshNetwork, refreshNetwork_fn).call(this);
-  }
-  /**
-   * Deactivates the controller, stopping any ongoing polling.
-   *
-   * In-progress requests will not be aborted.
-   */
-  async destroy() {
-    await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _blockTrackerProxy)?.destroy();
-  }
-  /**
-   * Updates the controller using the given backup data.
-   *
-   * @param backup - The data that has been backed up.
-   * @param backup.networkConfigurations - Network configurations in the backup.
-   */
-  loadBackup({
-    networkConfigurations
-  }) {
-    this.update((state) => {
-      state.networkConfigurations = {
-        ...state.networkConfigurations,
-        ...networkConfigurations
-      };
-    });
-  }
-  /**
-   * Searches for a network configuration ID with the given ChainID and returns it.
-   *
-   * @param chainId - ChainId to search for
-   * @returns networkClientId of the network configuration with the given chainId
-   */
-  findNetworkClientIdByChainId(chainId) {
-    const networkClients = this.getNetworkClientRegistry();
-    const networkClientEntry = Object.entries(networkClients).find(
-      ([_, networkClient]) => networkClient.configuration.chainId === chainId
-    );
-    if (networkClientEntry === void 0) {
-      throw new Error("Couldn't find networkClientId for chainId");
-    }
-    return networkClientEntry[0];
-  }
-};
-_ethQuery = new WeakMap();
-_infuraProjectId = new WeakMap();
-_trackMetaMetricsEvent = new WeakMap();
-_previousProviderConfig = new WeakMap();
-_providerProxy = new WeakMap();
-_blockTrackerProxy = new WeakMap();
-_autoManagedNetworkClientRegistry = new WeakMap();
-_refreshNetwork = new WeakSet();
-refreshNetwork_fn = async function() {
-  this.messagingSystem.publish(
-    "NetworkController:networkWillChange",
-    this.state
-  );
-  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _applyNetworkSelection, applyNetworkSelection_fn).call(this);
-  this.messagingSystem.publish(
-    "NetworkController:networkDidChange",
-    this.state
-  );
-  await this.lookupNetwork();
-};
-_getLatestBlock = new WeakSet();
-getLatestBlock_fn = function(networkClientId) {
-  if (networkClientId === void 0) {
-    networkClientId = this.state.selectedNetworkClientId;
-  }
-  const networkClient = this.getNetworkClientById(networkClientId);
-  const ethQuery = new (0, _ethquery2.default)(networkClient.provider);
-  return new Promise((resolve, reject) => {
-    ethQuery.sendAsync(
-      { method: "eth_getBlockByNumber", params: ["latest", false] },
-      (error, block) => {
-        if (error) {
-          reject(error);
-        } else {
-          resolve(block);
-        }
-      }
-    );
-  });
-};
-_determineEIP1559Compatibility = new WeakSet();
-determineEIP1559Compatibility_fn = async function(networkClientId) {
-  const latestBlock = await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getLatestBlock, getLatestBlock_fn).call(this, networkClientId);
-  if (!latestBlock) {
-    return void 0;
-  }
-  return latestBlock.baseFeePerGas !== void 0;
-};
-_ensureAutoManagedNetworkClientRegistryPopulated = new WeakSet();
-ensureAutoManagedNetworkClientRegistryPopulated_fn = function() {
-  const autoManagedNetworkClientRegistry = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _autoManagedNetworkClientRegistry) ?? _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createAutoManagedNetworkClientRegistry, createAutoManagedNetworkClientRegistry_fn).call(this);
-  _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _autoManagedNetworkClientRegistry, autoManagedNetworkClientRegistry);
-  return autoManagedNetworkClientRegistry;
-};
-_createAutoManagedNetworkClientRegistry = new WeakSet();
-createAutoManagedNetworkClientRegistry_fn = function() {
-  return [
-    ..._chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _buildIdentifiedInfuraNetworkClientConfigurations, buildIdentifiedInfuraNetworkClientConfigurations_fn).call(this),
-    ..._chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _buildIdentifiedCustomNetworkClientConfigurations, buildIdentifiedCustomNetworkClientConfigurations_fn).call(this),
-    ..._chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _buildIdentifiedNetworkClientConfigurationsFromProviderConfig, buildIdentifiedNetworkClientConfigurationsFromProviderConfig_fn).call(this)
-  ].reduce(
-    (registry, [networkClientType, networkClientId, networkClientConfiguration]) => {
-      const autoManagedNetworkClient = _chunkZV34XXLTjs.createAutoManagedNetworkClient.call(void 0, 
-        networkClientConfiguration
-      );
-      if (networkClientId in registry[networkClientType]) {
-        return registry;
-      }
-      return {
-        ...registry,
-        [networkClientType]: {
-          ...registry[networkClientType],
-          [networkClientId]: autoManagedNetworkClient
-        }
-      };
-    },
-    {
-      ["infura" /* Infura */]: {},
-      ["custom" /* Custom */]: {}
-    }
-  );
-};
-_buildIdentifiedInfuraNetworkClientConfigurations = new WeakSet();
-buildIdentifiedInfuraNetworkClientConfigurations_fn = function() {
-  return knownKeysOf(_controllerutils.InfuraNetworkType).map((network) => {
-    const networkClientId = buildInfuraNetworkClientId(network);
-    const networkClientConfiguration = {
-      type: "infura" /* Infura */,
-      network,
-      infuraProjectId: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _infuraProjectId),
-      chainId: _controllerutils.BUILT_IN_NETWORKS[network].chainId,
-      ticker: _controllerutils.BUILT_IN_NETWORKS[network].ticker
-    };
-    return [
-      "infura" /* Infura */,
-      networkClientId,
-      networkClientConfiguration
-    ];
-  });
-};
-_buildIdentifiedCustomNetworkClientConfigurations = new WeakSet();
-buildIdentifiedCustomNetworkClientConfigurations_fn = function() {
-  return Object.entries(this.state.networkConfigurations).map(
-    ([networkConfigurationId, networkConfiguration]) => {
-      if (networkConfiguration.chainId === void 0) {
-        throw new Error("chainId must be provided for custom RPC endpoints");
-      }
-      if (networkConfiguration.rpcUrl === void 0) {
-        throw new Error("rpcUrl must be provided for custom RPC endpoints");
-      }
-      const networkClientId = buildCustomNetworkClientId(
-        networkConfigurationId
-      );
-      const networkClientConfiguration = {
-        type: "custom" /* Custom */,
-        chainId: networkConfiguration.chainId,
-        rpcUrl: networkConfiguration.rpcUrl,
-        ticker: networkConfiguration.ticker
-      };
-      return [
-        "custom" /* Custom */,
-        networkClientId,
-        networkClientConfiguration
-      ];
-    }
-  );
-};
-_buildIdentifiedNetworkClientConfigurationsFromProviderConfig = new WeakSet();
-buildIdentifiedNetworkClientConfigurationsFromProviderConfig_fn = function() {
-  const { providerConfig } = this.state;
-  if (isCustomProviderConfig(providerConfig)) {
-    validateCustomProviderConfig(providerConfig);
-    const networkClientId = buildCustomNetworkClientId(
-      providerConfig,
-      this.state.networkConfigurations
-    );
-    const networkClientConfiguration = {
-      chainId: providerConfig.chainId,
-      rpcUrl: providerConfig.rpcUrl,
-      type: "custom" /* Custom */,
-      ticker: providerConfig.ticker
-    };
-    return [
-      ["custom" /* Custom */, networkClientId, networkClientConfiguration]
-    ];
-  }
-  if (isInfuraProviderConfig(providerConfig)) {
-    return [];
-  }
-  throw new Error(`Unrecognized network type: '${providerConfig.type}'`);
-};
-_applyNetworkSelection = new WeakSet();
-applyNetworkSelection_fn = function() {
-  if (!_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _autoManagedNetworkClientRegistry)) {
-    throw new Error(
-      "initializeProvider must be called first in order to switch the network"
-    );
-  }
-  const { providerConfig } = this.state;
-  let autoManagedNetworkClient;
-  let networkClientId;
-  if (isInfuraProviderConfig(providerConfig)) {
-    const networkClientType = "infura" /* Infura */;
-    networkClientId = buildInfuraNetworkClientId(providerConfig);
-    const builtInNetworkClientRegistry = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _autoManagedNetworkClientRegistry)[networkClientType];
-    autoManagedNetworkClient = builtInNetworkClientRegistry[networkClientId];
-    if (!autoManagedNetworkClient) {
-      throw new Error(
-        `Could not find custom network matching ${networkClientId}`
-      );
-    }
-  } else if (isCustomProviderConfig(providerConfig)) {
-    validateCustomProviderConfig(providerConfig);
-    const networkClientType = "custom" /* Custom */;
-    networkClientId = buildCustomNetworkClientId(
-      providerConfig,
-      this.state.networkConfigurations
-    );
-    const customNetworkClientRegistry = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _autoManagedNetworkClientRegistry)[networkClientType];
-    autoManagedNetworkClient = customNetworkClientRegistry[networkClientId];
-    if (!autoManagedNetworkClient) {
-      throw new Error(
-        `Could not find built-in network matching ${networkClientId}`
-      );
-    }
-  } else {
-    throw new Error("Could not determine type of provider config");
-  }
-  this.update((state) => {
-    state.selectedNetworkClientId = networkClientId;
-    if (state.networksMetadata[networkClientId] === void 0) {
-      state.networksMetadata[networkClientId] = {
-        status: "unknown" /* Unknown */,
-        EIPS: {}
-      };
-    }
-  });
-  const { provider, blockTracker } = autoManagedNetworkClient;
-  if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _providerProxy)) {
-    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _providerProxy).setTarget(provider);
-  } else {
-    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _providerProxy, _swappableobjproxy.createEventEmitterProxy.call(void 0, provider));
-  }
-  if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _blockTrackerProxy)) {
-    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _blockTrackerProxy).setTarget(blockTracker);
-  } else {
-    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _blockTrackerProxy, _swappableobjproxy.createEventEmitterProxy.call(void 0, blockTracker, {
-      eventFilter: "skipInternal"
-    }));
-  }
-  _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _ethQuery, new (0, _ethquery2.default)(_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _providerProxy)));
-};
-
-
-
-
-
-exports.knownKeysOf = knownKeysOf; exports.defaultState = defaultState; exports.NetworkController = NetworkController;
-//# sourceMappingURL=chunk-4ZD3DTQ7.js.map
\ No newline at end of file
diff --git a/dist/chunk-4ZD3DTQ7.js.map b/dist/chunk-4ZD3DTQ7.js.map
deleted file mode 100644
index c56601b8af503b155d3d3a4ad68dd840099cea89..0000000000000000000000000000000000000000
--- a/dist/chunk-4ZD3DTQ7.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/NetworkController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport {\n  BUILT_IN_NETWORKS,\n  NetworksTicker,\n  ChainId,\n  InfuraNetworkType,\n  NetworkType,\n  isSafeChainId,\n  isInfuraNetworkType,\n} from '@metamask/controller-utils';\nimport EthQuery from '@metamask/eth-query';\nimport { errorCodes } from '@metamask/rpc-errors';\nimport { createEventEmitterProxy } from '@metamask/swappable-obj-proxy';\nimport type { SwappableProxy } from '@metamask/swappable-obj-proxy';\nimport type { Hex } from '@metamask/utils';\nimport {\n  assertIsStrictHexString,\n  hasProperty,\n  isPlainObject,\n} from '@metamask/utils';\nimport { strict as assert } from 'assert';\nimport { v4 as random } from 'uuid';\n\nimport { INFURA_BLOCKED_KEY, NetworkStatus } from './constants';\nimport type {\n  AutoManagedNetworkClient,\n  ProxyWithAccessibleTarget,\n} from './create-auto-managed-network-client';\nimport { createAutoManagedNetworkClient } from './create-auto-managed-network-client';\nimport { projectLogger, createModuleLogger } from './logger';\nimport { NetworkClientType } from './types';\nimport type {\n  BlockTracker,\n  Provider,\n  CustomNetworkClientConfiguration,\n  InfuraNetworkClientConfiguration,\n  NetworkClientConfiguration,\n} from './types';\n\nconst log = createModuleLogger(projectLogger, 'NetworkController');\n\n/**\n * @type ProviderConfig\n *\n * Configuration passed to web3-provider-engine\n * @property rpcUrl - RPC target URL.\n * @property type - Human-readable network name.\n * @property chainId - Network ID as per EIP-155.\n * @property ticker - Currency ticker.\n * @property nickname - Personalized network name.\n * @property id - Network Configuration Id.\n */\nexport type ProviderConfig = {\n  rpcUrl?: string;\n  type: NetworkType;\n  chainId: Hex;\n  ticker: string;\n  nickname?: string;\n  rpcPrefs?: { blockExplorerUrl?: string };\n  id?: NetworkConfigurationId;\n};\n\nexport type Block = {\n  baseFeePerGas?: string;\n};\n\n/**\n * Information about a network not held by any other part of state.\n */\nexport type NetworkMetadata = {\n  /**\n   * EIPs supported by the network.\n   */\n  EIPS: {\n    [eipNumber: number]: boolean;\n  };\n  /**\n   * Indicates the availability of the network\n   */\n  status: NetworkStatus;\n};\n\n/**\n * Custom RPC network information\n *\n * @property rpcUrl - RPC target URL.\n * @property chainId - Network ID as per EIP-155\n * @property nickname - Personalized network name.\n * @property ticker - Currency ticker.\n * @property rpcPrefs - Personalized preferences.\n */\nexport type NetworkConfiguration = {\n  rpcUrl: string;\n  chainId: Hex;\n  ticker: string;\n  nickname?: string;\n  rpcPrefs?: {\n    blockExplorerUrl: string;\n  };\n};\n\n/**\n * The collection of network configurations in state.\n */\ntype NetworkConfigurations = Record<\n  NetworkConfigurationId,\n  NetworkConfiguration & { id: NetworkConfigurationId }\n>;\n\n/**\n * `Object.keys()` is intentionally generic: it returns the keys of an object,\n * but it cannot make guarantees about the contents of that object, so the type\n * of the keys is merely `string[]`. While this is technically accurate, it is\n * also unnecessary if we have an object that we own and whose contents are\n * known exactly.\n *\n * TODO: Move to @metamask/utils.\n *\n * @param object - The object.\n * @returns The keys of an object, typed according to the type of the object\n * itself.\n */\nexport function knownKeysOf<K extends PropertyKey>(\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  object: Partial<Record<K, any>>,\n) {\n  return Object.keys(object) as K[];\n}\n\n/**\n * Asserts that the given value is of the given type if the given validation\n * function returns a truthy result.\n *\n * @param value - The value to validate.\n * @param validate - A function used to validate that the value is of the given\n * type. Takes the `value` as an argument and is expected to return true or\n * false.\n * @param message - The message to throw if the function does not return a\n * truthy result.\n * @throws if the function does not return a truthy result.\n */\nfunction assertOfType<Type>(\n  value: unknown,\n  validate: (value: unknown) => boolean,\n  message: string,\n): asserts value is Type {\n  assert.ok(validate(value), message);\n}\n\n/**\n * Returns a portion of the given object with only the given keys.\n *\n * @param object - An object.\n * @param keys - The keys to pick from the object.\n * @returns the portion of the object.\n */\n// TODO: Replace `any` with type\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction pick<Obj extends Record<any, any>, Keys extends keyof Obj>(\n  object: Obj,\n  keys: Keys[],\n): Pick<Obj, Keys> {\n  const pickedObject = keys.reduce<Partial<Pick<Obj, Keys>>>(\n    (finalObject, key) => {\n      return { ...finalObject, [key]: object[key] };\n    },\n    {},\n  );\n  assertOfType<Pick<Obj, Keys>>(\n    pickedObject,\n    () => keys.every((key) => key in pickedObject),\n    'The reduce did not produce an object with all of the desired keys.',\n  );\n  return pickedObject;\n}\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `code` property, such as an instance of Error.\n *\n * TODO: Move this to @metamask/utils.\n *\n * @param error - The object to check.\n * @returns True if `error` has a `code`, false otherwise.\n */\nfunction isErrorWithCode(error: unknown): error is { code: string | number } {\n  return typeof error === 'object' && error !== null && 'code' in error;\n}\n\n/**\n * Builds an identifier for an Infura network client for lookup purposes.\n *\n * @param infuraNetworkOrProviderConfig - The name of an Infura network or a\n * provider config.\n * @returns The built identifier.\n */\nfunction buildInfuraNetworkClientId(\n  infuraNetworkOrProviderConfig:\n    | InfuraNetworkType\n    | (ProviderConfig & { type: InfuraNetworkType }),\n): BuiltInNetworkClientId {\n  if (typeof infuraNetworkOrProviderConfig === 'string') {\n    return infuraNetworkOrProviderConfig;\n  }\n  return infuraNetworkOrProviderConfig.type;\n}\n\n/**\n * Builds an identifier for a custom network client for lookup purposes.\n *\n * @param args - This function can be called two ways:\n * 1. The ID of a network configuration.\n * 2. A provider config and a set of network configurations.\n * @returns The built identifier.\n */\nfunction buildCustomNetworkClientId(\n  ...args:\n    | [NetworkConfigurationId]\n    | [\n        ProviderConfig & { type: typeof NetworkType.rpc; rpcUrl: string },\n        NetworkConfigurations,\n      ]\n): CustomNetworkClientId {\n  if (args.length === 1) {\n    return args[0];\n  }\n  const [{ id, rpcUrl }, networkConfigurations] = args;\n  if (id === undefined) {\n    const matchingNetworkConfiguration = Object.values(\n      networkConfigurations,\n    ).find((networkConfiguration) => {\n      return networkConfiguration.rpcUrl === rpcUrl.toLowerCase();\n    });\n    if (matchingNetworkConfiguration) {\n      return matchingNetworkConfiguration.id;\n    }\n    return rpcUrl.toLowerCase();\n  }\n  return id;\n}\n\n/**\n * Returns whether the given provider config refers to an Infura network.\n *\n * @param providerConfig - The provider config.\n * @returns True if the provider config refers to an Infura network, false\n * otherwise.\n */\nfunction isInfuraProviderConfig(\n  providerConfig: ProviderConfig,\n): providerConfig is ProviderConfig & { type: InfuraNetworkType } {\n  return isInfuraNetworkType(providerConfig.type);\n}\n\n/**\n * Returns whether the given provider config refers to an Infura network.\n *\n * @param providerConfig - The provider config.\n * @returns True if the provider config refers to an Infura network, false\n * otherwise.\n */\nfunction isCustomProviderConfig(\n  providerConfig: ProviderConfig,\n): providerConfig is ProviderConfig & { type: typeof NetworkType.rpc } {\n  return providerConfig.type === NetworkType.rpc;\n}\n\n/**\n * As a provider config represents the settings that are used to interface with\n * an RPC endpoint, it must have both a chain ID and an RPC URL if it represents\n * a custom network. These properties _should_ be set as they are validated in\n * the UI when a user adds a custom network, but just to be safe we validate\n * them here.\n *\n * In addition, historically the `rpcUrl` property on the ProviderConfig type\n * has been optional, even though it should not be. Making this non-optional\n * would be a breaking change, so this function types the provider config\n * correctly so that we don't have to check `rpcUrl` in other places.\n *\n * @param providerConfig - A provider config.\n * @throws if the provider config does not have a chain ID or an RPC URL.\n */\nfunction validateCustomProviderConfig(\n  providerConfig: ProviderConfig & { type: typeof NetworkType.rpc },\n): asserts providerConfig is typeof providerConfig & { rpcUrl: string } {\n  if (providerConfig.chainId === undefined) {\n    throw new Error('chainId must be provided for custom RPC endpoints');\n  }\n  if (providerConfig.rpcUrl === undefined) {\n    throw new Error('rpcUrl must be provided for custom RPC endpoints');\n  }\n}\n/**\n * The string that uniquely identifies an Infura network client.\n */\nexport type BuiltInNetworkClientId = InfuraNetworkType;\n\n/**\n * The string that uniquely identifies a custom network client.\n */\nexport type CustomNetworkClientId = string;\n\n/**\n * The string that uniquely identifies a network client.\n */\nexport type NetworkClientId = BuiltInNetworkClientId | CustomNetworkClientId;\n\n/**\n * Information about networks not held by any other part of state.\n */\nexport type NetworksMetadata = {\n  [networkClientId: NetworkClientId]: NetworkMetadata;\n};\n\n/**\n * @type NetworkState\n *\n * Network controller state\n * @property providerConfig - RPC URL and network name provider settings of the currently connected network\n * @property properties - an additional set of network properties for the currently connected network\n * @property networkConfigurations - the full list of configured networks either preloaded or added by the user.\n */\nexport type NetworkState = {\n  selectedNetworkClientId: NetworkClientId;\n  providerConfig: ProviderConfig;\n  networkConfigurations: NetworkConfigurations;\n  networksMetadata: NetworksMetadata;\n};\n\nconst name = 'NetworkController';\n\n/**\n * Represents the block tracker for the currently selected network. (Note that\n * this is a proxy around a proxy: the inner one exists so that the block\n * tracker doesn't have to exist until it's used, and the outer one exists so\n * that the currently selected network can change without consumers needing to\n * refresh the object reference to that network.)\n */\nexport type BlockTrackerProxy = SwappableProxy<\n  ProxyWithAccessibleTarget<BlockTracker>\n>;\n\n/**\n * Represents the provider for the currently selected network. (Note that this\n * is a proxy around a proxy: the inner one exists so that the provider doesn't\n * have to exist until it's used, and the outer one exists so that the currently\n * selected network can change without consumers needing to refresh the object\n * reference to that network.)\n */\nexport type ProviderProxy = SwappableProxy<ProxyWithAccessibleTarget<Provider>>;\n\nexport type NetworkControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof name,\n  NetworkState\n>;\n\n/**\n * `networkWillChange` is published when the current network is about to be\n * switched, but the new provider has not been created and no state changes have\n * occurred yet.\n */\nexport type NetworkControllerNetworkWillChangeEvent = {\n  type: 'NetworkController:networkWillChange';\n  payload: [NetworkState];\n};\n\n/**\n * `networkDidChange` is published after a provider has been created for a newly\n * switched network (but before the network has been confirmed to be available).\n */\nexport type NetworkControllerNetworkDidChangeEvent = {\n  type: 'NetworkController:networkDidChange';\n  payload: [NetworkState];\n};\n\n/**\n * `infuraIsBlocked` is published after the network is switched to an Infura\n * network, but when Infura returns an error blocking the user based on their\n * location.\n */\nexport type NetworkControllerInfuraIsBlockedEvent = {\n  type: 'NetworkController:infuraIsBlocked';\n  payload: [];\n};\n\n/**\n * `infuraIsBlocked` is published either after the network is switched to an\n * Infura network and Infura does not return an error blocking the user based on\n * their location, or the network is switched to a non-Infura network.\n */\nexport type NetworkControllerInfuraIsUnblockedEvent = {\n  type: 'NetworkController:infuraIsUnblocked';\n  payload: [];\n};\n\nexport type NetworkControllerEvents =\n  | NetworkControllerStateChangeEvent\n  | NetworkControllerNetworkWillChangeEvent\n  | NetworkControllerNetworkDidChangeEvent\n  | NetworkControllerInfuraIsBlockedEvent\n  | NetworkControllerInfuraIsUnblockedEvent;\n\nexport type NetworkControllerGetStateAction = ControllerGetStateAction<\n  typeof name,\n  NetworkState\n>;\n\nexport type NetworkControllerGetProviderConfigAction = {\n  type: `NetworkController:getProviderConfig`;\n  handler: () => ProviderConfig;\n};\n\nexport type NetworkControllerGetEthQueryAction = {\n  type: `NetworkController:getEthQuery`;\n  handler: () => EthQuery | undefined;\n};\n\nexport type NetworkControllerGetNetworkClientByIdAction = {\n  type: `NetworkController:getNetworkClientById`;\n  handler: NetworkController['getNetworkClientById'];\n};\n\nexport type NetworkControllerGetSelectedNetworkClientAction = {\n  type: `NetworkController:getSelectedNetworkClient`;\n  handler: NetworkController['getSelectedNetworkClient'];\n};\n\nexport type NetworkControllerGetEIP1559CompatibilityAction = {\n  type: `NetworkController:getEIP1559Compatibility`;\n  handler: NetworkController['getEIP1559Compatibility'];\n};\n\nexport type NetworkControllerFindNetworkClientIdByChainIdAction = {\n  type: `NetworkController:findNetworkClientIdByChainId`;\n  handler: NetworkController['findNetworkClientIdByChainId'];\n};\n\n/**\n * Change the currently selected network to the given built-in network type.\n *\n * @deprecated This action has been replaced by `setActiveNetwork`, and will be\n * removed in a future release.\n */\nexport type NetworkControllerSetProviderTypeAction = {\n  type: `NetworkController:setProviderType`;\n  handler: NetworkController['setProviderType'];\n};\n\nexport type NetworkControllerSetActiveNetworkAction = {\n  type: `NetworkController:setActiveNetwork`;\n  handler: NetworkController['setActiveNetwork'];\n};\n\nexport type NetworkControllerGetNetworkConfigurationByNetworkClientId = {\n  type: `NetworkController:getNetworkConfigurationByNetworkClientId`;\n  handler: NetworkController['getNetworkConfigurationByNetworkClientId'];\n};\n\nexport type NetworkControllerActions =\n  | NetworkControllerGetStateAction\n  | NetworkControllerGetProviderConfigAction\n  | NetworkControllerGetEthQueryAction\n  | NetworkControllerGetNetworkClientByIdAction\n  | NetworkControllerGetSelectedNetworkClientAction\n  | NetworkControllerGetEIP1559CompatibilityAction\n  | NetworkControllerFindNetworkClientIdByChainIdAction\n  | NetworkControllerSetActiveNetworkAction\n  | NetworkControllerSetProviderTypeAction\n  | NetworkControllerGetNetworkConfigurationByNetworkClientId;\n\nexport type NetworkControllerMessenger = RestrictedControllerMessenger<\n  typeof name,\n  NetworkControllerActions,\n  NetworkControllerEvents,\n  never,\n  never\n>;\n\nexport type NetworkControllerOptions = {\n  messenger: NetworkControllerMessenger;\n  trackMetaMetricsEvent: () => void;\n  infuraProjectId: string;\n  state?: Partial<NetworkState>;\n};\n\nexport const defaultState: NetworkState = {\n  selectedNetworkClientId: NetworkType.mainnet,\n  providerConfig: {\n    type: NetworkType.mainnet,\n    chainId: ChainId.mainnet,\n    ticker: NetworksTicker.mainnet,\n  },\n  networksMetadata: {},\n  networkConfigurations: {},\n};\n\ntype MetaMetricsEventPayload = {\n  event: string;\n  category: string;\n  referrer?: { url: string };\n  actionId?: number;\n  environmentType?: string;\n  properties?: unknown;\n  sensitiveProperties?: unknown;\n  revenue?: number;\n  currency?: string;\n  value?: number;\n};\n\ntype NetworkConfigurationId = string;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks.\n */\ntype AutoManagedBuiltInNetworkClientRegistry = Record<\n  BuiltInNetworkClientId,\n  AutoManagedNetworkClient<InfuraNetworkClientConfiguration>\n>;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks.\n */\ntype AutoManagedCustomNetworkClientRegistry = Record<\n  CustomNetworkClientId,\n  AutoManagedNetworkClient<CustomNetworkClientConfiguration>\n>;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks\n * as well as custom networks that users have added.\n */\ntype AutoManagedNetworkClientRegistry = {\n  [NetworkClientType.Infura]: AutoManagedBuiltInNetworkClientRegistry;\n  [NetworkClientType.Custom]: AutoManagedCustomNetworkClientRegistry;\n};\n\n/**\n * Controller that creates and manages an Ethereum network provider.\n */\nexport class NetworkController extends BaseController<\n  typeof name,\n  NetworkState,\n  NetworkControllerMessenger\n> {\n  #ethQuery?: EthQuery;\n\n  #infuraProjectId: string;\n\n  #trackMetaMetricsEvent: (event: MetaMetricsEventPayload) => void;\n\n  #previousProviderConfig: ProviderConfig;\n\n  #providerProxy: ProviderProxy | undefined;\n\n  #blockTrackerProxy: BlockTrackerProxy | undefined;\n\n  #autoManagedNetworkClientRegistry?: AutoManagedNetworkClientRegistry;\n\n  constructor({\n    messenger,\n    state,\n    infuraProjectId,\n    trackMetaMetricsEvent,\n  }: NetworkControllerOptions) {\n    super({\n      name,\n      metadata: {\n        selectedNetworkClientId: {\n          persist: true,\n          anonymous: false,\n        },\n        networksMetadata: {\n          persist: true,\n          anonymous: false,\n        },\n        providerConfig: {\n          persist: true,\n          anonymous: false,\n        },\n        networkConfigurations: {\n          persist: true,\n          anonymous: false,\n        },\n      },\n      messenger,\n      state: { ...defaultState, ...state },\n    });\n    if (!infuraProjectId || typeof infuraProjectId !== 'string') {\n      throw new Error('Invalid Infura project ID');\n    }\n    this.#infuraProjectId = infuraProjectId;\n    this.#trackMetaMetricsEvent = trackMetaMetricsEvent;\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getProviderConfig`,\n      () => {\n        return this.state.providerConfig;\n      },\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getEthQuery`,\n      () => {\n        return this.#ethQuery;\n      },\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getNetworkClientById`,\n      this.getNetworkClientById.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getEIP1559Compatibility`,\n      this.getEIP1559Compatibility.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:setActiveNetwork`,\n      this.setActiveNetwork.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:setProviderType`,\n      this.setProviderType.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:findNetworkClientIdByChainId`,\n      this.findNetworkClientIdByChainId.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getNetworkConfigurationByNetworkClientId`,\n      this.getNetworkConfigurationByNetworkClientId.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getSelectedNetworkClient`,\n      this.getSelectedNetworkClient.bind(this),\n    );\n\n    this.#previousProviderConfig = this.state.providerConfig;\n  }\n\n  /**\n   * Accesses the provider and block tracker for the currently selected network.\n   * @returns The proxy and block tracker proxies.\n   * @deprecated This method has been replaced by `getSelectedNetworkClient` (which has a more easily used return type) and will be removed in a future release.\n   */\n  getProviderAndBlockTracker(): {\n    provider: SwappableProxy<ProxyWithAccessibleTarget<Provider>> | undefined;\n    blockTracker:\n      | SwappableProxy<ProxyWithAccessibleTarget<BlockTracker>>\n      | undefined;\n  } {\n    return {\n      provider: this.#providerProxy,\n      blockTracker: this.#blockTrackerProxy,\n    };\n  }\n\n  /**\n   * Accesses the provider and block tracker for the currently selected network.\n   *\n   * @returns an object with the provider and block tracker proxies for the currently selected network.\n   */\n  getSelectedNetworkClient():\n    | {\n        provider: SwappableProxy<ProxyWithAccessibleTarget<Provider>>;\n        blockTracker: SwappableProxy<ProxyWithAccessibleTarget<BlockTracker>>;\n      }\n    | undefined {\n    if (this.#providerProxy && this.#blockTrackerProxy) {\n      return {\n        provider: this.#providerProxy,\n        blockTracker: this.#blockTrackerProxy,\n      };\n    }\n    return undefined;\n  }\n\n  /**\n   * Returns all of the network clients that have been created so far, keyed by\n   * their identifier in the network client registry. This collection represents\n   * not only built-in networks but also any custom networks that consumers have\n   * added.\n   *\n   * @returns The list of known network clients.\n   */\n  getNetworkClientRegistry(): AutoManagedBuiltInNetworkClientRegistry &\n    AutoManagedCustomNetworkClientRegistry {\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    return Object.assign(\n      {},\n      autoManagedNetworkClientRegistry[NetworkClientType.Infura],\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom],\n    );\n  }\n\n  /**\n   * Returns the Infura network client with the given ID.\n   *\n   * @param infuraNetworkClientId - An Infura network client ID.\n   * @returns The Infura network client.\n   * @throws If an Infura network client does not exist with the given ID.\n   */\n  getNetworkClientById(\n    infuraNetworkClientId: BuiltInNetworkClientId,\n  ): AutoManagedNetworkClient<InfuraNetworkClientConfiguration>;\n\n  /**\n   * Returns the custom network client with the given ID.\n   *\n   * @param customNetworkClientId - A custom network client ID.\n   * @returns The custom network client.\n   * @throws If a custom network client does not exist with the given ID.\n   */\n  getNetworkClientById(\n    customNetworkClientId: CustomNetworkClientId,\n  ): AutoManagedNetworkClient<CustomNetworkClientConfiguration>;\n\n  getNetworkClientById(\n    networkClientId: NetworkClientId,\n  ): AutoManagedNetworkClient<NetworkClientConfiguration> {\n    if (!networkClientId) {\n      throw new Error('No network client ID was provided.');\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    if (isInfuraNetworkType(networkClientId)) {\n      const infuraNetworkClient =\n        autoManagedNetworkClientRegistry[NetworkClientType.Infura][\n          networkClientId\n        ];\n      if (!infuraNetworkClient) {\n        throw new Error(\n          `No Infura network client was found with the ID \"${networkClientId}\".`,\n        );\n      }\n      return infuraNetworkClient;\n    }\n\n    const customNetworkClient =\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom][\n        networkClientId\n      ];\n    if (!customNetworkClient) {\n      throw new Error(\n        `No custom network client was found with the ID \"${networkClientId}\".`,\n      );\n    }\n    return customNetworkClient;\n  }\n\n  /**\n   * Executes a series of steps to apply the changes to the provider config:\n   *\n   * 1. Notifies subscribers that the network is about to change.\n   * 2. Looks up a known and preinitialized network client matching the provider\n   * config and re-points the provider and block tracker proxy to it.\n   * 3. Notifies subscribers that the network has changed.\n   */\n  async #refreshNetwork() {\n    this.messagingSystem.publish(\n      'NetworkController:networkWillChange',\n      this.state,\n    );\n    this.#applyNetworkSelection();\n    this.messagingSystem.publish(\n      'NetworkController:networkDidChange',\n      this.state,\n    );\n    await this.lookupNetwork();\n  }\n\n  /**\n   * Populates the network clients and establishes the initial network based on\n   * the provider configuration in state.\n   */\n  async initializeProvider() {\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.#applyNetworkSelection();\n    await this.lookupNetwork();\n  }\n\n  /**\n   * Refreshes the network meta with EIP-1559 support and the network status\n   * based on the given network client ID.\n   *\n   * @param networkClientId - The ID of the network client to update.\n   */\n  async lookupNetworkByClientId(networkClientId: NetworkClientId) {\n    const isInfura = isInfuraNetworkType(networkClientId);\n    let updatedNetworkStatus: NetworkStatus;\n    let updatedIsEIP1559Compatible: boolean | undefined;\n\n    try {\n      updatedIsEIP1559Compatible = await this.#determineEIP1559Compatibility(\n        networkClientId,\n      );\n      updatedNetworkStatus = NetworkStatus.Available;\n    } catch (error) {\n      if (isErrorWithCode(error)) {\n        let responseBody;\n        if (\n          isInfura &&\n          hasProperty(error, 'message') &&\n          typeof error.message === 'string'\n        ) {\n          try {\n            responseBody = JSON.parse(error.message);\n          } catch {\n            // error.message must not be JSON\n          }\n        }\n\n        if (\n          isPlainObject(responseBody) &&\n          responseBody.error === INFURA_BLOCKED_KEY\n        ) {\n          updatedNetworkStatus = NetworkStatus.Blocked;\n        } else if (error.code === errorCodes.rpc.internal) {\n          updatedNetworkStatus = NetworkStatus.Unknown;\n        } else {\n          updatedNetworkStatus = NetworkStatus.Unavailable;\n        }\n      } else if (\n        typeof Error !== 'undefined' &&\n        hasProperty(error as unknown as Error, 'message') &&\n        typeof (error as unknown as Error).message === 'string' &&\n        (error as unknown as Error).message.includes(\n          'No custom network client was found with the ID',\n        )\n      ) {\n        throw error;\n      } else {\n        log('NetworkController - could not determine network status', error);\n        updatedNetworkStatus = NetworkStatus.Unknown;\n      }\n    }\n    this.update((state) => {\n      if (state.networksMetadata[networkClientId] === undefined) {\n        state.networksMetadata[networkClientId] = {\n          status: NetworkStatus.Unknown,\n          EIPS: {},\n        };\n      }\n      const meta = state.networksMetadata[networkClientId];\n      meta.status = updatedNetworkStatus;\n      if (updatedIsEIP1559Compatible === undefined) {\n        delete meta.EIPS[1559];\n      } else {\n        meta.EIPS[1559] = updatedIsEIP1559Compatible;\n      }\n    });\n  }\n\n  /**\n   * Performs side effects after switching to a network. If the network is\n   * available, updates the network state with the network ID of the network and\n   * stores whether the network supports EIP-1559; otherwise clears said\n   * information about the network that may have been previously stored.\n   *\n   * @param networkClientId - (Optional) The ID of the network client to update.\n   * If no ID is provided, uses the currently selected network.\n   * @fires infuraIsBlocked if the network is Infura-supported and is blocking\n   * requests.\n   * @fires infuraIsUnblocked if the network is Infura-supported and is not\n   * blocking requests, or if the network is not Infura-supported.\n   */\n  async lookupNetwork(networkClientId?: NetworkClientId) {\n    if (networkClientId) {\n      await this.lookupNetworkByClientId(networkClientId);\n      return;\n    }\n\n    if (!this.#ethQuery) {\n      return;\n    }\n\n    const isInfura = isInfuraProviderConfig(this.state.providerConfig);\n\n    let networkChanged = false;\n    const listener = () => {\n      networkChanged = true;\n      this.messagingSystem.unsubscribe(\n        'NetworkController:networkDidChange',\n        listener,\n      );\n    };\n    this.messagingSystem.subscribe(\n      'NetworkController:networkDidChange',\n      listener,\n    );\n\n    let updatedNetworkStatus: NetworkStatus;\n    let updatedIsEIP1559Compatible: boolean | undefined;\n\n    try {\n      const isEIP1559Compatible = await this.#determineEIP1559Compatibility(\n        this.state.selectedNetworkClientId,\n      );\n      updatedNetworkStatus = NetworkStatus.Available;\n      updatedIsEIP1559Compatible = isEIP1559Compatible;\n    } catch (error) {\n      if (isErrorWithCode(error)) {\n        let responseBody;\n        if (\n          isInfura &&\n          hasProperty(error, 'message') &&\n          typeof error.message === 'string'\n        ) {\n          try {\n            responseBody = JSON.parse(error.message);\n          } catch {\n            // error.message must not be JSON\n          }\n        }\n\n        if (\n          isPlainObject(responseBody) &&\n          responseBody.error === INFURA_BLOCKED_KEY\n        ) {\n          updatedNetworkStatus = NetworkStatus.Blocked;\n        } else if (error.code === errorCodes.rpc.internal) {\n          updatedNetworkStatus = NetworkStatus.Unknown;\n        } else {\n          updatedNetworkStatus = NetworkStatus.Unavailable;\n        }\n      } else {\n        log('NetworkController - could not determine network status', error);\n        updatedNetworkStatus = NetworkStatus.Unknown;\n      }\n    }\n\n    if (networkChanged) {\n      // If the network has changed, then `lookupNetwork` either has been or is\n      // in the process of being called, so we don't need to go further.\n      return;\n    }\n    this.messagingSystem.unsubscribe(\n      'NetworkController:networkDidChange',\n      listener,\n    );\n\n    this.update((state) => {\n      const meta = state.networksMetadata[state.selectedNetworkClientId];\n      meta.status = updatedNetworkStatus;\n      if (updatedIsEIP1559Compatible === undefined) {\n        delete meta.EIPS[1559];\n      } else {\n        meta.EIPS[1559] = updatedIsEIP1559Compatible;\n      }\n    });\n\n    if (isInfura) {\n      if (updatedNetworkStatus === NetworkStatus.Available) {\n        this.messagingSystem.publish('NetworkController:infuraIsUnblocked');\n      } else if (updatedNetworkStatus === NetworkStatus.Blocked) {\n        this.messagingSystem.publish('NetworkController:infuraIsBlocked');\n      }\n    } else {\n      // Always publish infuraIsUnblocked regardless of network status to\n      // prevent consumers from being stuck in a blocked state if they were\n      // previously connected to an Infura network that was blocked\n      this.messagingSystem.publish('NetworkController:infuraIsUnblocked');\n    }\n  }\n\n  /**\n   * Convenience method to update provider network type settings.\n   *\n   * @param type - Human readable network name.\n   * @deprecated This has been replaced by `setActiveNetwork`, and will be\n   * removed in a future release\n   */\n  async setProviderType(type: InfuraNetworkType) {\n    assert.notStrictEqual(\n      type,\n      NetworkType.rpc,\n      `NetworkController - cannot call \"setProviderType\" with type \"${NetworkType.rpc}\". Use \"setActiveNetwork\"`,\n    );\n    assert.ok(\n      isInfuraNetworkType(type),\n      `Unknown Infura provider type \"${type}\".`,\n    );\n\n    await this.setActiveNetwork(type);\n  }\n\n  /**\n   * Convenience method to update provider RPC settings.\n   *\n   * @param networkConfigurationIdOrType - The unique id for the network configuration to set as the active provider,\n   * or the type of a built-in network.\n   */\n  async setActiveNetwork(networkConfigurationIdOrType: string) {\n    this.#previousProviderConfig = this.state.providerConfig;\n\n    let targetNetwork: ProviderConfig;\n    if (isInfuraNetworkType(networkConfigurationIdOrType)) {\n      const ticker = NetworksTicker[networkConfigurationIdOrType];\n\n      targetNetwork = {\n        chainId: ChainId[networkConfigurationIdOrType],\n        id: undefined,\n        rpcPrefs: BUILT_IN_NETWORKS[networkConfigurationIdOrType].rpcPrefs,\n        rpcUrl: undefined,\n        nickname: undefined,\n        ticker,\n        type: networkConfigurationIdOrType,\n      };\n    } else {\n      if (\n        !Object.keys(this.state.networkConfigurations).includes(\n          networkConfigurationIdOrType,\n        )\n      ) {\n        throw new Error(\n          `networkConfigurationId ${networkConfigurationIdOrType} does not match a configured networkConfiguration or built-in network type`,\n        );\n      }\n      targetNetwork = {\n        ...this.state.networkConfigurations[networkConfigurationIdOrType],\n        type: NetworkType.rpc,\n      };\n    }\n\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.update((state) => {\n      state.providerConfig = targetNetwork;\n    });\n\n    await this.#refreshNetwork();\n  }\n\n  /**\n   * Fetches the latest block for the network.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check the latest block. Defaults to the selectedNetworkClientId.\n   * @returns A promise that either resolves to the block header or null if\n   * there is no latest block, or rejects with an error.\n   */\n  #getLatestBlock(networkClientId: NetworkClientId): Promise<Block> {\n    if (networkClientId === undefined) {\n      networkClientId = this.state.selectedNetworkClientId;\n    }\n\n    const networkClient = this.getNetworkClientById(networkClientId);\n    const ethQuery = new EthQuery(networkClient.provider);\n\n    return new Promise((resolve, reject) => {\n      ethQuery.sendAsync(\n        { method: 'eth_getBlockByNumber', params: ['latest', false] },\n        (error: unknown, block?: unknown) => {\n          if (error) {\n            reject(error);\n          } else {\n            // TODO: Validate this type\n            resolve(block as Block);\n          }\n        },\n      );\n    });\n  }\n\n  /**\n   * Determines whether the network supports EIP-1559 by checking whether the\n   * latest block has a `baseFeePerGas` property, then updates state\n   * appropriately.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility.\n   * @returns A promise that resolves to true if the network supports EIP-1559\n   * , false otherwise, or `undefined` if unable to determine the compatibility.\n   */\n  async getEIP1559Compatibility(networkClientId?: NetworkClientId) {\n    if (networkClientId) {\n      return this.get1559CompatibilityWithNetworkClientId(networkClientId);\n    }\n    if (!this.#ethQuery) {\n      return false;\n    }\n\n    const { EIPS } =\n      this.state.networksMetadata[this.state.selectedNetworkClientId];\n\n    if (EIPS[1559] !== undefined) {\n      return EIPS[1559];\n    }\n\n    const isEIP1559Compatible = await this.#determineEIP1559Compatibility(\n      this.state.selectedNetworkClientId,\n    );\n    this.update((state) => {\n      if (isEIP1559Compatible !== undefined) {\n        state.networksMetadata[state.selectedNetworkClientId].EIPS[1559] =\n          isEIP1559Compatible;\n      }\n    });\n    return isEIP1559Compatible;\n  }\n\n  async get1559CompatibilityWithNetworkClientId(\n    networkClientId: NetworkClientId,\n  ) {\n    let metadata = this.state.networksMetadata[networkClientId];\n    if (metadata === undefined) {\n      await this.lookupNetwork(networkClientId);\n      metadata = this.state.networksMetadata[networkClientId];\n    }\n    const { EIPS } = metadata;\n\n    // may want to include some 'freshness' value - something to make sure we refetch this from time to time\n    return EIPS[1559];\n  }\n\n  /**\n   * Retrieves and checks the latest block from the currently selected\n   * network; if the block has a `baseFeePerGas` property, then we know\n   * that the network supports EIP-1559; otherwise it doesn't.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility\n   * @returns A promise that resolves to `true` if the network supports EIP-1559,\n   * `false` otherwise, or `undefined` if unable to retrieve the last block.\n   */\n  async #determineEIP1559Compatibility(\n    networkClientId: NetworkClientId,\n  ): Promise<boolean | undefined> {\n    const latestBlock = await this.#getLatestBlock(networkClientId);\n\n    if (!latestBlock) {\n      return undefined;\n    }\n\n    return latestBlock.baseFeePerGas !== undefined;\n  }\n\n  /**\n   * Re-initializes the provider and block tracker for the current network.\n   */\n  async resetConnection() {\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n    await this.#refreshNetwork();\n  }\n\n  /**\n   * Returns a configuration object for the network identified by the given\n   * network client ID. If given an Infura network type, constructs one based on\n   * what we know about the network; otherwise attempts locates a network\n   * configuration in state that corresponds to the network client ID.\n   *\n   * @param networkClientId - The network client ID.\n   * @returns The configuration for the referenced network if one exists, or\n   * undefined otherwise.\n   */\n  getNetworkConfigurationByNetworkClientId(\n    networkClientId: NetworkClientId,\n  ): NetworkConfiguration | undefined {\n    if (isInfuraNetworkType(networkClientId)) {\n      const rpcUrl = `https://${networkClientId}.infura.io/v3/${\n        this.#infuraProjectId\n      }`;\n      return {\n        rpcUrl,\n        ...BUILT_IN_NETWORKS[networkClientId],\n      };\n    }\n\n    return this.state.networkConfigurations[networkClientId];\n  }\n\n  /**\n   * Adds a new custom network or updates the information for an existing\n   * network.\n   *\n   * This may involve updating the `networkConfigurations` property in\n   * state as well and/or adding a new network client to the network client\n   * registry. The `rpcUrl` and `chainId` of the given object are used to\n   * determine which action to take:\n   *\n   * - If the `rpcUrl` corresponds to an existing network configuration\n   * (case-insensitively), then it is overwritten with the object. Furthermore,\n   * if the `chainId` is different from the existing network configuration, then\n   * the existing network client is replaced with a new one.\n   * - If the `rpcUrl` does not correspond to an existing network configuration\n   * (case-insensitively), then the object is used to add a new network\n   * configuration along with a new network client.\n   *\n   * @param networkConfiguration - The network configuration to add or update.\n   * @param options - Additional configuration options.\n   * @param options.referrer - Used to create a metrics event; the site from which the call originated, or 'metamask' for internal calls.\n   * @param options.source - Used to create a metrics event; where the event originated (i.e. from a dapp or from the network form).\n   * @param options.setActive - If true, switches to the network upon adding or updating it (default: false).\n   * @returns The ID for the added or updated network configuration.\n   */\n  async upsertNetworkConfiguration(\n    networkConfiguration: NetworkConfiguration,\n    {\n      referrer,\n      source,\n      setActive = false,\n    }: {\n      referrer: string;\n      source: string;\n      setActive?: boolean;\n    },\n  ): Promise<string> {\n    const sanitizedNetworkConfiguration: NetworkConfiguration = pick(\n      networkConfiguration,\n      ['rpcUrl', 'chainId', 'ticker', 'nickname', 'rpcPrefs'],\n    );\n    const { rpcUrl, chainId, ticker } = sanitizedNetworkConfiguration;\n\n    assertIsStrictHexString(chainId);\n    if (!isSafeChainId(chainId)) {\n      throw new Error(\n        `Invalid chain ID \"${chainId}\": numerical value greater than max safe value.`,\n      );\n    }\n    if (!rpcUrl) {\n      throw new Error(\n        'An rpcUrl is required to add or update network configuration',\n      );\n    }\n    if (!referrer || !source) {\n      throw new Error(\n        'referrer and source are required arguments for adding or updating a network configuration',\n      );\n    }\n    try {\n      new URL(rpcUrl);\n      // TODO: Replace `any` with type\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      if (e.message.includes('Invalid URL')) {\n        throw new Error('rpcUrl must be a valid URL');\n      }\n    }\n    if (!ticker) {\n      throw new Error(\n        'A ticker is required to add or update networkConfiguration',\n      );\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    const existingNetworkConfiguration = Object.values(\n      this.state.networkConfigurations,\n    ).find(\n      (networkConfig) =>\n        networkConfig.rpcUrl.toLowerCase() === rpcUrl.toLowerCase(),\n    );\n    const upsertedNetworkConfigurationId = existingNetworkConfiguration\n      ? existingNetworkConfiguration.id\n      : random();\n    const networkClientId = buildCustomNetworkClientId(\n      upsertedNetworkConfigurationId,\n    );\n\n    const customNetworkClientRegistry =\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom];\n    const existingAutoManagedNetworkClient =\n      customNetworkClientRegistry[networkClientId];\n    const shouldDestroyExistingNetworkClient =\n      existingAutoManagedNetworkClient &&\n      existingAutoManagedNetworkClient.configuration.chainId !== chainId;\n    if (shouldDestroyExistingNetworkClient) {\n      existingAutoManagedNetworkClient.destroy();\n    }\n    if (\n      !existingAutoManagedNetworkClient ||\n      shouldDestroyExistingNetworkClient\n    ) {\n      customNetworkClientRegistry[networkClientId] =\n        createAutoManagedNetworkClient({\n          type: NetworkClientType.Custom,\n          chainId,\n          rpcUrl,\n          ticker,\n        });\n    }\n\n    this.update((state) => {\n      state.networkConfigurations[upsertedNetworkConfigurationId] = {\n        id: upsertedNetworkConfigurationId,\n        ...sanitizedNetworkConfiguration,\n      };\n    });\n\n    if (!existingNetworkConfiguration) {\n      this.#trackMetaMetricsEvent({\n        event: 'Custom Network Added',\n        category: 'Network',\n        referrer: {\n          url: referrer,\n        },\n        properties: {\n          chain_id: chainId,\n          symbol: ticker,\n          source,\n        },\n      });\n    }\n\n    if (setActive) {\n      await this.setActiveNetwork(upsertedNetworkConfigurationId);\n    }\n\n    return upsertedNetworkConfigurationId;\n  }\n\n  /**\n   * Removes a custom network from state.\n   *\n   * This involves updating the `networkConfigurations` property in state as\n   * well and removing the network client that corresponds to the network from\n   * the client registry.\n   *\n   * @param networkConfigurationId - The ID of an existing network\n   * configuration.\n   */\n  removeNetworkConfiguration(networkConfigurationId: string) {\n    if (!this.state.networkConfigurations[networkConfigurationId]) {\n      throw new Error(\n        `networkConfigurationId ${networkConfigurationId} does not match a configured networkConfiguration`,\n      );\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n    const networkClientId = buildCustomNetworkClientId(networkConfigurationId);\n\n    this.update((state) => {\n      delete state.networkConfigurations[networkConfigurationId];\n    });\n\n    const customNetworkClientRegistry =\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom];\n    const existingAutoManagedNetworkClient =\n      customNetworkClientRegistry[networkClientId];\n    existingAutoManagedNetworkClient.destroy();\n    delete customNetworkClientRegistry[networkClientId];\n  }\n\n  /**\n   * Switches to the previously selected network, assuming that there is one\n   * (if not and `initializeProvider` has not been previously called, then this\n   * method is equivalent to calling `resetConnection`).\n   */\n  async rollbackToPreviousProvider() {\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.update((state) => {\n      state.providerConfig = this.#previousProviderConfig;\n    });\n\n    await this.#refreshNetwork();\n  }\n\n  /**\n   * Deactivates the controller, stopping any ongoing polling.\n   *\n   * In-progress requests will not be aborted.\n   */\n  async destroy() {\n    await this.#blockTrackerProxy?.destroy();\n  }\n\n  /**\n   * Updates the controller using the given backup data.\n   *\n   * @param backup - The data that has been backed up.\n   * @param backup.networkConfigurations - Network configurations in the backup.\n   */\n  loadBackup({\n    networkConfigurations,\n  }: {\n    networkConfigurations: NetworkState['networkConfigurations'];\n  }): void {\n    this.update((state) => {\n      state.networkConfigurations = {\n        ...state.networkConfigurations,\n        ...networkConfigurations,\n      };\n    });\n  }\n\n  /**\n   * Searches for a network configuration ID with the given ChainID and returns it.\n   *\n   * @param chainId - ChainId to search for\n   * @returns networkClientId of the network configuration with the given chainId\n   */\n  findNetworkClientIdByChainId(chainId: Hex): NetworkClientId {\n    const networkClients = this.getNetworkClientRegistry();\n    const networkClientEntry = Object.entries(networkClients).find(\n      ([_, networkClient]) => networkClient.configuration.chainId === chainId,\n    );\n    if (networkClientEntry === undefined) {\n      throw new Error(\"Couldn't find networkClientId for chainId\");\n    }\n    return networkClientEntry[0];\n  }\n\n  /**\n   * Before accessing or switching the network, the registry of network clients\n   * needs to be populated. Otherwise, `#applyNetworkSelection` and\n   * `getNetworkClientRegistry` will throw an error. This method checks to see if the\n   * population step has happened yet, and if not, makes it happen.\n   *\n   * @returns The populated network client registry.\n   */\n  #ensureAutoManagedNetworkClientRegistryPopulated(): AutoManagedNetworkClientRegistry {\n    const autoManagedNetworkClientRegistry =\n      this.#autoManagedNetworkClientRegistry ??\n      this.#createAutoManagedNetworkClientRegistry();\n    this.#autoManagedNetworkClientRegistry = autoManagedNetworkClientRegistry;\n    return autoManagedNetworkClientRegistry;\n  }\n\n  /**\n   * Constructs the registry of network clients based on the set of built-in\n   * networks as well as the custom networks in state.\n   *\n   * @returns The network clients keyed by ID.\n   */\n  #createAutoManagedNetworkClientRegistry(): AutoManagedNetworkClientRegistry {\n    return [\n      ...this.#buildIdentifiedInfuraNetworkClientConfigurations(),\n      ...this.#buildIdentifiedCustomNetworkClientConfigurations(),\n      ...this.#buildIdentifiedNetworkClientConfigurationsFromProviderConfig(),\n    ].reduce(\n      (\n        registry,\n        [networkClientType, networkClientId, networkClientConfiguration],\n      ) => {\n        const autoManagedNetworkClient = createAutoManagedNetworkClient(\n          networkClientConfiguration,\n        );\n        if (networkClientId in registry[networkClientType]) {\n          return registry;\n        }\n        return {\n          ...registry,\n          [networkClientType]: {\n            ...registry[networkClientType],\n            [networkClientId]: autoManagedNetworkClient,\n          },\n        };\n      },\n      {\n        [NetworkClientType.Infura]: {},\n        [NetworkClientType.Custom]: {},\n      },\n    ) as AutoManagedNetworkClientRegistry;\n  }\n\n  /**\n   * Constructs the list of network clients for built-in networks (that is,\n   * the subset of the networks we know Infura supports that consumers do not\n   * need to explicitly add).\n   *\n   * @returns The network clients.\n   */\n  #buildIdentifiedInfuraNetworkClientConfigurations(): [\n    NetworkClientType.Infura,\n    BuiltInNetworkClientId,\n    InfuraNetworkClientConfiguration,\n  ][] {\n    return knownKeysOf(InfuraNetworkType).map((network) => {\n      const networkClientId = buildInfuraNetworkClientId(network);\n      const networkClientConfiguration: InfuraNetworkClientConfiguration = {\n        type: NetworkClientType.Infura,\n        network,\n        infuraProjectId: this.#infuraProjectId,\n        chainId: BUILT_IN_NETWORKS[network].chainId,\n        ticker: BUILT_IN_NETWORKS[network].ticker,\n      };\n      return [\n        NetworkClientType.Infura,\n        networkClientId,\n        networkClientConfiguration,\n      ];\n    });\n  }\n\n  /**\n   * Constructs the list of network clients for custom networks (that is, those\n   * which consumers have added via `networkConfigurations`).\n   *\n   * @returns The network clients.\n   */\n  #buildIdentifiedCustomNetworkClientConfigurations(): [\n    NetworkClientType.Custom,\n    CustomNetworkClientId,\n    CustomNetworkClientConfiguration,\n  ][] {\n    return Object.entries(this.state.networkConfigurations).map(\n      ([networkConfigurationId, networkConfiguration]) => {\n        if (networkConfiguration.chainId === undefined) {\n          throw new Error('chainId must be provided for custom RPC endpoints');\n        }\n        if (networkConfiguration.rpcUrl === undefined) {\n          throw new Error('rpcUrl must be provided for custom RPC endpoints');\n        }\n        const networkClientId = buildCustomNetworkClientId(\n          networkConfigurationId,\n        );\n        const networkClientConfiguration: CustomNetworkClientConfiguration = {\n          type: NetworkClientType.Custom,\n          chainId: networkConfiguration.chainId,\n          rpcUrl: networkConfiguration.rpcUrl,\n          ticker: networkConfiguration.ticker,\n        };\n        return [\n          NetworkClientType.Custom,\n          networkClientId,\n          networkClientConfiguration,\n        ];\n      },\n    );\n  }\n\n  /**\n   * Converts the provider config object in state to a network client\n   * configuration object.\n   *\n   * @returns The network client config.\n   * @throws If the provider config is of type \"rpc\" and lacks either a\n   * `chainId` or an `rpcUrl`.\n   */\n  #buildIdentifiedNetworkClientConfigurationsFromProviderConfig():\n    | [\n        [\n          NetworkClientType.Custom,\n          CustomNetworkClientId,\n          CustomNetworkClientConfiguration,\n        ],\n      ]\n    | [] {\n    const { providerConfig } = this.state;\n\n    if (isCustomProviderConfig(providerConfig)) {\n      validateCustomProviderConfig(providerConfig);\n      const networkClientId = buildCustomNetworkClientId(\n        providerConfig,\n        this.state.networkConfigurations,\n      );\n      const networkClientConfiguration: CustomNetworkClientConfiguration = {\n        chainId: providerConfig.chainId,\n        rpcUrl: providerConfig.rpcUrl,\n        type: NetworkClientType.Custom,\n        ticker: providerConfig.ticker,\n      };\n      return [\n        [NetworkClientType.Custom, networkClientId, networkClientConfiguration],\n      ];\n    }\n\n    if (isInfuraProviderConfig(providerConfig)) {\n      return [];\n    }\n\n    throw new Error(`Unrecognized network type: '${providerConfig.type}'`);\n  }\n\n  /**\n   * Uses the information in the provider config object to look up a known and\n   * preinitialized network client. Once a network client is found, updates the\n   * provider and block tracker proxy to point to those from the network client,\n   * then finally creates an EthQuery that points to the provider proxy.\n   *\n   * @throws If no network client could be found matching the current provider\n   * config.\n   */\n  #applyNetworkSelection() {\n    if (!this.#autoManagedNetworkClientRegistry) {\n      throw new Error(\n        'initializeProvider must be called first in order to switch the network',\n      );\n    }\n\n    const { providerConfig } = this.state;\n\n    let autoManagedNetworkClient: AutoManagedNetworkClient<NetworkClientConfiguration>;\n\n    let networkClientId: NetworkClientId;\n    if (isInfuraProviderConfig(providerConfig)) {\n      const networkClientType = NetworkClientType.Infura;\n      networkClientId = buildInfuraNetworkClientId(providerConfig);\n      const builtInNetworkClientRegistry =\n        this.#autoManagedNetworkClientRegistry[networkClientType];\n      autoManagedNetworkClient =\n        builtInNetworkClientRegistry[networkClientId as BuiltInNetworkClientId];\n      if (!autoManagedNetworkClient) {\n        throw new Error(\n          `Could not find custom network matching ${networkClientId}`,\n        );\n      }\n    } else if (isCustomProviderConfig(providerConfig)) {\n      validateCustomProviderConfig(providerConfig);\n      const networkClientType = NetworkClientType.Custom;\n      networkClientId = buildCustomNetworkClientId(\n        providerConfig,\n        this.state.networkConfigurations,\n      );\n      const customNetworkClientRegistry =\n        this.#autoManagedNetworkClientRegistry[networkClientType];\n      autoManagedNetworkClient = customNetworkClientRegistry[networkClientId];\n      if (!autoManagedNetworkClient) {\n        throw new Error(\n          `Could not find built-in network matching ${networkClientId}`,\n        );\n      }\n    } else {\n      throw new Error('Could not determine type of provider config');\n    }\n\n    this.update((state) => {\n      state.selectedNetworkClientId = networkClientId;\n      if (state.networksMetadata[networkClientId] === undefined) {\n        state.networksMetadata[networkClientId] = {\n          status: NetworkStatus.Unknown,\n          EIPS: {},\n        };\n      }\n    });\n\n    const { provider, blockTracker } = autoManagedNetworkClient;\n\n    if (this.#providerProxy) {\n      this.#providerProxy.setTarget(provider);\n    } else {\n      this.#providerProxy = createEventEmitterProxy(provider);\n    }\n\n    if (this.#blockTrackerProxy) {\n      this.#blockTrackerProxy.setTarget(blockTracker);\n    } else {\n      this.#blockTrackerProxy = createEventEmitterProxy(blockTracker, {\n        eventFilter: 'skipInternal',\n      });\n    }\n\n    this.#ethQuery = new EthQuery(this.#providerProxy);\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/chunk-6EXWS63D.mjs b/dist/chunk-6EXWS63D.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..629e671e925a5360650e6f7b10f3e4954a5c4cdc
--- /dev/null
+++ b/dist/chunk-6EXWS63D.mjs
@@ -0,0 +1,1034 @@
+import {
+  INFURA_BLOCKED_KEY
+} from "./chunk-2QJYHWIP.mjs";
+import {
+  createAutoManagedNetworkClient
+} from "./chunk-G5HYTGGH.mjs";
+import {
+  createModuleLogger,
+  projectLogger
+} from "./chunk-VTLOAS2R.mjs";
+import {
+  __privateAdd,
+  __privateGet,
+  __privateMethod,
+  __privateSet
+} from "./chunk-XUI43LEZ.mjs";
+
+// src/NetworkController.ts
+import { BaseController } from "@metamask/base-controller";
+import {
+  BUILT_IN_NETWORKS,
+  NetworksTicker,
+  ChainId,
+  InfuraNetworkType,
+  NetworkType,
+  isSafeChainId,
+  isInfuraNetworkType
+} from "@metamask/controller-utils";
+import EthQuery from "@metamask/eth-query";
+import { errorCodes } from "@metamask/rpc-errors";
+import { createEventEmitterProxy } from "@metamask/swappable-obj-proxy";
+import {
+  assertIsStrictHexString,
+  hasProperty,
+  isPlainObject
+} from "@metamask/utils";
+import { strict as assert } from "assert";
+import { v4 as random } from "uuid";
+var log = createModuleLogger(projectLogger, "NetworkController");
+function knownKeysOf(object) {
+  return Object.keys(object);
+}
+function assertOfType(value, validate, message) {
+  assert.ok(validate(value), message);
+}
+function pick(object, keys) {
+  const pickedObject = keys.reduce(
+    (finalObject, key) => {
+      return { ...finalObject, [key]: object[key] };
+    },
+    {}
+  );
+  assertOfType(
+    pickedObject,
+    () => keys.every((key) => key in pickedObject),
+    "The reduce did not produce an object with all of the desired keys."
+  );
+  return pickedObject;
+}
+function isErrorWithCode(error) {
+  return typeof error === "object" && error !== null && "code" in error;
+}
+function buildInfuraNetworkClientId(infuraNetworkOrProviderConfig) {
+  if (typeof infuraNetworkOrProviderConfig === "string") {
+    return infuraNetworkOrProviderConfig;
+  }
+  return infuraNetworkOrProviderConfig.type;
+}
+function buildCustomNetworkClientId(...args) {
+  if (args.length === 1) {
+    return args[0];
+  }
+  const [{ id, rpcUrl }, networkConfigurations] = args;
+  if (id === void 0) {
+    const matchingNetworkConfiguration = Object.values(
+      networkConfigurations
+    ).find((networkConfiguration) => {
+      return networkConfiguration.rpcUrl === rpcUrl.toLowerCase();
+    });
+    if (matchingNetworkConfiguration) {
+      return matchingNetworkConfiguration.id;
+    }
+    return rpcUrl.toLowerCase();
+  }
+  return id;
+}
+function isInfuraProviderConfig(providerConfig) {
+  return isInfuraNetworkType(providerConfig.type);
+}
+function isCustomProviderConfig(providerConfig) {
+  return providerConfig.type === NetworkType.rpc;
+}
+function validateCustomProviderConfig(providerConfig) {
+  if (providerConfig.chainId === void 0) {
+    throw new Error("chainId must be provided for custom RPC endpoints");
+  }
+  if (providerConfig.rpcUrl === void 0) {
+    throw new Error("rpcUrl must be provided for custom RPC endpoints");
+  }
+}
+var name = "NetworkController";
+var defaultState = {
+  selectedNetworkClientId: NetworkType.mainnet,
+  providerConfig: {
+    type: NetworkType.mainnet,
+    chainId: ChainId.mainnet,
+    ticker: NetworksTicker.mainnet
+  },
+  networksMetadata: {},
+  networkConfigurations: {}
+};
+var _ethQuery, _infuraProjectId, _trackMetaMetricsEvent, _previousProviderConfig, _providerProxy, _blockTrackerProxy, _autoManagedNetworkClientRegistry, _refreshNetwork, refreshNetwork_fn, _getLatestBlock, getLatestBlock_fn, _determineEIP1559Compatibility, determineEIP1559Compatibility_fn, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn, _createAutoManagedNetworkClientRegistry, createAutoManagedNetworkClientRegistry_fn, _buildIdentifiedInfuraNetworkClientConfigurations, buildIdentifiedInfuraNetworkClientConfigurations_fn, _buildIdentifiedCustomNetworkClientConfigurations, buildIdentifiedCustomNetworkClientConfigurations_fn, _buildIdentifiedNetworkClientConfigurationsFromProviderConfig, buildIdentifiedNetworkClientConfigurationsFromProviderConfig_fn, _applyNetworkSelection, applyNetworkSelection_fn;
+var NetworkController = class extends BaseController {
+  constructor({
+    messenger,
+    state,
+    infuraProjectId,
+    trackMetaMetricsEvent
+  }) {
+    super({
+      name,
+      metadata: {
+        selectedNetworkClientId: {
+          persist: true,
+          anonymous: false
+        },
+        networksMetadata: {
+          persist: true,
+          anonymous: false
+        },
+        providerConfig: {
+          persist: true,
+          anonymous: false
+        },
+        networkConfigurations: {
+          persist: true,
+          anonymous: false
+        }
+      },
+      messenger,
+      state: { ...defaultState, ...state }
+    });
+    /**
+     * Executes a series of steps to apply the changes to the provider config:
+     *
+     * 1. Notifies subscribers that the network is about to change.
+     * 2. Looks up a known and preinitialized network client matching the provider
+     * config and re-points the provider and block tracker proxy to it.
+     * 3. Notifies subscribers that the network has changed.
+     */
+    __privateAdd(this, _refreshNetwork);
+    /**
+     * Fetches the latest block for the network.
+     *
+     * @param networkClientId - The networkClientId to fetch the correct provider against which to check the latest block. Defaults to the selectedNetworkClientId.
+     * @returns A promise that either resolves to the block header or null if
+     * there is no latest block, or rejects with an error.
+     */
+    __privateAdd(this, _getLatestBlock);
+    /**
+     * Retrieves and checks the latest block from the currently selected
+     * network; if the block has a `baseFeePerGas` property, then we know
+     * that the network supports EIP-1559; otherwise it doesn't.
+     *
+     * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility
+     * @returns A promise that resolves to `true` if the network supports EIP-1559,
+     * `false` otherwise, or `undefined` if unable to retrieve the last block.
+     */
+    __privateAdd(this, _determineEIP1559Compatibility);
+    /**
+     * Before accessing or switching the network, the registry of network clients
+     * needs to be populated. Otherwise, `#applyNetworkSelection` and
+     * `getNetworkClientRegistry` will throw an error. This method checks to see if the
+     * population step has happened yet, and if not, makes it happen.
+     *
+     * @returns The populated network client registry.
+     */
+    __privateAdd(this, _ensureAutoManagedNetworkClientRegistryPopulated);
+    /**
+     * Constructs the registry of network clients based on the set of built-in
+     * networks as well as the custom networks in state.
+     *
+     * @returns The network clients keyed by ID.
+     */
+    __privateAdd(this, _createAutoManagedNetworkClientRegistry);
+    /**
+     * Constructs the list of network clients for built-in networks (that is,
+     * the subset of the networks we know Infura supports that consumers do not
+     * need to explicitly add).
+     *
+     * @returns The network clients.
+     */
+    __privateAdd(this, _buildIdentifiedInfuraNetworkClientConfigurations);
+    /**
+     * Constructs the list of network clients for custom networks (that is, those
+     * which consumers have added via `networkConfigurations`).
+     *
+     * @returns The network clients.
+     */
+    __privateAdd(this, _buildIdentifiedCustomNetworkClientConfigurations);
+    /**
+     * Converts the provider config object in state to a network client
+     * configuration object.
+     *
+     * @returns The network client config.
+     * @throws If the provider config is of type "rpc" and lacks either a
+     * `chainId` or an `rpcUrl`.
+     */
+    __privateAdd(this, _buildIdentifiedNetworkClientConfigurationsFromProviderConfig);
+    /**
+     * Uses the information in the provider config object to look up a known and
+     * preinitialized network client. Once a network client is found, updates the
+     * provider and block tracker proxy to point to those from the network client,
+     * then finally creates an EthQuery that points to the provider proxy.
+     *
+     * @throws If no network client could be found matching the current provider
+     * config.
+     */
+    __privateAdd(this, _applyNetworkSelection);
+    __privateAdd(this, _ethQuery, void 0);
+    __privateAdd(this, _infuraProjectId, void 0);
+    __privateAdd(this, _trackMetaMetricsEvent, void 0);
+    __privateAdd(this, _previousProviderConfig, void 0);
+    __privateAdd(this, _providerProxy, void 0);
+    __privateAdd(this, _blockTrackerProxy, void 0);
+    __privateAdd(this, _autoManagedNetworkClientRegistry, void 0);
+    if (!infuraProjectId || typeof infuraProjectId !== "string") {
+      throw new Error("Invalid Infura project ID");
+    }
+    __privateSet(this, _infuraProjectId, infuraProjectId);
+    __privateSet(this, _trackMetaMetricsEvent, trackMetaMetricsEvent);
+    this.messagingSystem.registerActionHandler(
+      `${this.name}:getProviderConfig`,
+      () => {
+        return this.state.providerConfig;
+      }
+    );
+    this.messagingSystem.registerActionHandler(
+      `${this.name}:getEthQuery`,
+      () => {
+        return __privateGet(this, _ethQuery);
+      }
+    );
+    this.messagingSystem.registerActionHandler(
+      `${this.name}:getNetworkClientById`,
+      this.getNetworkClientById.bind(this)
+    );
+    this.messagingSystem.registerActionHandler(
+      `${this.name}:getEIP1559Compatibility`,
+      this.getEIP1559Compatibility.bind(this)
+    );
+    this.messagingSystem.registerActionHandler(
+      `${this.name}:setActiveNetwork`,
+      this.setActiveNetwork.bind(this)
+    );
+    this.messagingSystem.registerActionHandler(
+      `${this.name}:setProviderType`,
+      this.setProviderType.bind(this)
+    );
+    this.messagingSystem.registerActionHandler(
+      `${this.name}:findNetworkClientIdByChainId`,
+      this.findNetworkClientIdByChainId.bind(this)
+    );
+    this.messagingSystem.registerActionHandler(
+      `${this.name}:getNetworkConfigurationByNetworkClientId`,
+      this.getNetworkConfigurationByNetworkClientId.bind(this)
+    );
+    this.messagingSystem.registerActionHandler(
+      `${this.name}:getSelectedNetworkClient`,
+      this.getSelectedNetworkClient.bind(this)
+    );
+    __privateSet(this, _previousProviderConfig, this.state.providerConfig);
+  }
+  /**
+   * Accesses the provider and block tracker for the currently selected network.
+   * @returns The proxy and block tracker proxies.
+   * @deprecated This method has been replaced by `getSelectedNetworkClient` (which has a more easily used return type) and will be removed in a future release.
+   */
+  getProviderAndBlockTracker() {
+    return {
+      provider: __privateGet(this, _providerProxy),
+      blockTracker: __privateGet(this, _blockTrackerProxy)
+    };
+  }
+  /**
+   * Accesses the provider and block tracker for the currently selected network.
+   *
+   * @returns an object with the provider and block tracker proxies for the currently selected network.
+   */
+  getSelectedNetworkClient() {
+    if (__privateGet(this, _providerProxy) && __privateGet(this, _blockTrackerProxy)) {
+      return {
+        provider: __privateGet(this, _providerProxy),
+        blockTracker: __privateGet(this, _blockTrackerProxy)
+      };
+    }
+    return void 0;
+  }
+  /**
+   * Returns all of the network clients that have been created so far, keyed by
+   * their identifier in the network client registry. This collection represents
+   * not only built-in networks but also any custom networks that consumers have
+   * added.
+   *
+   * @returns The list of known network clients.
+   */
+  getNetworkClientRegistry() {
+    const autoManagedNetworkClientRegistry = __privateMethod(this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
+    return Object.assign(
+      {},
+      autoManagedNetworkClientRegistry["infura" /* Infura */],
+      autoManagedNetworkClientRegistry["custom" /* Custom */]
+    );
+  }
+  getNetworkClientById(networkClientId) {
+    if (!networkClientId) {
+      throw new Error("No network client ID was provided.");
+    }
+    const autoManagedNetworkClientRegistry = __privateMethod(this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
+    if (isInfuraNetworkType(networkClientId)) {
+      const infuraNetworkClient = autoManagedNetworkClientRegistry["infura" /* Infura */][networkClientId];
+      if (!infuraNetworkClient) {
+        throw new Error(
+          `No Infura network client was found with the ID "${networkClientId}".`
+        );
+      }
+      return infuraNetworkClient;
+    }
+    const customNetworkClient = autoManagedNetworkClientRegistry["custom" /* Custom */][networkClientId];
+    if (!customNetworkClient) {
+      throw new Error(
+        `No custom network client was found with the ID "${networkClientId}".`
+      );
+    }
+    return customNetworkClient;
+  }
+  /**
+   * Populates the network clients and establishes the initial network based on
+   * the provider configuration in state.
+   */
+  async initializeProvider() {
+    __privateMethod(this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
+    __privateMethod(this, _applyNetworkSelection, applyNetworkSelection_fn).call(this);
+  }
+  /**
+   * Refreshes the network meta with EIP-1559 support and the network status
+   * based on the given network client ID.
+   *
+   * @param networkClientId - The ID of the network client to update.
+   */
+  async lookupNetworkByClientId(networkClientId) {
+    const isInfura = isInfuraNetworkType(networkClientId);
+    let updatedNetworkStatus;
+    let updatedIsEIP1559Compatible;
+    try {
+      updatedIsEIP1559Compatible = await __privateMethod(this, _determineEIP1559Compatibility, determineEIP1559Compatibility_fn).call(this, networkClientId);
+      updatedNetworkStatus = "available" /* Available */;
+    } catch (error) {
+      if (isErrorWithCode(error)) {
+        let responseBody;
+        if (isInfura && hasProperty(error, "message") && typeof error.message === "string") {
+          try {
+            responseBody = JSON.parse(error.message);
+          } catch {
+          }
+        }
+        if (isPlainObject(responseBody) && responseBody.error === INFURA_BLOCKED_KEY) {
+          updatedNetworkStatus = "blocked" /* Blocked */;
+        } else if (error.code === errorCodes.rpc.internal) {
+          updatedNetworkStatus = "unknown" /* Unknown */;
+        } else {
+          updatedNetworkStatus = "unavailable" /* Unavailable */;
+        }
+      } else if (typeof Error !== "undefined" && hasProperty(error, "message") && typeof error.message === "string" && error.message.includes(
+        "No custom network client was found with the ID"
+      )) {
+        throw error;
+      } else {
+        log("NetworkController - could not determine network status", error);
+        updatedNetworkStatus = "unknown" /* Unknown */;
+      }
+    }
+    this.update((state) => {
+      if (state.networksMetadata[networkClientId] === void 0) {
+        state.networksMetadata[networkClientId] = {
+          status: "unknown" /* Unknown */,
+          EIPS: {}
+        };
+      }
+      const meta = state.networksMetadata[networkClientId];
+      meta.status = updatedNetworkStatus;
+      if (updatedIsEIP1559Compatible === void 0) {
+        delete meta.EIPS[1559];
+      } else {
+        meta.EIPS[1559] = updatedIsEIP1559Compatible;
+      }
+    });
+  }
+  /**
+   * Performs side effects after switching to a network. If the network is
+   * available, updates the network state with the network ID of the network and
+   * stores whether the network supports EIP-1559; otherwise clears said
+   * information about the network that may have been previously stored.
+   *
+   * @param networkClientId - (Optional) The ID of the network client to update.
+   * If no ID is provided, uses the currently selected network.
+   * @fires infuraIsBlocked if the network is Infura-supported and is blocking
+   * requests.
+   * @fires infuraIsUnblocked if the network is Infura-supported and is not
+   * blocking requests, or if the network is not Infura-supported.
+   */
+  async lookupNetwork(networkClientId) {
+    if (networkClientId) {
+      await this.lookupNetworkByClientId(networkClientId);
+      return;
+    }
+    if (!__privateGet(this, _ethQuery)) {
+      return;
+    }
+    const isInfura = isInfuraProviderConfig(this.state.providerConfig);
+    let networkChanged = false;
+    const listener = () => {
+      networkChanged = true;
+      this.messagingSystem.unsubscribe(
+        "NetworkController:networkDidChange",
+        listener
+      );
+    };
+    this.messagingSystem.subscribe(
+      "NetworkController:networkDidChange",
+      listener
+    );
+    let updatedNetworkStatus;
+    let updatedIsEIP1559Compatible;
+    try {
+      const isEIP1559Compatible = await __privateMethod(this, _determineEIP1559Compatibility, determineEIP1559Compatibility_fn).call(this, this.state.selectedNetworkClientId);
+      updatedNetworkStatus = "available" /* Available */;
+      updatedIsEIP1559Compatible = isEIP1559Compatible;
+    } catch (error) {
+      if (isErrorWithCode(error)) {
+        let responseBody;
+        if (isInfura && hasProperty(error, "message") && typeof error.message === "string") {
+          try {
+            responseBody = JSON.parse(error.message);
+          } catch {
+          }
+        }
+        if (isPlainObject(responseBody) && responseBody.error === INFURA_BLOCKED_KEY) {
+          updatedNetworkStatus = "blocked" /* Blocked */;
+        } else if (error.code === errorCodes.rpc.internal) {
+          updatedNetworkStatus = "unknown" /* Unknown */;
+        } else {
+          updatedNetworkStatus = "unavailable" /* Unavailable */;
+        }
+      } else {
+        log("NetworkController - could not determine network status", error);
+        updatedNetworkStatus = "unknown" /* Unknown */;
+      }
+    }
+    if (networkChanged) {
+      return;
+    }
+    this.messagingSystem.unsubscribe(
+      "NetworkController:networkDidChange",
+      listener
+    );
+    this.update((state) => {
+      const meta = state.networksMetadata[state.selectedNetworkClientId];
+      meta.status = updatedNetworkStatus;
+      if (updatedIsEIP1559Compatible === void 0) {
+        delete meta.EIPS[1559];
+      } else {
+        meta.EIPS[1559] = updatedIsEIP1559Compatible;
+      }
+    });
+    if (isInfura) {
+      if (updatedNetworkStatus === "available" /* Available */) {
+        this.messagingSystem.publish("NetworkController:infuraIsUnblocked");
+      } else if (updatedNetworkStatus === "blocked" /* Blocked */) {
+        this.messagingSystem.publish("NetworkController:infuraIsBlocked");
+      }
+    } else {
+      this.messagingSystem.publish("NetworkController:infuraIsUnblocked");
+    }
+  }
+  /**
+   * Convenience method to update provider network type settings.
+   *
+   * @param type - Human readable network name.
+   * @deprecated This has been replaced by `setActiveNetwork`, and will be
+   * removed in a future release
+   */
+  async setProviderType(type) {
+    assert.notStrictEqual(
+      type,
+      NetworkType.rpc,
+      `NetworkController - cannot call "setProviderType" with type "${NetworkType.rpc}". Use "setActiveNetwork"`
+    );
+    assert.ok(
+      isInfuraNetworkType(type),
+      `Unknown Infura provider type "${type}".`
+    );
+    await this.setActiveNetwork(type);
+  }
+  /**
+   * Convenience method to update provider RPC settings.
+   *
+   * @param networkConfigurationIdOrType - The unique id for the network configuration to set as the active provider,
+   * or the type of a built-in network.
+   */
+  async setActiveNetwork(networkConfigurationIdOrType) {
+    __privateSet(this, _previousProviderConfig, this.state.providerConfig);
+    let targetNetwork;
+    if (isInfuraNetworkType(networkConfigurationIdOrType)) {
+      const ticker = NetworksTicker[networkConfigurationIdOrType];
+      targetNetwork = {
+        chainId: ChainId[networkConfigurationIdOrType],
+        id: void 0,
+        rpcPrefs: BUILT_IN_NETWORKS[networkConfigurationIdOrType].rpcPrefs,
+        rpcUrl: void 0,
+        nickname: void 0,
+        ticker,
+        type: networkConfigurationIdOrType
+      };
+    } else {
+      if (!Object.keys(this.state.networkConfigurations).includes(
+        networkConfigurationIdOrType
+      )) {
+        throw new Error(
+          `networkConfigurationId ${networkConfigurationIdOrType} does not match a configured networkConfiguration or built-in network type`
+        );
+      }
+      targetNetwork = {
+        ...this.state.networkConfigurations[networkConfigurationIdOrType],
+        type: NetworkType.rpc
+      };
+    }
+    __privateMethod(this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
+    this.update((state) => {
+      state.providerConfig = targetNetwork;
+    });
+    await __privateMethod(this, _refreshNetwork, refreshNetwork_fn).call(this);
+  }
+  /**
+   * Determines whether the network supports EIP-1559 by checking whether the
+   * latest block has a `baseFeePerGas` property, then updates state
+   * appropriately.
+   *
+   * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility.
+   * @returns A promise that resolves to true if the network supports EIP-1559
+   * , false otherwise, or `undefined` if unable to determine the compatibility.
+   */
+  async getEIP1559Compatibility(networkClientId) {
+    if (networkClientId) {
+      return this.get1559CompatibilityWithNetworkClientId(networkClientId);
+    }
+    if (!__privateGet(this, _ethQuery)) {
+      return false;
+    }
+    const { EIPS } = this.state.networksMetadata[this.state.selectedNetworkClientId];
+    if (EIPS[1559] !== void 0) {
+      return EIPS[1559];
+    }
+    const isEIP1559Compatible = await __privateMethod(this, _determineEIP1559Compatibility, determineEIP1559Compatibility_fn).call(this, this.state.selectedNetworkClientId);
+    this.update((state) => {
+      if (isEIP1559Compatible !== void 0) {
+        state.networksMetadata[state.selectedNetworkClientId].EIPS[1559] = isEIP1559Compatible;
+      }
+    });
+    return isEIP1559Compatible;
+  }
+  async get1559CompatibilityWithNetworkClientId(networkClientId) {
+    let metadata = this.state.networksMetadata[networkClientId];
+    if (metadata === void 0) {
+      await this.lookupNetwork(networkClientId);
+      metadata = this.state.networksMetadata[networkClientId];
+    }
+    const { EIPS } = metadata;
+    return EIPS[1559];
+  }
+  /**
+   * Re-initializes the provider and block tracker for the current network.
+   */
+  async resetConnection() {
+    __privateMethod(this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
+    await __privateMethod(this, _refreshNetwork, refreshNetwork_fn).call(this);
+  }
+  /**
+   * Returns a configuration object for the network identified by the given
+   * network client ID. If given an Infura network type, constructs one based on
+   * what we know about the network; otherwise attempts locates a network
+   * configuration in state that corresponds to the network client ID.
+   *
+   * @param networkClientId - The network client ID.
+   * @returns The configuration for the referenced network if one exists, or
+   * undefined otherwise.
+   */
+  getNetworkConfigurationByNetworkClientId(networkClientId) {
+    if (isInfuraNetworkType(networkClientId)) {
+      const rpcUrl = `https://${networkClientId}.infura.io/v3/${__privateGet(this, _infuraProjectId)}`;
+      return {
+        rpcUrl,
+        ...BUILT_IN_NETWORKS[networkClientId]
+      };
+    }
+    return this.state.networkConfigurations[networkClientId];
+  }
+  /**
+   * Adds a new custom network or updates the information for an existing
+   * network.
+   *
+   * This may involve updating the `networkConfigurations` property in
+   * state as well and/or adding a new network client to the network client
+   * registry. The `rpcUrl` and `chainId` of the given object are used to
+   * determine which action to take:
+   *
+   * - If the `rpcUrl` corresponds to an existing network configuration
+   * (case-insensitively), then it is overwritten with the object. Furthermore,
+   * if the `chainId` is different from the existing network configuration, then
+   * the existing network client is replaced with a new one.
+   * - If the `rpcUrl` does not correspond to an existing network configuration
+   * (case-insensitively), then the object is used to add a new network
+   * configuration along with a new network client.
+   *
+   * @param networkConfiguration - The network configuration to add or update.
+   * @param options - Additional configuration options.
+   * @param options.referrer - Used to create a metrics event; the site from which the call originated, or 'metamask' for internal calls.
+   * @param options.source - Used to create a metrics event; where the event originated (i.e. from a dapp or from the network form).
+   * @param options.setActive - If true, switches to the network upon adding or updating it (default: false).
+   * @returns The ID for the added or updated network configuration.
+   */
+  async upsertNetworkConfiguration(networkConfiguration, {
+    referrer,
+    source,
+    setActive = false
+  }) {
+    const sanitizedNetworkConfiguration = pick(networkConfiguration, [
+      "rpcUrl",
+      "chainId",
+      "ticker",
+      "nickname",
+      "rpcPrefs",
+      "id"
+    ]);
+    const { rpcUrl, chainId, ticker, id } = sanitizedNetworkConfiguration;
+    assertIsStrictHexString(chainId);
+    if (!isSafeChainId(chainId)) {
+      throw new Error(
+        `Invalid chain ID "${chainId}": numerical value greater than max safe value.`
+      );
+    }
+    if (!rpcUrl) {
+      throw new Error(
+        "An rpcUrl is required to add or update network configuration"
+      );
+    }
+    if (!referrer || !source) {
+      throw new Error(
+        "referrer and source are required arguments for adding or updating a network configuration"
+      );
+    }
+    try {
+      new URL(rpcUrl);
+    } catch (e) {
+      if (e.message.includes("Invalid URL")) {
+        throw new Error("rpcUrl must be a valid URL");
+      }
+    }
+    if (!ticker) {
+      throw new Error(
+        "A ticker is required to add or update networkConfiguration"
+      );
+    }
+    const autoManagedNetworkClientRegistry = __privateMethod(this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
+    const existingNetworkConfigurationWithId = Object.values(
+      this.state.networkConfigurations
+    ).find((networkConfig) => networkConfig.id === id);
+    if (id && !existingNetworkConfigurationWithId) {
+      throw new Error("No network configuration matches the provided id");
+    }
+    const existingNetworkConfigurationWithRpcUrl = Object.values(
+      this.state.networkConfigurations
+    ).find(
+      (networkConfig) => networkConfig.rpcUrl.toLowerCase() === rpcUrl.toLowerCase()
+    );
+    if (id && existingNetworkConfigurationWithRpcUrl && existingNetworkConfigurationWithRpcUrl.id !== id) {
+      throw new Error(
+        "A different network configuration already exists with the provided rpcUrl"
+      );
+    }
+    const existingNetworkConfiguration = existingNetworkConfigurationWithId ?? existingNetworkConfigurationWithRpcUrl;
+    const upsertedNetworkConfigurationId = existingNetworkConfiguration ? existingNetworkConfiguration.id : random();
+    const networkClientId = buildCustomNetworkClientId(
+      upsertedNetworkConfigurationId
+    );
+    const customNetworkClientRegistry = autoManagedNetworkClientRegistry["custom" /* Custom */];
+    const existingAutoManagedNetworkClient = customNetworkClientRegistry[networkClientId];
+    const shouldDestroyExistingNetworkClient = existingAutoManagedNetworkClient && existingAutoManagedNetworkClient.configuration.chainId !== chainId;
+    if (shouldDestroyExistingNetworkClient) {
+      existingAutoManagedNetworkClient.destroy();
+    }
+    if (!existingAutoManagedNetworkClient || shouldDestroyExistingNetworkClient) {
+      customNetworkClientRegistry[networkClientId] = createAutoManagedNetworkClient({
+        type: "custom" /* Custom */,
+        chainId,
+        rpcUrl,
+        ticker
+      });
+    }
+    this.update((state) => {
+      state.networkConfigurations[upsertedNetworkConfigurationId] = {
+        // Core PR: https://github.com/MetaMask/core/pull/4614
+        // Core Patch Branch: jl/network-controller@19.0.0-patch
+        ...sanitizedNetworkConfiguration,
+        id: upsertedNetworkConfigurationId
+      };
+    });
+    if (!existingNetworkConfiguration) {
+      __privateGet(this, _trackMetaMetricsEvent).call(this, {
+        event: "Custom Network Added",
+        category: "Network",
+        referrer: {
+          url: referrer
+        },
+        properties: {
+          chain_id: chainId,
+          symbol: ticker,
+          source
+        }
+      });
+    }
+    if (setActive) {
+      await this.setActiveNetwork(upsertedNetworkConfigurationId);
+    }
+    return upsertedNetworkConfigurationId;
+  }
+  /**
+   * Removes a custom network from state.
+   *
+   * This involves updating the `networkConfigurations` property in state as
+   * well and removing the network client that corresponds to the network from
+   * the client registry.
+   *
+   * @param networkConfigurationId - The ID of an existing network
+   * configuration.
+   */
+  removeNetworkConfiguration(networkConfigurationId) {
+    if (!this.state.networkConfigurations[networkConfigurationId]) {
+      throw new Error(
+        `networkConfigurationId ${networkConfigurationId} does not match a configured networkConfiguration`
+      );
+    }
+    const autoManagedNetworkClientRegistry = __privateMethod(this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
+    const networkClientId = buildCustomNetworkClientId(networkConfigurationId);
+    this.update((state) => {
+      delete state.networkConfigurations[networkConfigurationId];
+    });
+    const customNetworkClientRegistry = autoManagedNetworkClientRegistry["custom" /* Custom */];
+    const existingAutoManagedNetworkClient = customNetworkClientRegistry[networkClientId];
+    existingAutoManagedNetworkClient.destroy();
+    delete customNetworkClientRegistry[networkClientId];
+  }
+  /**
+   * Switches to the previously selected network, assuming that there is one
+   * (if not and `initializeProvider` has not been previously called, then this
+   * method is equivalent to calling `resetConnection`).
+   */
+  async rollbackToPreviousProvider() {
+    __privateMethod(this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
+    this.update((state) => {
+      state.providerConfig = __privateGet(this, _previousProviderConfig);
+    });
+    await __privateMethod(this, _refreshNetwork, refreshNetwork_fn).call(this);
+  }
+  /**
+   * Deactivates the controller, stopping any ongoing polling.
+   *
+   * In-progress requests will not be aborted.
+   */
+  async destroy() {
+    await __privateGet(this, _blockTrackerProxy)?.destroy();
+  }
+  /**
+   * Updates the controller using the given backup data.
+   *
+   * @param backup - The data that has been backed up.
+   * @param backup.networkConfigurations - Network configurations in the backup.
+   */
+  loadBackup({
+    networkConfigurations
+  }) {
+    this.update((state) => {
+      state.networkConfigurations = {
+        ...state.networkConfigurations,
+        ...networkConfigurations
+      };
+    });
+  }
+  /**
+   * Searches for a network configuration ID with the given ChainID and returns it.
+   *
+   * @param chainId - ChainId to search for
+   * @returns networkClientId of the network configuration with the given chainId
+   */
+  findNetworkClientIdByChainId(chainId) {
+    const networkClients = this.getNetworkClientRegistry();
+    const networkClientEntry = Object.entries(networkClients).find(
+      ([_, networkClient]) => networkClient.configuration.chainId === chainId
+    );
+    if (networkClientEntry === void 0) {
+      throw new Error("Couldn't find networkClientId for chainId");
+    }
+    return networkClientEntry[0];
+  }
+};
+_ethQuery = new WeakMap();
+_infuraProjectId = new WeakMap();
+_trackMetaMetricsEvent = new WeakMap();
+_previousProviderConfig = new WeakMap();
+_providerProxy = new WeakMap();
+_blockTrackerProxy = new WeakMap();
+_autoManagedNetworkClientRegistry = new WeakMap();
+_refreshNetwork = new WeakSet();
+refreshNetwork_fn = async function() {
+  this.messagingSystem.publish(
+    "NetworkController:networkWillChange",
+    this.state
+  );
+  __privateMethod(this, _applyNetworkSelection, applyNetworkSelection_fn).call(this);
+  this.messagingSystem.publish(
+    "NetworkController:networkDidChange",
+    this.state
+  );
+  await this.lookupNetwork();
+};
+_getLatestBlock = new WeakSet();
+getLatestBlock_fn = function(networkClientId) {
+  if (networkClientId === void 0) {
+    networkClientId = this.state.selectedNetworkClientId;
+  }
+  const networkClient = this.getNetworkClientById(networkClientId);
+  const ethQuery = new EthQuery(networkClient.provider);
+  return new Promise((resolve, reject) => {
+    ethQuery.sendAsync(
+      { method: "eth_getBlockByNumber", params: ["latest", false] },
+      (error, block) => {
+        if (error) {
+          reject(error);
+        } else {
+          resolve(block);
+        }
+      }
+    );
+  });
+};
+_determineEIP1559Compatibility = new WeakSet();
+determineEIP1559Compatibility_fn = async function(networkClientId) {
+  const latestBlock = await __privateMethod(this, _getLatestBlock, getLatestBlock_fn).call(this, networkClientId);
+  if (!latestBlock) {
+    return void 0;
+  }
+  return latestBlock.baseFeePerGas !== void 0;
+};
+_ensureAutoManagedNetworkClientRegistryPopulated = new WeakSet();
+ensureAutoManagedNetworkClientRegistryPopulated_fn = function() {
+  const autoManagedNetworkClientRegistry = __privateGet(this, _autoManagedNetworkClientRegistry) ?? __privateMethod(this, _createAutoManagedNetworkClientRegistry, createAutoManagedNetworkClientRegistry_fn).call(this);
+  __privateSet(this, _autoManagedNetworkClientRegistry, autoManagedNetworkClientRegistry);
+  return autoManagedNetworkClientRegistry;
+};
+_createAutoManagedNetworkClientRegistry = new WeakSet();
+createAutoManagedNetworkClientRegistry_fn = function() {
+  return [
+    ...__privateMethod(this, _buildIdentifiedInfuraNetworkClientConfigurations, buildIdentifiedInfuraNetworkClientConfigurations_fn).call(this),
+    ...__privateMethod(this, _buildIdentifiedCustomNetworkClientConfigurations, buildIdentifiedCustomNetworkClientConfigurations_fn).call(this),
+    ...__privateMethod(this, _buildIdentifiedNetworkClientConfigurationsFromProviderConfig, buildIdentifiedNetworkClientConfigurationsFromProviderConfig_fn).call(this)
+  ].reduce(
+    (registry, [networkClientType, networkClientId, networkClientConfiguration]) => {
+      const autoManagedNetworkClient = createAutoManagedNetworkClient(
+        networkClientConfiguration
+      );
+      if (networkClientId in registry[networkClientType]) {
+        return registry;
+      }
+      return {
+        ...registry,
+        [networkClientType]: {
+          ...registry[networkClientType],
+          [networkClientId]: autoManagedNetworkClient
+        }
+      };
+    },
+    {
+      ["infura" /* Infura */]: {},
+      ["custom" /* Custom */]: {}
+    }
+  );
+};
+_buildIdentifiedInfuraNetworkClientConfigurations = new WeakSet();
+buildIdentifiedInfuraNetworkClientConfigurations_fn = function() {
+  return knownKeysOf(InfuraNetworkType).map((network) => {
+    const networkClientId = buildInfuraNetworkClientId(network);
+    const networkClientConfiguration = {
+      type: "infura" /* Infura */,
+      network,
+      infuraProjectId: __privateGet(this, _infuraProjectId),
+      chainId: BUILT_IN_NETWORKS[network].chainId,
+      ticker: BUILT_IN_NETWORKS[network].ticker
+    };
+    return [
+      "infura" /* Infura */,
+      networkClientId,
+      networkClientConfiguration
+    ];
+  });
+};
+_buildIdentifiedCustomNetworkClientConfigurations = new WeakSet();
+buildIdentifiedCustomNetworkClientConfigurations_fn = function() {
+  return Object.entries(this.state.networkConfigurations).map(
+    ([networkConfigurationId, networkConfiguration]) => {
+      if (networkConfiguration.chainId === void 0) {
+        throw new Error("chainId must be provided for custom RPC endpoints");
+      }
+      if (networkConfiguration.rpcUrl === void 0) {
+        throw new Error("rpcUrl must be provided for custom RPC endpoints");
+      }
+      const networkClientId = buildCustomNetworkClientId(
+        networkConfigurationId
+      );
+      const networkClientConfiguration = {
+        type: "custom" /* Custom */,
+        chainId: networkConfiguration.chainId,
+        rpcUrl: networkConfiguration.rpcUrl,
+        ticker: networkConfiguration.ticker
+      };
+      return [
+        "custom" /* Custom */,
+        networkClientId,
+        networkClientConfiguration
+      ];
+    }
+  );
+};
+_buildIdentifiedNetworkClientConfigurationsFromProviderConfig = new WeakSet();
+buildIdentifiedNetworkClientConfigurationsFromProviderConfig_fn = function() {
+  const { providerConfig } = this.state;
+  if (isCustomProviderConfig(providerConfig)) {
+    validateCustomProviderConfig(providerConfig);
+    const networkClientId = buildCustomNetworkClientId(
+      providerConfig,
+      this.state.networkConfigurations
+    );
+    const networkClientConfiguration = {
+      chainId: providerConfig.chainId,
+      rpcUrl: providerConfig.rpcUrl,
+      type: "custom" /* Custom */,
+      ticker: providerConfig.ticker
+    };
+    return [
+      ["custom" /* Custom */, networkClientId, networkClientConfiguration]
+    ];
+  }
+  if (isInfuraProviderConfig(providerConfig)) {
+    return [];
+  }
+  throw new Error(`Unrecognized network type: '${providerConfig.type}'`);
+};
+_applyNetworkSelection = new WeakSet();
+applyNetworkSelection_fn = function() {
+  if (!__privateGet(this, _autoManagedNetworkClientRegistry)) {
+    throw new Error(
+      "initializeProvider must be called first in order to switch the network"
+    );
+  }
+  const { providerConfig } = this.state;
+  let autoManagedNetworkClient;
+  let networkClientId;
+  if (isInfuraProviderConfig(providerConfig)) {
+    const networkClientType = "infura" /* Infura */;
+    networkClientId = buildInfuraNetworkClientId(providerConfig);
+    const builtInNetworkClientRegistry = __privateGet(this, _autoManagedNetworkClientRegistry)[networkClientType];
+    autoManagedNetworkClient = builtInNetworkClientRegistry[networkClientId];
+    if (!autoManagedNetworkClient) {
+      throw new Error(
+        `Could not find custom network matching ${networkClientId}`
+      );
+    }
+  } else if (isCustomProviderConfig(providerConfig)) {
+    validateCustomProviderConfig(providerConfig);
+    const networkClientType = "custom" /* Custom */;
+    networkClientId = buildCustomNetworkClientId(
+      providerConfig,
+      this.state.networkConfigurations
+    );
+    const customNetworkClientRegistry = __privateGet(this, _autoManagedNetworkClientRegistry)[networkClientType];
+    autoManagedNetworkClient = customNetworkClientRegistry[networkClientId];
+    if (!autoManagedNetworkClient) {
+      throw new Error(
+        `Could not find built-in network matching ${networkClientId}`
+      );
+    }
+  } else {
+    throw new Error("Could not determine type of provider config");
+  }
+  this.update((state) => {
+    state.selectedNetworkClientId = networkClientId;
+    if (state.networksMetadata[networkClientId] === void 0) {
+      state.networksMetadata[networkClientId] = {
+        status: "unknown" /* Unknown */,
+        EIPS: {}
+      };
+    }
+  });
+  const { provider, blockTracker } = autoManagedNetworkClient;
+  if (__privateGet(this, _providerProxy)) {
+    __privateGet(this, _providerProxy).setTarget(provider);
+  } else {
+    __privateSet(this, _providerProxy, createEventEmitterProxy(provider));
+  }
+  if (__privateGet(this, _blockTrackerProxy)) {
+    __privateGet(this, _blockTrackerProxy).setTarget(blockTracker);
+  } else {
+    __privateSet(this, _blockTrackerProxy, createEventEmitterProxy(blockTracker, {
+      eventFilter: "skipInternal"
+    }));
+  }
+  __privateSet(this, _ethQuery, new EthQuery(__privateGet(this, _providerProxy)));
+};
+
+export {
+  knownKeysOf,
+  defaultState,
+  NetworkController
+};
+//# sourceMappingURL=chunk-6EXWS63D.mjs.map
\ No newline at end of file
diff --git a/dist/chunk-6EXWS63D.mjs.map b/dist/chunk-6EXWS63D.mjs.map
new file mode 100644
index 0000000000000000000000000000000000000000..7178fd66d1bb10ad64677f02609c91bd632e2bae
--- /dev/null
+++ b/dist/chunk-6EXWS63D.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/NetworkController.ts"],"sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport {\n  BUILT_IN_NETWORKS,\n  NetworksTicker,\n  ChainId,\n  InfuraNetworkType,\n  NetworkType,\n  isSafeChainId,\n  isInfuraNetworkType,\n} from '@metamask/controller-utils';\nimport EthQuery from '@metamask/eth-query';\nimport { errorCodes } from '@metamask/rpc-errors';\nimport { createEventEmitterProxy } from '@metamask/swappable-obj-proxy';\nimport type { SwappableProxy } from '@metamask/swappable-obj-proxy';\nimport type { Hex } from '@metamask/utils';\nimport {\n  assertIsStrictHexString,\n  hasProperty,\n  isPlainObject,\n} from '@metamask/utils';\nimport { strict as assert } from 'assert';\nimport { v4 as random } from 'uuid';\n\nimport { INFURA_BLOCKED_KEY, NetworkStatus } from './constants';\nimport type {\n  AutoManagedNetworkClient,\n  ProxyWithAccessibleTarget,\n} from './create-auto-managed-network-client';\nimport { createAutoManagedNetworkClient } from './create-auto-managed-network-client';\nimport { projectLogger, createModuleLogger } from './logger';\nimport { NetworkClientType } from './types';\nimport type {\n  BlockTracker,\n  Provider,\n  CustomNetworkClientConfiguration,\n  InfuraNetworkClientConfiguration,\n  NetworkClientConfiguration,\n} from './types';\n\nconst log = createModuleLogger(projectLogger, 'NetworkController');\n\n/**\n * @type ProviderConfig\n *\n * Configuration passed to web3-provider-engine\n * @property rpcUrl - RPC target URL.\n * @property type - Human-readable network name.\n * @property chainId - Network ID as per EIP-155.\n * @property ticker - Currency ticker.\n * @property nickname - Personalized network name.\n * @property id - Network Configuration Id.\n */\nexport type ProviderConfig = {\n  rpcUrl?: string;\n  type: NetworkType;\n  chainId: Hex;\n  ticker: string;\n  nickname?: string;\n  rpcPrefs?: { blockExplorerUrl?: string };\n  id?: NetworkConfigurationId;\n};\n\nexport type Block = {\n  baseFeePerGas?: string;\n};\n\n/**\n * Information about a network not held by any other part of state.\n */\nexport type NetworkMetadata = {\n  /**\n   * EIPs supported by the network.\n   */\n  EIPS: {\n    [eipNumber: number]: boolean;\n  };\n  /**\n   * Indicates the availability of the network\n   */\n  status: NetworkStatus;\n};\n\n/**\n * Custom RPC network information\n *\n * @property rpcUrl - RPC target URL.\n * @property chainId - Network ID as per EIP-155\n * @property nickname - Personalized network name.\n * @property ticker - Currency ticker.\n * @property rpcPrefs - Personalized preferences.\n */\nexport type NetworkConfiguration = {\n  rpcUrl: string;\n  chainId: Hex;\n  ticker: string;\n  nickname?: string;\n  rpcPrefs?: {\n    blockExplorerUrl: string;\n  };\n};\n\n/**\n * The collection of network configurations in state.\n */\ntype NetworkConfigurations = Record<\n  NetworkConfigurationId,\n  NetworkConfiguration & { id: NetworkConfigurationId }\n>;\n\n/**\n * `Object.keys()` is intentionally generic: it returns the keys of an object,\n * but it cannot make guarantees about the contents of that object, so the type\n * of the keys is merely `string[]`. While this is technically accurate, it is\n * also unnecessary if we have an object that we own and whose contents are\n * known exactly.\n *\n * TODO: Move to @metamask/utils.\n *\n * @param object - The object.\n * @returns The keys of an object, typed according to the type of the object\n * itself.\n */\nexport function knownKeysOf<K extends PropertyKey>(\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  object: Partial<Record<K, any>>,\n) {\n  return Object.keys(object) as K[];\n}\n\n/**\n * Asserts that the given value is of the given type if the given validation\n * function returns a truthy result.\n *\n * @param value - The value to validate.\n * @param validate - A function used to validate that the value is of the given\n * type. Takes the `value` as an argument and is expected to return true or\n * false.\n * @param message - The message to throw if the function does not return a\n * truthy result.\n * @throws if the function does not return a truthy result.\n */\nfunction assertOfType<Type>(\n  value: unknown,\n  validate: (value: unknown) => boolean,\n  message: string,\n): asserts value is Type {\n  assert.ok(validate(value), message);\n}\n\n/**\n * Returns a portion of the given object with only the given keys.\n *\n * @param object - An object.\n * @param keys - The keys to pick from the object.\n * @returns the portion of the object.\n */\n// TODO: Replace `any` with type\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction pick<Obj extends Record<any, any>, Keys extends keyof Obj>(\n  object: Obj,\n  keys: Keys[],\n): Pick<Obj, Keys> {\n  const pickedObject = keys.reduce<Partial<Pick<Obj, Keys>>>(\n    (finalObject, key) => {\n      return { ...finalObject, [key]: object[key] };\n    },\n    {},\n  );\n  assertOfType<Pick<Obj, Keys>>(\n    pickedObject,\n    () => keys.every((key) => key in pickedObject),\n    'The reduce did not produce an object with all of the desired keys.',\n  );\n  return pickedObject;\n}\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `code` property, such as an instance of Error.\n *\n * TODO: Move this to @metamask/utils.\n *\n * @param error - The object to check.\n * @returns True if `error` has a `code`, false otherwise.\n */\nfunction isErrorWithCode(error: unknown): error is { code: string | number } {\n  return typeof error === 'object' && error !== null && 'code' in error;\n}\n\n/**\n * Builds an identifier for an Infura network client for lookup purposes.\n *\n * @param infuraNetworkOrProviderConfig - The name of an Infura network or a\n * provider config.\n * @returns The built identifier.\n */\nfunction buildInfuraNetworkClientId(\n  infuraNetworkOrProviderConfig:\n    | InfuraNetworkType\n    | (ProviderConfig & { type: InfuraNetworkType }),\n): BuiltInNetworkClientId {\n  if (typeof infuraNetworkOrProviderConfig === 'string') {\n    return infuraNetworkOrProviderConfig;\n  }\n  return infuraNetworkOrProviderConfig.type;\n}\n\n/**\n * Builds an identifier for a custom network client for lookup purposes.\n *\n * @param args - This function can be called two ways:\n * 1. The ID of a network configuration.\n * 2. A provider config and a set of network configurations.\n * @returns The built identifier.\n */\nfunction buildCustomNetworkClientId(\n  ...args:\n    | [NetworkConfigurationId]\n    | [\n        ProviderConfig & { type: typeof NetworkType.rpc; rpcUrl: string },\n        NetworkConfigurations,\n      ]\n): CustomNetworkClientId {\n  if (args.length === 1) {\n    return args[0];\n  }\n  const [{ id, rpcUrl }, networkConfigurations] = args;\n  if (id === undefined) {\n    const matchingNetworkConfiguration = Object.values(\n      networkConfigurations,\n    ).find((networkConfiguration) => {\n      return networkConfiguration.rpcUrl === rpcUrl.toLowerCase();\n    });\n    if (matchingNetworkConfiguration) {\n      return matchingNetworkConfiguration.id;\n    }\n    return rpcUrl.toLowerCase();\n  }\n  return id;\n}\n\n/**\n * Returns whether the given provider config refers to an Infura network.\n *\n * @param providerConfig - The provider config.\n * @returns True if the provider config refers to an Infura network, false\n * otherwise.\n */\nfunction isInfuraProviderConfig(\n  providerConfig: ProviderConfig,\n): providerConfig is ProviderConfig & { type: InfuraNetworkType } {\n  return isInfuraNetworkType(providerConfig.type);\n}\n\n/**\n * Returns whether the given provider config refers to an Infura network.\n *\n * @param providerConfig - The provider config.\n * @returns True if the provider config refers to an Infura network, false\n * otherwise.\n */\nfunction isCustomProviderConfig(\n  providerConfig: ProviderConfig,\n): providerConfig is ProviderConfig & { type: typeof NetworkType.rpc } {\n  return providerConfig.type === NetworkType.rpc;\n}\n\n/**\n * As a provider config represents the settings that are used to interface with\n * an RPC endpoint, it must have both a chain ID and an RPC URL if it represents\n * a custom network. These properties _should_ be set as they are validated in\n * the UI when a user adds a custom network, but just to be safe we validate\n * them here.\n *\n * In addition, historically the `rpcUrl` property on the ProviderConfig type\n * has been optional, even though it should not be. Making this non-optional\n * would be a breaking change, so this function types the provider config\n * correctly so that we don't have to check `rpcUrl` in other places.\n *\n * @param providerConfig - A provider config.\n * @throws if the provider config does not have a chain ID or an RPC URL.\n */\nfunction validateCustomProviderConfig(\n  providerConfig: ProviderConfig & { type: typeof NetworkType.rpc },\n): asserts providerConfig is typeof providerConfig & { rpcUrl: string } {\n  if (providerConfig.chainId === undefined) {\n    throw new Error('chainId must be provided for custom RPC endpoints');\n  }\n  if (providerConfig.rpcUrl === undefined) {\n    throw new Error('rpcUrl must be provided for custom RPC endpoints');\n  }\n}\n/**\n * The string that uniquely identifies an Infura network client.\n */\nexport type BuiltInNetworkClientId = InfuraNetworkType;\n\n/**\n * The string that uniquely identifies a custom network client.\n */\nexport type CustomNetworkClientId = string;\n\n/**\n * The string that uniquely identifies a network client.\n */\nexport type NetworkClientId = BuiltInNetworkClientId | CustomNetworkClientId;\n\n/**\n * Information about networks not held by any other part of state.\n */\nexport type NetworksMetadata = {\n  [networkClientId: NetworkClientId]: NetworkMetadata;\n};\n\n/**\n * @type NetworkState\n *\n * Network controller state\n * @property providerConfig - RPC URL and network name provider settings of the currently connected network\n * @property properties - an additional set of network properties for the currently connected network\n * @property networkConfigurations - the full list of configured networks either preloaded or added by the user.\n */\nexport type NetworkState = {\n  selectedNetworkClientId: NetworkClientId;\n  providerConfig: ProviderConfig;\n  networkConfigurations: NetworkConfigurations;\n  networksMetadata: NetworksMetadata;\n};\n\nconst name = 'NetworkController';\n\n/**\n * Represents the block tracker for the currently selected network. (Note that\n * this is a proxy around a proxy: the inner one exists so that the block\n * tracker doesn't have to exist until it's used, and the outer one exists so\n * that the currently selected network can change without consumers needing to\n * refresh the object reference to that network.)\n */\nexport type BlockTrackerProxy = SwappableProxy<\n  ProxyWithAccessibleTarget<BlockTracker>\n>;\n\n/**\n * Represents the provider for the currently selected network. (Note that this\n * is a proxy around a proxy: the inner one exists so that the provider doesn't\n * have to exist until it's used, and the outer one exists so that the currently\n * selected network can change without consumers needing to refresh the object\n * reference to that network.)\n */\nexport type ProviderProxy = SwappableProxy<ProxyWithAccessibleTarget<Provider>>;\n\nexport type NetworkControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof name,\n  NetworkState\n>;\n\n/**\n * `networkWillChange` is published when the current network is about to be\n * switched, but the new provider has not been created and no state changes have\n * occurred yet.\n */\nexport type NetworkControllerNetworkWillChangeEvent = {\n  type: 'NetworkController:networkWillChange';\n  payload: [NetworkState];\n};\n\n/**\n * `networkDidChange` is published after a provider has been created for a newly\n * switched network (but before the network has been confirmed to be available).\n */\nexport type NetworkControllerNetworkDidChangeEvent = {\n  type: 'NetworkController:networkDidChange';\n  payload: [NetworkState];\n};\n\n/**\n * `infuraIsBlocked` is published after the network is switched to an Infura\n * network, but when Infura returns an error blocking the user based on their\n * location.\n */\nexport type NetworkControllerInfuraIsBlockedEvent = {\n  type: 'NetworkController:infuraIsBlocked';\n  payload: [];\n};\n\n/**\n * `infuraIsBlocked` is published either after the network is switched to an\n * Infura network and Infura does not return an error blocking the user based on\n * their location, or the network is switched to a non-Infura network.\n */\nexport type NetworkControllerInfuraIsUnblockedEvent = {\n  type: 'NetworkController:infuraIsUnblocked';\n  payload: [];\n};\n\nexport type NetworkControllerEvents =\n  | NetworkControllerStateChangeEvent\n  | NetworkControllerNetworkWillChangeEvent\n  | NetworkControllerNetworkDidChangeEvent\n  | NetworkControllerInfuraIsBlockedEvent\n  | NetworkControllerInfuraIsUnblockedEvent;\n\nexport type NetworkControllerGetStateAction = ControllerGetStateAction<\n  typeof name,\n  NetworkState\n>;\n\nexport type NetworkControllerGetProviderConfigAction = {\n  type: `NetworkController:getProviderConfig`;\n  handler: () => ProviderConfig;\n};\n\nexport type NetworkControllerGetEthQueryAction = {\n  type: `NetworkController:getEthQuery`;\n  handler: () => EthQuery | undefined;\n};\n\nexport type NetworkControllerGetNetworkClientByIdAction = {\n  type: `NetworkController:getNetworkClientById`;\n  handler: NetworkController['getNetworkClientById'];\n};\n\nexport type NetworkControllerGetSelectedNetworkClientAction = {\n  type: `NetworkController:getSelectedNetworkClient`;\n  handler: NetworkController['getSelectedNetworkClient'];\n};\n\nexport type NetworkControllerGetEIP1559CompatibilityAction = {\n  type: `NetworkController:getEIP1559Compatibility`;\n  handler: NetworkController['getEIP1559Compatibility'];\n};\n\nexport type NetworkControllerFindNetworkClientIdByChainIdAction = {\n  type: `NetworkController:findNetworkClientIdByChainId`;\n  handler: NetworkController['findNetworkClientIdByChainId'];\n};\n\n/**\n * Change the currently selected network to the given built-in network type.\n *\n * @deprecated This action has been replaced by `setActiveNetwork`, and will be\n * removed in a future release.\n */\nexport type NetworkControllerSetProviderTypeAction = {\n  type: `NetworkController:setProviderType`;\n  handler: NetworkController['setProviderType'];\n};\n\nexport type NetworkControllerSetActiveNetworkAction = {\n  type: `NetworkController:setActiveNetwork`;\n  handler: NetworkController['setActiveNetwork'];\n};\n\nexport type NetworkControllerGetNetworkConfigurationByNetworkClientId = {\n  type: `NetworkController:getNetworkConfigurationByNetworkClientId`;\n  handler: NetworkController['getNetworkConfigurationByNetworkClientId'];\n};\n\nexport type NetworkControllerActions =\n  | NetworkControllerGetStateAction\n  | NetworkControllerGetProviderConfigAction\n  | NetworkControllerGetEthQueryAction\n  | NetworkControllerGetNetworkClientByIdAction\n  | NetworkControllerGetSelectedNetworkClientAction\n  | NetworkControllerGetEIP1559CompatibilityAction\n  | NetworkControllerFindNetworkClientIdByChainIdAction\n  | NetworkControllerSetActiveNetworkAction\n  | NetworkControllerSetProviderTypeAction\n  | NetworkControllerGetNetworkConfigurationByNetworkClientId;\n\nexport type NetworkControllerMessenger = RestrictedControllerMessenger<\n  typeof name,\n  NetworkControllerActions,\n  NetworkControllerEvents,\n  never,\n  never\n>;\n\nexport type NetworkControllerOptions = {\n  messenger: NetworkControllerMessenger;\n  trackMetaMetricsEvent: () => void;\n  infuraProjectId: string;\n  state?: Partial<NetworkState>;\n};\n\nexport const defaultState: NetworkState = {\n  selectedNetworkClientId: NetworkType.mainnet,\n  providerConfig: {\n    type: NetworkType.mainnet,\n    chainId: ChainId.mainnet,\n    ticker: NetworksTicker.mainnet,\n  },\n  networksMetadata: {},\n  networkConfigurations: {},\n};\n\ntype MetaMetricsEventPayload = {\n  event: string;\n  category: string;\n  referrer?: { url: string };\n  actionId?: number;\n  environmentType?: string;\n  properties?: unknown;\n  sensitiveProperties?: unknown;\n  revenue?: number;\n  currency?: string;\n  value?: number;\n};\n\ntype NetworkConfigurationId = string;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks.\n */\ntype AutoManagedBuiltInNetworkClientRegistry = Record<\n  BuiltInNetworkClientId,\n  AutoManagedNetworkClient<InfuraNetworkClientConfiguration>\n>;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks.\n */\ntype AutoManagedCustomNetworkClientRegistry = Record<\n  CustomNetworkClientId,\n  AutoManagedNetworkClient<CustomNetworkClientConfiguration>\n>;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks\n * as well as custom networks that users have added.\n */\ntype AutoManagedNetworkClientRegistry = {\n  [NetworkClientType.Infura]: AutoManagedBuiltInNetworkClientRegistry;\n  [NetworkClientType.Custom]: AutoManagedCustomNetworkClientRegistry;\n};\n\n/**\n * Controller that creates and manages an Ethereum network provider.\n */\nexport class NetworkController extends BaseController<\n  typeof name,\n  NetworkState,\n  NetworkControllerMessenger\n> {\n  #ethQuery?: EthQuery;\n\n  #infuraProjectId: string;\n\n  #trackMetaMetricsEvent: (event: MetaMetricsEventPayload) => void;\n\n  #previousProviderConfig: ProviderConfig;\n\n  #providerProxy: ProviderProxy | undefined;\n\n  #blockTrackerProxy: BlockTrackerProxy | undefined;\n\n  #autoManagedNetworkClientRegistry?: AutoManagedNetworkClientRegistry;\n\n  constructor({\n    messenger,\n    state,\n    infuraProjectId,\n    trackMetaMetricsEvent,\n  }: NetworkControllerOptions) {\n    super({\n      name,\n      metadata: {\n        selectedNetworkClientId: {\n          persist: true,\n          anonymous: false,\n        },\n        networksMetadata: {\n          persist: true,\n          anonymous: false,\n        },\n        providerConfig: {\n          persist: true,\n          anonymous: false,\n        },\n        networkConfigurations: {\n          persist: true,\n          anonymous: false,\n        },\n      },\n      messenger,\n      state: { ...defaultState, ...state },\n    });\n    if (!infuraProjectId || typeof infuraProjectId !== 'string') {\n      throw new Error('Invalid Infura project ID');\n    }\n    this.#infuraProjectId = infuraProjectId;\n    this.#trackMetaMetricsEvent = trackMetaMetricsEvent;\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getProviderConfig`,\n      () => {\n        return this.state.providerConfig;\n      },\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getEthQuery`,\n      () => {\n        return this.#ethQuery;\n      },\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getNetworkClientById`,\n      this.getNetworkClientById.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getEIP1559Compatibility`,\n      this.getEIP1559Compatibility.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:setActiveNetwork`,\n      this.setActiveNetwork.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:setProviderType`,\n      this.setProviderType.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:findNetworkClientIdByChainId`,\n      this.findNetworkClientIdByChainId.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getNetworkConfigurationByNetworkClientId`,\n      this.getNetworkConfigurationByNetworkClientId.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getSelectedNetworkClient`,\n      this.getSelectedNetworkClient.bind(this),\n    );\n\n    this.#previousProviderConfig = this.state.providerConfig;\n  }\n\n  /**\n   * Accesses the provider and block tracker for the currently selected network.\n   * @returns The proxy and block tracker proxies.\n   * @deprecated This method has been replaced by `getSelectedNetworkClient` (which has a more easily used return type) and will be removed in a future release.\n   */\n  getProviderAndBlockTracker(): {\n    provider: SwappableProxy<ProxyWithAccessibleTarget<Provider>> | undefined;\n    blockTracker:\n      | SwappableProxy<ProxyWithAccessibleTarget<BlockTracker>>\n      | undefined;\n  } {\n    return {\n      provider: this.#providerProxy,\n      blockTracker: this.#blockTrackerProxy,\n    };\n  }\n\n  /**\n   * Accesses the provider and block tracker for the currently selected network.\n   *\n   * @returns an object with the provider and block tracker proxies for the currently selected network.\n   */\n  getSelectedNetworkClient():\n    | {\n        provider: SwappableProxy<ProxyWithAccessibleTarget<Provider>>;\n        blockTracker: SwappableProxy<ProxyWithAccessibleTarget<BlockTracker>>;\n      }\n    | undefined {\n    if (this.#providerProxy && this.#blockTrackerProxy) {\n      return {\n        provider: this.#providerProxy,\n        blockTracker: this.#blockTrackerProxy,\n      };\n    }\n    return undefined;\n  }\n\n  /**\n   * Returns all of the network clients that have been created so far, keyed by\n   * their identifier in the network client registry. This collection represents\n   * not only built-in networks but also any custom networks that consumers have\n   * added.\n   *\n   * @returns The list of known network clients.\n   */\n  getNetworkClientRegistry(): AutoManagedBuiltInNetworkClientRegistry &\n    AutoManagedCustomNetworkClientRegistry {\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    return Object.assign(\n      {},\n      autoManagedNetworkClientRegistry[NetworkClientType.Infura],\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom],\n    );\n  }\n\n  /**\n   * Returns the Infura network client with the given ID.\n   *\n   * @param infuraNetworkClientId - An Infura network client ID.\n   * @returns The Infura network client.\n   * @throws If an Infura network client does not exist with the given ID.\n   */\n  getNetworkClientById(\n    infuraNetworkClientId: BuiltInNetworkClientId,\n  ): AutoManagedNetworkClient<InfuraNetworkClientConfiguration>;\n\n  /**\n   * Returns the custom network client with the given ID.\n   *\n   * @param customNetworkClientId - A custom network client ID.\n   * @returns The custom network client.\n   * @throws If a custom network client does not exist with the given ID.\n   */\n  getNetworkClientById(\n    customNetworkClientId: CustomNetworkClientId,\n  ): AutoManagedNetworkClient<CustomNetworkClientConfiguration>;\n\n  getNetworkClientById(\n    networkClientId: NetworkClientId,\n  ): AutoManagedNetworkClient<NetworkClientConfiguration> {\n    if (!networkClientId) {\n      throw new Error('No network client ID was provided.');\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    if (isInfuraNetworkType(networkClientId)) {\n      const infuraNetworkClient =\n        autoManagedNetworkClientRegistry[NetworkClientType.Infura][\n          networkClientId\n        ];\n      if (!infuraNetworkClient) {\n        throw new Error(\n          `No Infura network client was found with the ID \"${networkClientId}\".`,\n        );\n      }\n      return infuraNetworkClient;\n    }\n\n    const customNetworkClient =\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom][\n        networkClientId\n      ];\n    if (!customNetworkClient) {\n      throw new Error(\n        `No custom network client was found with the ID \"${networkClientId}\".`,\n      );\n    }\n    return customNetworkClient;\n  }\n\n  /**\n   * Executes a series of steps to apply the changes to the provider config:\n   *\n   * 1. Notifies subscribers that the network is about to change.\n   * 2. Looks up a known and preinitialized network client matching the provider\n   * config and re-points the provider and block tracker proxy to it.\n   * 3. Notifies subscribers that the network has changed.\n   */\n  async #refreshNetwork() {\n    this.messagingSystem.publish(\n      'NetworkController:networkWillChange',\n      this.state,\n    );\n    this.#applyNetworkSelection();\n    this.messagingSystem.publish(\n      'NetworkController:networkDidChange',\n      this.state,\n    );\n    await this.lookupNetwork();\n  }\n\n  /**\n   * Populates the network clients and establishes the initial network based on\n   * the provider configuration in state.\n   */\n  async initializeProvider() {\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.#applyNetworkSelection();\n    // Core Patch Branch: jl/network-controller@19.0.0-patch\n    // await this.lookupNetwork();\n  }\n\n  /**\n   * Refreshes the network meta with EIP-1559 support and the network status\n   * based on the given network client ID.\n   *\n   * @param networkClientId - The ID of the network client to update.\n   */\n  async lookupNetworkByClientId(networkClientId: NetworkClientId) {\n    const isInfura = isInfuraNetworkType(networkClientId);\n    let updatedNetworkStatus: NetworkStatus;\n    let updatedIsEIP1559Compatible: boolean | undefined;\n\n    try {\n      updatedIsEIP1559Compatible = await this.#determineEIP1559Compatibility(\n        networkClientId,\n      );\n      updatedNetworkStatus = NetworkStatus.Available;\n    } catch (error) {\n      if (isErrorWithCode(error)) {\n        let responseBody;\n        if (\n          isInfura &&\n          hasProperty(error, 'message') &&\n          typeof error.message === 'string'\n        ) {\n          try {\n            responseBody = JSON.parse(error.message);\n          } catch {\n            // error.message must not be JSON\n          }\n        }\n\n        if (\n          isPlainObject(responseBody) &&\n          responseBody.error === INFURA_BLOCKED_KEY\n        ) {\n          updatedNetworkStatus = NetworkStatus.Blocked;\n        } else if (error.code === errorCodes.rpc.internal) {\n          updatedNetworkStatus = NetworkStatus.Unknown;\n        } else {\n          updatedNetworkStatus = NetworkStatus.Unavailable;\n        }\n      } else if (\n        typeof Error !== 'undefined' &&\n        hasProperty(error as unknown as Error, 'message') &&\n        typeof (error as unknown as Error).message === 'string' &&\n        (error as unknown as Error).message.includes(\n          'No custom network client was found with the ID',\n        )\n      ) {\n        throw error;\n      } else {\n        log('NetworkController - could not determine network status', error);\n        updatedNetworkStatus = NetworkStatus.Unknown;\n      }\n    }\n    this.update((state) => {\n      if (state.networksMetadata[networkClientId] === undefined) {\n        state.networksMetadata[networkClientId] = {\n          status: NetworkStatus.Unknown,\n          EIPS: {},\n        };\n      }\n      const meta = state.networksMetadata[networkClientId];\n      meta.status = updatedNetworkStatus;\n      if (updatedIsEIP1559Compatible === undefined) {\n        delete meta.EIPS[1559];\n      } else {\n        meta.EIPS[1559] = updatedIsEIP1559Compatible;\n      }\n    });\n  }\n\n  /**\n   * Performs side effects after switching to a network. If the network is\n   * available, updates the network state with the network ID of the network and\n   * stores whether the network supports EIP-1559; otherwise clears said\n   * information about the network that may have been previously stored.\n   *\n   * @param networkClientId - (Optional) The ID of the network client to update.\n   * If no ID is provided, uses the currently selected network.\n   * @fires infuraIsBlocked if the network is Infura-supported and is blocking\n   * requests.\n   * @fires infuraIsUnblocked if the network is Infura-supported and is not\n   * blocking requests, or if the network is not Infura-supported.\n   */\n  async lookupNetwork(networkClientId?: NetworkClientId) {\n    if (networkClientId) {\n      await this.lookupNetworkByClientId(networkClientId);\n      return;\n    }\n\n    if (!this.#ethQuery) {\n      return;\n    }\n\n    const isInfura = isInfuraProviderConfig(this.state.providerConfig);\n\n    let networkChanged = false;\n    const listener = () => {\n      networkChanged = true;\n      this.messagingSystem.unsubscribe(\n        'NetworkController:networkDidChange',\n        listener,\n      );\n    };\n    this.messagingSystem.subscribe(\n      'NetworkController:networkDidChange',\n      listener,\n    );\n\n    let updatedNetworkStatus: NetworkStatus;\n    let updatedIsEIP1559Compatible: boolean | undefined;\n\n    try {\n      const isEIP1559Compatible = await this.#determineEIP1559Compatibility(\n        this.state.selectedNetworkClientId,\n      );\n      updatedNetworkStatus = NetworkStatus.Available;\n      updatedIsEIP1559Compatible = isEIP1559Compatible;\n    } catch (error) {\n      if (isErrorWithCode(error)) {\n        let responseBody;\n        if (\n          isInfura &&\n          hasProperty(error, 'message') &&\n          typeof error.message === 'string'\n        ) {\n          try {\n            responseBody = JSON.parse(error.message);\n          } catch {\n            // error.message must not be JSON\n          }\n        }\n\n        if (\n          isPlainObject(responseBody) &&\n          responseBody.error === INFURA_BLOCKED_KEY\n        ) {\n          updatedNetworkStatus = NetworkStatus.Blocked;\n        } else if (error.code === errorCodes.rpc.internal) {\n          updatedNetworkStatus = NetworkStatus.Unknown;\n        } else {\n          updatedNetworkStatus = NetworkStatus.Unavailable;\n        }\n      } else {\n        log('NetworkController - could not determine network status', error);\n        updatedNetworkStatus = NetworkStatus.Unknown;\n      }\n    }\n\n    if (networkChanged) {\n      // If the network has changed, then `lookupNetwork` either has been or is\n      // in the process of being called, so we don't need to go further.\n      return;\n    }\n    this.messagingSystem.unsubscribe(\n      'NetworkController:networkDidChange',\n      listener,\n    );\n\n    this.update((state) => {\n      const meta = state.networksMetadata[state.selectedNetworkClientId];\n      meta.status = updatedNetworkStatus;\n      if (updatedIsEIP1559Compatible === undefined) {\n        delete meta.EIPS[1559];\n      } else {\n        meta.EIPS[1559] = updatedIsEIP1559Compatible;\n      }\n    });\n\n    if (isInfura) {\n      if (updatedNetworkStatus === NetworkStatus.Available) {\n        this.messagingSystem.publish('NetworkController:infuraIsUnblocked');\n      } else if (updatedNetworkStatus === NetworkStatus.Blocked) {\n        this.messagingSystem.publish('NetworkController:infuraIsBlocked');\n      }\n    } else {\n      // Always publish infuraIsUnblocked regardless of network status to\n      // prevent consumers from being stuck in a blocked state if they were\n      // previously connected to an Infura network that was blocked\n      this.messagingSystem.publish('NetworkController:infuraIsUnblocked');\n    }\n  }\n\n  /**\n   * Convenience method to update provider network type settings.\n   *\n   * @param type - Human readable network name.\n   * @deprecated This has been replaced by `setActiveNetwork`, and will be\n   * removed in a future release\n   */\n  async setProviderType(type: InfuraNetworkType) {\n    assert.notStrictEqual(\n      type,\n      NetworkType.rpc,\n      `NetworkController - cannot call \"setProviderType\" with type \"${NetworkType.rpc}\". Use \"setActiveNetwork\"`,\n    );\n    assert.ok(\n      isInfuraNetworkType(type),\n      `Unknown Infura provider type \"${type}\".`,\n    );\n\n    await this.setActiveNetwork(type);\n  }\n\n  /**\n   * Convenience method to update provider RPC settings.\n   *\n   * @param networkConfigurationIdOrType - The unique id for the network configuration to set as the active provider,\n   * or the type of a built-in network.\n   */\n  async setActiveNetwork(networkConfigurationIdOrType: string) {\n    this.#previousProviderConfig = this.state.providerConfig;\n\n    let targetNetwork: ProviderConfig;\n    if (isInfuraNetworkType(networkConfigurationIdOrType)) {\n      const ticker = NetworksTicker[networkConfigurationIdOrType];\n\n      targetNetwork = {\n        chainId: ChainId[networkConfigurationIdOrType],\n        id: undefined,\n        rpcPrefs: BUILT_IN_NETWORKS[networkConfigurationIdOrType].rpcPrefs,\n        rpcUrl: undefined,\n        nickname: undefined,\n        ticker,\n        type: networkConfigurationIdOrType,\n      };\n    } else {\n      if (\n        !Object.keys(this.state.networkConfigurations).includes(\n          networkConfigurationIdOrType,\n        )\n      ) {\n        throw new Error(\n          `networkConfigurationId ${networkConfigurationIdOrType} does not match a configured networkConfiguration or built-in network type`,\n        );\n      }\n      targetNetwork = {\n        ...this.state.networkConfigurations[networkConfigurationIdOrType],\n        type: NetworkType.rpc,\n      };\n    }\n\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.update((state) => {\n      state.providerConfig = targetNetwork;\n    });\n\n    await this.#refreshNetwork();\n  }\n\n  /**\n   * Fetches the latest block for the network.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check the latest block. Defaults to the selectedNetworkClientId.\n   * @returns A promise that either resolves to the block header or null if\n   * there is no latest block, or rejects with an error.\n   */\n  #getLatestBlock(networkClientId: NetworkClientId): Promise<Block> {\n    if (networkClientId === undefined) {\n      networkClientId = this.state.selectedNetworkClientId;\n    }\n\n    const networkClient = this.getNetworkClientById(networkClientId);\n    const ethQuery = new EthQuery(networkClient.provider);\n\n    return new Promise((resolve, reject) => {\n      ethQuery.sendAsync(\n        { method: 'eth_getBlockByNumber', params: ['latest', false] },\n        (error: unknown, block?: unknown) => {\n          if (error) {\n            reject(error);\n          } else {\n            // TODO: Validate this type\n            resolve(block as Block);\n          }\n        },\n      );\n    });\n  }\n\n  /**\n   * Determines whether the network supports EIP-1559 by checking whether the\n   * latest block has a `baseFeePerGas` property, then updates state\n   * appropriately.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility.\n   * @returns A promise that resolves to true if the network supports EIP-1559\n   * , false otherwise, or `undefined` if unable to determine the compatibility.\n   */\n  async getEIP1559Compatibility(networkClientId?: NetworkClientId) {\n    if (networkClientId) {\n      return this.get1559CompatibilityWithNetworkClientId(networkClientId);\n    }\n    if (!this.#ethQuery) {\n      return false;\n    }\n\n    const { EIPS } =\n      this.state.networksMetadata[this.state.selectedNetworkClientId];\n\n    if (EIPS[1559] !== undefined) {\n      return EIPS[1559];\n    }\n\n    const isEIP1559Compatible = await this.#determineEIP1559Compatibility(\n      this.state.selectedNetworkClientId,\n    );\n    this.update((state) => {\n      if (isEIP1559Compatible !== undefined) {\n        state.networksMetadata[state.selectedNetworkClientId].EIPS[1559] =\n          isEIP1559Compatible;\n      }\n    });\n    return isEIP1559Compatible;\n  }\n\n  async get1559CompatibilityWithNetworkClientId(\n    networkClientId: NetworkClientId,\n  ) {\n    let metadata = this.state.networksMetadata[networkClientId];\n    if (metadata === undefined) {\n      await this.lookupNetwork(networkClientId);\n      metadata = this.state.networksMetadata[networkClientId];\n    }\n    const { EIPS } = metadata;\n\n    // may want to include some 'freshness' value - something to make sure we refetch this from time to time\n    return EIPS[1559];\n  }\n\n  /**\n   * Retrieves and checks the latest block from the currently selected\n   * network; if the block has a `baseFeePerGas` property, then we know\n   * that the network supports EIP-1559; otherwise it doesn't.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility\n   * @returns A promise that resolves to `true` if the network supports EIP-1559,\n   * `false` otherwise, or `undefined` if unable to retrieve the last block.\n   */\n  async #determineEIP1559Compatibility(\n    networkClientId: NetworkClientId,\n  ): Promise<boolean | undefined> {\n    const latestBlock = await this.#getLatestBlock(networkClientId);\n\n    if (!latestBlock) {\n      return undefined;\n    }\n\n    return latestBlock.baseFeePerGas !== undefined;\n  }\n\n  /**\n   * Re-initializes the provider and block tracker for the current network.\n   */\n  async resetConnection() {\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n    await this.#refreshNetwork();\n  }\n\n  /**\n   * Returns a configuration object for the network identified by the given\n   * network client ID. If given an Infura network type, constructs one based on\n   * what we know about the network; otherwise attempts locates a network\n   * configuration in state that corresponds to the network client ID.\n   *\n   * @param networkClientId - The network client ID.\n   * @returns The configuration for the referenced network if one exists, or\n   * undefined otherwise.\n   */\n  getNetworkConfigurationByNetworkClientId(\n    networkClientId: NetworkClientId,\n  ): NetworkConfiguration | undefined {\n    if (isInfuraNetworkType(networkClientId)) {\n      const rpcUrl = `https://${networkClientId}.infura.io/v3/${\n        this.#infuraProjectId\n      }`;\n      return {\n        rpcUrl,\n        ...BUILT_IN_NETWORKS[networkClientId],\n      };\n    }\n\n    return this.state.networkConfigurations[networkClientId];\n  }\n\n  /**\n   * Adds a new custom network or updates the information for an existing\n   * network.\n   *\n   * This may involve updating the `networkConfigurations` property in\n   * state as well and/or adding a new network client to the network client\n   * registry. The `rpcUrl` and `chainId` of the given object are used to\n   * determine which action to take:\n   *\n   * - If the `rpcUrl` corresponds to an existing network configuration\n   * (case-insensitively), then it is overwritten with the object. Furthermore,\n   * if the `chainId` is different from the existing network configuration, then\n   * the existing network client is replaced with a new one.\n   * - If the `rpcUrl` does not correspond to an existing network configuration\n   * (case-insensitively), then the object is used to add a new network\n   * configuration along with a new network client.\n   *\n   * @param networkConfiguration - The network configuration to add or update.\n   * @param options - Additional configuration options.\n   * @param options.referrer - Used to create a metrics event; the site from which the call originated, or 'metamask' for internal calls.\n   * @param options.source - Used to create a metrics event; where the event originated (i.e. from a dapp or from the network form).\n   * @param options.setActive - If true, switches to the network upon adding or updating it (default: false).\n   * @returns The ID for the added or updated network configuration.\n   */\n  async upsertNetworkConfiguration(\n    // Core PR: https://github.com/MetaMask/core/pull/4614\n    // Core Patch Branch: jl/network-controller@19.0.0-patch\n    networkConfiguration: NetworkConfiguration & {\n      id?: NetworkConfigurationId;\n    },\n    {\n      referrer,\n      source,\n      setActive = false,\n    }: {\n      referrer: string;\n      source: string;\n      setActive?: boolean;\n    },\n  ): Promise<string> {\n    // Core PR: https://github.com/MetaMask/core/pull/4614\n    // Core Patch Branch: jl/network-controller@19.0.0-patch\n    const sanitizedNetworkConfiguration: NetworkConfiguration & {\n      id?: NetworkConfigurationId;\n    } = pick(networkConfiguration, [\n      'rpcUrl',\n      'chainId',\n      'ticker',\n      'nickname',\n      'rpcPrefs',\n      'id',\n    ]);\n    const { rpcUrl, chainId, ticker, id } = sanitizedNetworkConfiguration;\n\n    assertIsStrictHexString(chainId);\n    if (!isSafeChainId(chainId)) {\n      throw new Error(\n        `Invalid chain ID \"${chainId}\": numerical value greater than max safe value.`,\n      );\n    }\n    if (!rpcUrl) {\n      throw new Error(\n        'An rpcUrl is required to add or update network configuration',\n      );\n    }\n    if (!referrer || !source) {\n      throw new Error(\n        'referrer and source are required arguments for adding or updating a network configuration',\n      );\n    }\n    try {\n      new URL(rpcUrl);\n      // TODO: Replace `any` with type\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      if (e.message.includes('Invalid URL')) {\n        throw new Error('rpcUrl must be a valid URL');\n      }\n    }\n    if (!ticker) {\n      throw new Error(\n        'A ticker is required to add or update networkConfiguration',\n      );\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    // Core PR: https://github.com/MetaMask/core/pull/4614\n    // Core Patch Branch: jl/network-controller@19.0.0-patch\n    const existingNetworkConfigurationWithId = Object.values(\n      this.state.networkConfigurations,\n    ).find((networkConfig) => networkConfig.id === id);\n    if (id && !existingNetworkConfigurationWithId) {\n      throw new Error('No network configuration matches the provided id');\n    }\n\n    const existingNetworkConfigurationWithRpcUrl = Object.values(\n      this.state.networkConfigurations,\n    ).find(\n      (networkConfig) =>\n        networkConfig.rpcUrl.toLowerCase() === rpcUrl.toLowerCase(),\n    );\n    if (\n      id &&\n      existingNetworkConfigurationWithRpcUrl &&\n      existingNetworkConfigurationWithRpcUrl.id !== id\n    ) {\n      throw new Error(\n        'A different network configuration already exists with the provided rpcUrl',\n      );\n    }\n\n    const existingNetworkConfiguration =\n      existingNetworkConfigurationWithId ??\n      existingNetworkConfigurationWithRpcUrl;\n\n    const upsertedNetworkConfigurationId = existingNetworkConfiguration\n      ? existingNetworkConfiguration.id\n      : random();\n    const networkClientId = buildCustomNetworkClientId(\n      upsertedNetworkConfigurationId,\n    );\n\n    const customNetworkClientRegistry =\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom];\n    const existingAutoManagedNetworkClient =\n      customNetworkClientRegistry[networkClientId];\n    const shouldDestroyExistingNetworkClient =\n      existingAutoManagedNetworkClient &&\n      existingAutoManagedNetworkClient.configuration.chainId !== chainId;\n    if (shouldDestroyExistingNetworkClient) {\n      existingAutoManagedNetworkClient.destroy();\n    }\n    if (\n      !existingAutoManagedNetworkClient ||\n      shouldDestroyExistingNetworkClient\n    ) {\n      customNetworkClientRegistry[networkClientId] =\n        createAutoManagedNetworkClient({\n          type: NetworkClientType.Custom,\n          chainId,\n          rpcUrl,\n          ticker,\n        });\n    }\n\n    this.update((state) => {\n      state.networkConfigurations[upsertedNetworkConfigurationId] = {\n        // Core PR: https://github.com/MetaMask/core/pull/4614\n        // Core Patch Branch: jl/network-controller@19.0.0-patch\n        ...sanitizedNetworkConfiguration,\n        id: upsertedNetworkConfigurationId,\n      };\n    });\n\n    if (!existingNetworkConfiguration) {\n      this.#trackMetaMetricsEvent({\n        event: 'Custom Network Added',\n        category: 'Network',\n        referrer: {\n          url: referrer,\n        },\n        properties: {\n          chain_id: chainId,\n          symbol: ticker,\n          source,\n        },\n      });\n    }\n\n    if (setActive) {\n      await this.setActiveNetwork(upsertedNetworkConfigurationId);\n    }\n\n    return upsertedNetworkConfigurationId;\n  }\n\n  /**\n   * Removes a custom network from state.\n   *\n   * This involves updating the `networkConfigurations` property in state as\n   * well and removing the network client that corresponds to the network from\n   * the client registry.\n   *\n   * @param networkConfigurationId - The ID of an existing network\n   * configuration.\n   */\n  removeNetworkConfiguration(networkConfigurationId: string) {\n    if (!this.state.networkConfigurations[networkConfigurationId]) {\n      throw new Error(\n        `networkConfigurationId ${networkConfigurationId} does not match a configured networkConfiguration`,\n      );\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n    const networkClientId = buildCustomNetworkClientId(networkConfigurationId);\n\n    this.update((state) => {\n      delete state.networkConfigurations[networkConfigurationId];\n    });\n\n    const customNetworkClientRegistry =\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom];\n    const existingAutoManagedNetworkClient =\n      customNetworkClientRegistry[networkClientId];\n    existingAutoManagedNetworkClient.destroy();\n    delete customNetworkClientRegistry[networkClientId];\n  }\n\n  /**\n   * Switches to the previously selected network, assuming that there is one\n   * (if not and `initializeProvider` has not been previously called, then this\n   * method is equivalent to calling `resetConnection`).\n   */\n  async rollbackToPreviousProvider() {\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.update((state) => {\n      state.providerConfig = this.#previousProviderConfig;\n    });\n\n    await this.#refreshNetwork();\n  }\n\n  /**\n   * Deactivates the controller, stopping any ongoing polling.\n   *\n   * In-progress requests will not be aborted.\n   */\n  async destroy() {\n    await this.#blockTrackerProxy?.destroy();\n  }\n\n  /**\n   * Updates the controller using the given backup data.\n   *\n   * @param backup - The data that has been backed up.\n   * @param backup.networkConfigurations - Network configurations in the backup.\n   */\n  loadBackup({\n    networkConfigurations,\n  }: {\n    networkConfigurations: NetworkState['networkConfigurations'];\n  }): void {\n    this.update((state) => {\n      state.networkConfigurations = {\n        ...state.networkConfigurations,\n        ...networkConfigurations,\n      };\n    });\n  }\n\n  /**\n   * Searches for a network configuration ID with the given ChainID and returns it.\n   *\n   * @param chainId - ChainId to search for\n   * @returns networkClientId of the network configuration with the given chainId\n   */\n  findNetworkClientIdByChainId(chainId: Hex): NetworkClientId {\n    const networkClients = this.getNetworkClientRegistry();\n    const networkClientEntry = Object.entries(networkClients).find(\n      ([_, networkClient]) => networkClient.configuration.chainId === chainId,\n    );\n    if (networkClientEntry === undefined) {\n      throw new Error(\"Couldn't find networkClientId for chainId\");\n    }\n    return networkClientEntry[0];\n  }\n\n  /**\n   * Before accessing or switching the network, the registry of network clients\n   * needs to be populated. Otherwise, `#applyNetworkSelection` and\n   * `getNetworkClientRegistry` will throw an error. This method checks to see if the\n   * population step has happened yet, and if not, makes it happen.\n   *\n   * @returns The populated network client registry.\n   */\n  #ensureAutoManagedNetworkClientRegistryPopulated(): AutoManagedNetworkClientRegistry {\n    const autoManagedNetworkClientRegistry =\n      this.#autoManagedNetworkClientRegistry ??\n      this.#createAutoManagedNetworkClientRegistry();\n    this.#autoManagedNetworkClientRegistry = autoManagedNetworkClientRegistry;\n    return autoManagedNetworkClientRegistry;\n  }\n\n  /**\n   * Constructs the registry of network clients based on the set of built-in\n   * networks as well as the custom networks in state.\n   *\n   * @returns The network clients keyed by ID.\n   */\n  #createAutoManagedNetworkClientRegistry(): AutoManagedNetworkClientRegistry {\n    return [\n      ...this.#buildIdentifiedInfuraNetworkClientConfigurations(),\n      ...this.#buildIdentifiedCustomNetworkClientConfigurations(),\n      ...this.#buildIdentifiedNetworkClientConfigurationsFromProviderConfig(),\n    ].reduce(\n      (\n        registry,\n        [networkClientType, networkClientId, networkClientConfiguration],\n      ) => {\n        const autoManagedNetworkClient = createAutoManagedNetworkClient(\n          networkClientConfiguration,\n        );\n        if (networkClientId in registry[networkClientType]) {\n          return registry;\n        }\n        return {\n          ...registry,\n          [networkClientType]: {\n            ...registry[networkClientType],\n            [networkClientId]: autoManagedNetworkClient,\n          },\n        };\n      },\n      {\n        [NetworkClientType.Infura]: {},\n        [NetworkClientType.Custom]: {},\n      },\n    ) as AutoManagedNetworkClientRegistry;\n  }\n\n  /**\n   * Constructs the list of network clients for built-in networks (that is,\n   * the subset of the networks we know Infura supports that consumers do not\n   * need to explicitly add).\n   *\n   * @returns The network clients.\n   */\n  #buildIdentifiedInfuraNetworkClientConfigurations(): [\n    NetworkClientType.Infura,\n    BuiltInNetworkClientId,\n    InfuraNetworkClientConfiguration,\n  ][] {\n    return knownKeysOf(InfuraNetworkType).map((network) => {\n      const networkClientId = buildInfuraNetworkClientId(network);\n      const networkClientConfiguration: InfuraNetworkClientConfiguration = {\n        type: NetworkClientType.Infura,\n        network,\n        infuraProjectId: this.#infuraProjectId,\n        chainId: BUILT_IN_NETWORKS[network].chainId,\n        ticker: BUILT_IN_NETWORKS[network].ticker,\n      };\n      return [\n        NetworkClientType.Infura,\n        networkClientId,\n        networkClientConfiguration,\n      ];\n    });\n  }\n\n  /**\n   * Constructs the list of network clients for custom networks (that is, those\n   * which consumers have added via `networkConfigurations`).\n   *\n   * @returns The network clients.\n   */\n  #buildIdentifiedCustomNetworkClientConfigurations(): [\n    NetworkClientType.Custom,\n    CustomNetworkClientId,\n    CustomNetworkClientConfiguration,\n  ][] {\n    return Object.entries(this.state.networkConfigurations).map(\n      ([networkConfigurationId, networkConfiguration]) => {\n        if (networkConfiguration.chainId === undefined) {\n          throw new Error('chainId must be provided for custom RPC endpoints');\n        }\n        if (networkConfiguration.rpcUrl === undefined) {\n          throw new Error('rpcUrl must be provided for custom RPC endpoints');\n        }\n        const networkClientId = buildCustomNetworkClientId(\n          networkConfigurationId,\n        );\n        const networkClientConfiguration: CustomNetworkClientConfiguration = {\n          type: NetworkClientType.Custom,\n          chainId: networkConfiguration.chainId,\n          rpcUrl: networkConfiguration.rpcUrl,\n          ticker: networkConfiguration.ticker,\n        };\n        return [\n          NetworkClientType.Custom,\n          networkClientId,\n          networkClientConfiguration,\n        ];\n      },\n    );\n  }\n\n  /**\n   * Converts the provider config object in state to a network client\n   * configuration object.\n   *\n   * @returns The network client config.\n   * @throws If the provider config is of type \"rpc\" and lacks either a\n   * `chainId` or an `rpcUrl`.\n   */\n  #buildIdentifiedNetworkClientConfigurationsFromProviderConfig():\n    | [\n        [\n          NetworkClientType.Custom,\n          CustomNetworkClientId,\n          CustomNetworkClientConfiguration,\n        ],\n      ]\n    | [] {\n    const { providerConfig } = this.state;\n\n    if (isCustomProviderConfig(providerConfig)) {\n      validateCustomProviderConfig(providerConfig);\n      const networkClientId = buildCustomNetworkClientId(\n        providerConfig,\n        this.state.networkConfigurations,\n      );\n      const networkClientConfiguration: CustomNetworkClientConfiguration = {\n        chainId: providerConfig.chainId,\n        rpcUrl: providerConfig.rpcUrl,\n        type: NetworkClientType.Custom,\n        ticker: providerConfig.ticker,\n      };\n      return [\n        [NetworkClientType.Custom, networkClientId, networkClientConfiguration],\n      ];\n    }\n\n    if (isInfuraProviderConfig(providerConfig)) {\n      return [];\n    }\n\n    throw new Error(`Unrecognized network type: '${providerConfig.type}'`);\n  }\n\n  /**\n   * Uses the information in the provider config object to look up a known and\n   * preinitialized network client. Once a network client is found, updates the\n   * provider and block tracker proxy to point to those from the network client,\n   * then finally creates an EthQuery that points to the provider proxy.\n   *\n   * @throws If no network client could be found matching the current provider\n   * config.\n   */\n  #applyNetworkSelection() {\n    if (!this.#autoManagedNetworkClientRegistry) {\n      throw new Error(\n        'initializeProvider must be called first in order to switch the network',\n      );\n    }\n\n    const { providerConfig } = this.state;\n\n    let autoManagedNetworkClient: AutoManagedNetworkClient<NetworkClientConfiguration>;\n\n    let networkClientId: NetworkClientId;\n    if (isInfuraProviderConfig(providerConfig)) {\n      const networkClientType = NetworkClientType.Infura;\n      networkClientId = buildInfuraNetworkClientId(providerConfig);\n      const builtInNetworkClientRegistry =\n        this.#autoManagedNetworkClientRegistry[networkClientType];\n      autoManagedNetworkClient =\n        builtInNetworkClientRegistry[networkClientId as BuiltInNetworkClientId];\n      if (!autoManagedNetworkClient) {\n        throw new Error(\n          `Could not find custom network matching ${networkClientId}`,\n        );\n      }\n    } else if (isCustomProviderConfig(providerConfig)) {\n      validateCustomProviderConfig(providerConfig);\n      const networkClientType = NetworkClientType.Custom;\n      networkClientId = buildCustomNetworkClientId(\n        providerConfig,\n        this.state.networkConfigurations,\n      );\n      const customNetworkClientRegistry =\n        this.#autoManagedNetworkClientRegistry[networkClientType];\n      autoManagedNetworkClient = customNetworkClientRegistry[networkClientId];\n      if (!autoManagedNetworkClient) {\n        throw new Error(\n          `Could not find built-in network matching ${networkClientId}`,\n        );\n      }\n    } else {\n      throw new Error('Could not determine type of provider config');\n    }\n\n    this.update((state) => {\n      state.selectedNetworkClientId = networkClientId;\n      if (state.networksMetadata[networkClientId] === undefined) {\n        state.networksMetadata[networkClientId] = {\n          status: NetworkStatus.Unknown,\n          EIPS: {},\n        };\n      }\n    });\n\n    const { provider, blockTracker } = autoManagedNetworkClient;\n\n    if (this.#providerProxy) {\n      this.#providerProxy.setTarget(provider);\n    } else {\n      this.#providerProxy = createEventEmitterProxy(provider);\n    }\n\n    if (this.#blockTrackerProxy) {\n      this.#blockTrackerProxy.setTarget(blockTracker);\n    } else {\n      this.#blockTrackerProxy = createEventEmitterProxy(blockTracker, {\n        eventFilter: 'skipInternal',\n      });\n    }\n\n    this.#ethQuery = new EthQuery(this.#providerProxy);\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAKA,SAAS,sBAAsB;AAC/B;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,OAAO,cAAc;AACrB,SAAS,kBAAkB;AAC3B,SAAS,+BAA+B;AAGxC;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,UAAU,cAAc;AACjC,SAAS,MAAM,cAAc;AAkB7B,IAAM,MAAM,mBAAmB,eAAe,mBAAmB;AAmF1D,SAAS,YAGd,QACA;AACA,SAAO,OAAO,KAAK,MAAM;AAC3B;AAcA,SAAS,aACP,OACA,UACA,SACuB;AACvB,SAAO,GAAG,SAAS,KAAK,GAAG,OAAO;AACpC;AAWA,SAAS,KACP,QACA,MACiB;AACjB,QAAM,eAAe,KAAK;AAAA,IACxB,CAAC,aAAa,QAAQ;AACpB,aAAO,EAAE,GAAG,aAAa,CAAC,GAAG,GAAG,OAAO,GAAG,EAAE;AAAA,IAC9C;AAAA,IACA,CAAC;AAAA,EACH;AACA;AAAA,IACE;AAAA,IACA,MAAM,KAAK,MAAM,CAAC,QAAQ,OAAO,YAAY;AAAA,IAC7C;AAAA,EACF;AACA,SAAO;AACT;AAWA,SAAS,gBAAgB,OAAoD;AAC3E,SAAO,OAAO,UAAU,YAAY,UAAU,QAAQ,UAAU;AAClE;AASA,SAAS,2BACP,+BAGwB;AACxB,MAAI,OAAO,kCAAkC,UAAU;AACrD,WAAO;AAAA,EACT;AACA,SAAO,8BAA8B;AACvC;AAUA,SAAS,8BACJ,MAMoB;AACvB,MAAI,KAAK,WAAW,GAAG;AACrB,WAAO,KAAK,CAAC;AAAA,EACf;AACA,QAAM,CAAC,EAAE,IAAI,OAAO,GAAG,qBAAqB,IAAI;AAChD,MAAI,OAAO,QAAW;AACpB,UAAM,+BAA+B,OAAO;AAAA,MAC1C;AAAA,IACF,EAAE,KAAK,CAAC,yBAAyB;AAC/B,aAAO,qBAAqB,WAAW,OAAO,YAAY;AAAA,IAC5D,CAAC;AACD,QAAI,8BAA8B;AAChC,aAAO,6BAA6B;AAAA,IACtC;AACA,WAAO,OAAO,YAAY;AAAA,EAC5B;AACA,SAAO;AACT;AASA,SAAS,uBACP,gBACgE;AAChE,SAAO,oBAAoB,eAAe,IAAI;AAChD;AASA,SAAS,uBACP,gBACqE;AACrE,SAAO,eAAe,SAAS,YAAY;AAC7C;AAiBA,SAAS,6BACP,gBACsE;AACtE,MAAI,eAAe,YAAY,QAAW;AACxC,UAAM,IAAI,MAAM,mDAAmD;AAAA,EACrE;AACA,MAAI,eAAe,WAAW,QAAW;AACvC,UAAM,IAAI,MAAM,kDAAkD;AAAA,EACpE;AACF;AAsCA,IAAM,OAAO;AA4JN,IAAM,eAA6B;AAAA,EACxC,yBAAyB,YAAY;AAAA,EACrC,gBAAgB;AAAA,IACd,MAAM,YAAY;AAAA,IAClB,SAAS,QAAQ;AAAA,IACjB,QAAQ,eAAe;AAAA,EACzB;AAAA,EACA,kBAAkB,CAAC;AAAA,EACnB,uBAAuB,CAAC;AAC1B;AApfA;AAiiBO,IAAM,oBAAN,cAAgC,eAIrC;AAAA,EAeA,YAAY;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAA6B;AAC3B,UAAM;AAAA,MACJ;AAAA,MACA,UAAU;AAAA,QACR,yBAAyB;AAAA,UACvB,SAAS;AAAA,UACT,WAAW;AAAA,QACb;AAAA,QACA,kBAAkB;AAAA,UAChB,SAAS;AAAA,UACT,WAAW;AAAA,QACb;AAAA,QACA,gBAAgB;AAAA,UACd,SAAS;AAAA,UACT,WAAW;AAAA,QACb;AAAA,QACA,uBAAuB;AAAA,UACrB,SAAS;AAAA,UACT,WAAW;AAAA,QACb;AAAA,MACF;AAAA,MACA;AAAA,MACA,OAAO,EAAE,GAAG,cAAc,GAAG,MAAM;AAAA,IACrC,CAAC;AAoLH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AA4RN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AAqUN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA4BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAuCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA4CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AApjCA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AA+BE,QAAI,CAAC,mBAAmB,OAAO,oBAAoB,UAAU;AAC3D,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC7C;AACA,uBAAK,kBAAmB;AACxB,uBAAK,wBAAyB;AAC9B,SAAK,gBAAgB;AAAA,MACnB,GAAG,KAAK,IAAI;AAAA,MACZ,MAAM;AACJ,eAAO,KAAK,MAAM;AAAA,MACpB;AAAA,IACF;AAEA,SAAK,gBAAgB;AAAA,MACnB,GAAG,KAAK,IAAI;AAAA,MACZ,MAAM;AACJ,eAAO,mBAAK;AAAA,MACd;AAAA,IACF;AAEA,SAAK,gBAAgB;AAAA,MACnB,GAAG,KAAK,IAAI;AAAA,MACZ,KAAK,qBAAqB,KAAK,IAAI;AAAA,IACrC;AAEA,SAAK,gBAAgB;AAAA,MACnB,GAAG,KAAK,IAAI;AAAA,MACZ,KAAK,wBAAwB,KAAK,IAAI;AAAA,IACxC;AAEA,SAAK,gBAAgB;AAAA,MACnB,GAAG,KAAK,IAAI;AAAA,MACZ,KAAK,iBAAiB,KAAK,IAAI;AAAA,IACjC;AAEA,SAAK,gBAAgB;AAAA,MACnB,GAAG,KAAK,IAAI;AAAA,MACZ,KAAK,gBAAgB,KAAK,IAAI;AAAA,IAChC;AAEA,SAAK,gBAAgB;AAAA,MACnB,GAAG,KAAK,IAAI;AAAA,MACZ,KAAK,6BAA6B,KAAK,IAAI;AAAA,IAC7C;AAEA,SAAK,gBAAgB;AAAA,MACnB,GAAG,KAAK,IAAI;AAAA,MACZ,KAAK,yCAAyC,KAAK,IAAI;AAAA,IACzD;AAEA,SAAK,gBAAgB;AAAA,MACnB,GAAG,KAAK,IAAI;AAAA,MACZ,KAAK,yBAAyB,KAAK,IAAI;AAAA,IACzC;AAEA,uBAAK,yBAA0B,KAAK,MAAM;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,6BAKE;AACA,WAAO;AAAA,MACL,UAAU,mBAAK;AAAA,MACf,cAAc,mBAAK;AAAA,IACrB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,2BAKc;AACZ,QAAI,mBAAK,mBAAkB,mBAAK,qBAAoB;AAClD,aAAO;AAAA,QACL,UAAU,mBAAK;AAAA,QACf,cAAc,mBAAK;AAAA,MACrB;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,2BACyC;AACvC,UAAM,mCACJ,sBAAK,sGAAL;AAEF,WAAO,OAAO;AAAA,MACZ,CAAC;AAAA,MACD,sDAAyD;AAAA,MACzD,sDAAyD;AAAA,IAC3D;AAAA,EACF;AAAA,EAwBA,qBACE,iBACsD;AACtD,QAAI,CAAC,iBAAiB;AACpB,YAAM,IAAI,MAAM,oCAAoC;AAAA,IACtD;AAEA,UAAM,mCACJ,sBAAK,sGAAL;AAEF,QAAI,oBAAoB,eAAe,GAAG;AACxC,YAAM,sBACJ,sDAAyD,EACvD,eACF;AACF,UAAI,CAAC,qBAAqB;AACxB,cAAM,IAAI;AAAA,UACR,mDAAmD,eAAe;AAAA,QACpE;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAEA,UAAM,sBACJ,sDAAyD,EACvD,eACF;AACF,QAAI,CAAC,qBAAqB;AACxB,YAAM,IAAI;AAAA,QACR,mDAAmD,eAAe;AAAA,MACpE;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EA2BA,MAAM,qBAAqB;AACzB,0BAAK,sGAAL;AAEA,0BAAK,kDAAL;AAAA,EAGF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,wBAAwB,iBAAkC;AAC9D,UAAM,WAAW,oBAAoB,eAAe;AACpD,QAAI;AACJ,QAAI;AAEJ,QAAI;AACF,mCAA6B,MAAM,sBAAK,kEAAL,WACjC;AAEF;AAAA,IACF,SAAS,OAAO;AACd,UAAI,gBAAgB,KAAK,GAAG;AAC1B,YAAI;AACJ,YACE,YACA,YAAY,OAAO,SAAS,KAC5B,OAAO,MAAM,YAAY,UACzB;AACA,cAAI;AACF,2BAAe,KAAK,MAAM,MAAM,OAAO;AAAA,UACzC,QAAQ;AAAA,UAER;AAAA,QACF;AAEA,YACE,cAAc,YAAY,KAC1B,aAAa,UAAU,oBACvB;AACA;AAAA,QACF,WAAW,MAAM,SAAS,WAAW,IAAI,UAAU;AACjD;AAAA,QACF,OAAO;AACL;AAAA,QACF;AAAA,MACF,WACE,OAAO,UAAU,eACjB,YAAY,OAA2B,SAAS,KAChD,OAAQ,MAA2B,YAAY,YAC9C,MAA2B,QAAQ;AAAA,QAClC;AAAA,MACF,GACA;AACA,cAAM;AAAA,MACR,OAAO;AACL,YAAI,0DAA0D,KAAK;AACnE;AAAA,MACF;AAAA,IACF;AACA,SAAK,OAAO,CAAC,UAAU;AACrB,UAAI,MAAM,iBAAiB,eAAe,MAAM,QAAW;AACzD,cAAM,iBAAiB,eAAe,IAAI;AAAA,UACxC;AAAA,UACA,MAAM,CAAC;AAAA,QACT;AAAA,MACF;AACA,YAAM,OAAO,MAAM,iBAAiB,eAAe;AACnD,WAAK,SAAS;AACd,UAAI,+BAA+B,QAAW;AAC5C,eAAO,KAAK,KAAK,IAAI;AAAA,MACvB,OAAO;AACL,aAAK,KAAK,IAAI,IAAI;AAAA,MACpB;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,MAAM,cAAc,iBAAmC;AACrD,QAAI,iBAAiB;AACnB,YAAM,KAAK,wBAAwB,eAAe;AAClD;AAAA,IACF;AAEA,QAAI,CAAC,mBAAK,YAAW;AACnB;AAAA,IACF;AAEA,UAAM,WAAW,uBAAuB,KAAK,MAAM,cAAc;AAEjE,QAAI,iBAAiB;AACrB,UAAM,WAAW,MAAM;AACrB,uBAAiB;AACjB,WAAK,gBAAgB;AAAA,QACnB;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,SAAK,gBAAgB;AAAA,MACnB;AAAA,MACA;AAAA,IACF;AAEA,QAAI;AACJ,QAAI;AAEJ,QAAI;AACF,YAAM,sBAAsB,MAAM,sBAAK,kEAAL,WAChC,KAAK,MAAM;AAEb;AACA,mCAA6B;AAAA,IAC/B,SAAS,OAAO;AACd,UAAI,gBAAgB,KAAK,GAAG;AAC1B,YAAI;AACJ,YACE,YACA,YAAY,OAAO,SAAS,KAC5B,OAAO,MAAM,YAAY,UACzB;AACA,cAAI;AACF,2BAAe,KAAK,MAAM,MAAM,OAAO;AAAA,UACzC,QAAQ;AAAA,UAER;AAAA,QACF;AAEA,YACE,cAAc,YAAY,KAC1B,aAAa,UAAU,oBACvB;AACA;AAAA,QACF,WAAW,MAAM,SAAS,WAAW,IAAI,UAAU;AACjD;AAAA,QACF,OAAO;AACL;AAAA,QACF;AAAA,MACF,OAAO;AACL,YAAI,0DAA0D,KAAK;AACnE;AAAA,MACF;AAAA,IACF;AAEA,QAAI,gBAAgB;AAGlB;AAAA,IACF;AACA,SAAK,gBAAgB;AAAA,MACnB;AAAA,MACA;AAAA,IACF;AAEA,SAAK,OAAO,CAAC,UAAU;AACrB,YAAM,OAAO,MAAM,iBAAiB,MAAM,uBAAuB;AACjE,WAAK,SAAS;AACd,UAAI,+BAA+B,QAAW;AAC5C,eAAO,KAAK,KAAK,IAAI;AAAA,MACvB,OAAO;AACL,aAAK,KAAK,IAAI,IAAI;AAAA,MACpB;AAAA,IACF,CAAC;AAED,QAAI,UAAU;AACZ,UAAI,sDAAkD;AACpD,aAAK,gBAAgB,QAAQ,qCAAqC;AAAA,MACpE,WAAW,kDAAgD;AACzD,aAAK,gBAAgB,QAAQ,mCAAmC;AAAA,MAClE;AAAA,IACF,OAAO;AAIL,WAAK,gBAAgB,QAAQ,qCAAqC;AAAA,IACpE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,gBAAgB,MAAyB;AAC7C,WAAO;AAAA,MACL;AAAA,MACA,YAAY;AAAA,MACZ,gEAAgE,YAAY,GAAG;AAAA,IACjF;AACA,WAAO;AAAA,MACL,oBAAoB,IAAI;AAAA,MACxB,iCAAiC,IAAI;AAAA,IACvC;AAEA,UAAM,KAAK,iBAAiB,IAAI;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,iBAAiB,8BAAsC;AAC3D,uBAAK,yBAA0B,KAAK,MAAM;AAE1C,QAAI;AACJ,QAAI,oBAAoB,4BAA4B,GAAG;AACrD,YAAM,SAAS,eAAe,4BAA4B;AAE1D,sBAAgB;AAAA,QACd,SAAS,QAAQ,4BAA4B;AAAA,QAC7C,IAAI;AAAA,QACJ,UAAU,kBAAkB,4BAA4B,EAAE;AAAA,QAC1D,QAAQ;AAAA,QACR,UAAU;AAAA,QACV;AAAA,QACA,MAAM;AAAA,MACR;AAAA,IACF,OAAO;AACL,UACE,CAAC,OAAO,KAAK,KAAK,MAAM,qBAAqB,EAAE;AAAA,QAC7C;AAAA,MACF,GACA;AACA,cAAM,IAAI;AAAA,UACR,0BAA0B,4BAA4B;AAAA,QACxD;AAAA,MACF;AACA,sBAAgB;AAAA,QACd,GAAG,KAAK,MAAM,sBAAsB,4BAA4B;AAAA,QAChE,MAAM,YAAY;AAAA,MACpB;AAAA,IACF;AAEA,0BAAK,sGAAL;AAEA,SAAK,OAAO,CAAC,UAAU;AACrB,YAAM,iBAAiB;AAAA,IACzB,CAAC;AAED,UAAM,sBAAK,oCAAL;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAyCA,MAAM,wBAAwB,iBAAmC;AAC/D,QAAI,iBAAiB;AACnB,aAAO,KAAK,wCAAwC,eAAe;AAAA,IACrE;AACA,QAAI,CAAC,mBAAK,YAAW;AACnB,aAAO;AAAA,IACT;AAEA,UAAM,EAAE,KAAK,IACX,KAAK,MAAM,iBAAiB,KAAK,MAAM,uBAAuB;AAEhE,QAAI,KAAK,IAAI,MAAM,QAAW;AAC5B,aAAO,KAAK,IAAI;AAAA,IAClB;AAEA,UAAM,sBAAsB,MAAM,sBAAK,kEAAL,WAChC,KAAK,MAAM;AAEb,SAAK,OAAO,CAAC,UAAU;AACrB,UAAI,wBAAwB,QAAW;AACrC,cAAM,iBAAiB,MAAM,uBAAuB,EAAE,KAAK,IAAI,IAC7D;AAAA,MACJ;AAAA,IACF,CAAC;AACD,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,wCACJ,iBACA;AACA,QAAI,WAAW,KAAK,MAAM,iBAAiB,eAAe;AAC1D,QAAI,aAAa,QAAW;AAC1B,YAAM,KAAK,cAAc,eAAe;AACxC,iBAAW,KAAK,MAAM,iBAAiB,eAAe;AAAA,IACxD;AACA,UAAM,EAAE,KAAK,IAAI;AAGjB,WAAO,KAAK,IAAI;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EA0BA,MAAM,kBAAkB;AACtB,0BAAK,sGAAL;AACA,UAAM,sBAAK,oCAAL;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,yCACE,iBACkC;AAClC,QAAI,oBAAoB,eAAe,GAAG;AACxC,YAAM,SAAS,WAAW,eAAe,iBACvC,mBAAK,iBACP;AACA,aAAO;AAAA,QACL;AAAA,QACA,GAAG,kBAAkB,eAAe;AAAA,MACtC;AAAA,IACF;AAEA,WAAO,KAAK,MAAM,sBAAsB,eAAe;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA0BA,MAAM,2BAGJ,sBAGA;AAAA,IACE;AAAA,IACA;AAAA,IACA,YAAY;AAAA,EACd,GAKiB;AAGjB,UAAM,gCAEF,KAAK,sBAAsB;AAAA,MAC7B;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AACD,UAAM,EAAE,QAAQ,SAAS,QAAQ,GAAG,IAAI;AAExC,4BAAwB,OAAO;AAC/B,QAAI,CAAC,cAAc,OAAO,GAAG;AAC3B,YAAM,IAAI;AAAA,QACR,qBAAqB,OAAO;AAAA,MAC9B;AAAA,IACF;AACA,QAAI,CAAC,QAAQ;AACX,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,QAAI,CAAC,YAAY,CAAC,QAAQ;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,QAAI;AACF,UAAI,IAAI,MAAM;AAAA,IAGhB,SAAS,GAAQ;AACf,UAAI,EAAE,QAAQ,SAAS,aAAa,GAAG;AACrC,cAAM,IAAI,MAAM,4BAA4B;AAAA,MAC9C;AAAA,IACF;AACA,QAAI,CAAC,QAAQ;AACX,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,UAAM,mCACJ,sBAAK,sGAAL;AAIF,UAAM,qCAAqC,OAAO;AAAA,MAChD,KAAK,MAAM;AAAA,IACb,EAAE,KAAK,CAAC,kBAAkB,cAAc,OAAO,EAAE;AACjD,QAAI,MAAM,CAAC,oCAAoC;AAC7C,YAAM,IAAI,MAAM,kDAAkD;AAAA,IACpE;AAEA,UAAM,yCAAyC,OAAO;AAAA,MACpD,KAAK,MAAM;AAAA,IACb,EAAE;AAAA,MACA,CAAC,kBACC,cAAc,OAAO,YAAY,MAAM,OAAO,YAAY;AAAA,IAC9D;AACA,QACE,MACA,0CACA,uCAAuC,OAAO,IAC9C;AACA,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,UAAM,+BACJ,sCACA;AAEF,UAAM,iCAAiC,+BACnC,6BAA6B,KAC7B,OAAO;AACX,UAAM,kBAAkB;AAAA,MACtB;AAAA,IACF;AAEA,UAAM,8BACJ,sDAAyD;AAC3D,UAAM,mCACJ,4BAA4B,eAAe;AAC7C,UAAM,qCACJ,oCACA,iCAAiC,cAAc,YAAY;AAC7D,QAAI,oCAAoC;AACtC,uCAAiC,QAAQ;AAAA,IAC3C;AACA,QACE,CAAC,oCACD,oCACA;AACA,kCAA4B,eAAe,IACzC,+BAA+B;AAAA,QAC7B;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACL;AAEA,SAAK,OAAO,CAAC,UAAU;AACrB,YAAM,sBAAsB,8BAA8B,IAAI;AAAA;AAAA;AAAA,QAG5D,GAAG;AAAA,QACH,IAAI;AAAA,MACN;AAAA,IACF,CAAC;AAED,QAAI,CAAC,8BAA8B;AACjC,yBAAK,wBAAL,WAA4B;AAAA,QAC1B,OAAO;AAAA,QACP,UAAU;AAAA,QACV,UAAU;AAAA,UACR,KAAK;AAAA,QACP;AAAA,QACA,YAAY;AAAA,UACV,UAAU;AAAA,UACV,QAAQ;AAAA,UACR;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,QAAI,WAAW;AACb,YAAM,KAAK,iBAAiB,8BAA8B;AAAA,IAC5D;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,2BAA2B,wBAAgC;AACzD,QAAI,CAAC,KAAK,MAAM,sBAAsB,sBAAsB,GAAG;AAC7D,YAAM,IAAI;AAAA,QACR,0BAA0B,sBAAsB;AAAA,MAClD;AAAA,IACF;AAEA,UAAM,mCACJ,sBAAK,sGAAL;AACF,UAAM,kBAAkB,2BAA2B,sBAAsB;AAEzE,SAAK,OAAO,CAAC,UAAU;AACrB,aAAO,MAAM,sBAAsB,sBAAsB;AAAA,IAC3D,CAAC;AAED,UAAM,8BACJ,sDAAyD;AAC3D,UAAM,mCACJ,4BAA4B,eAAe;AAC7C,qCAAiC,QAAQ;AACzC,WAAO,4BAA4B,eAAe;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,6BAA6B;AACjC,0BAAK,sGAAL;AAEA,SAAK,OAAO,CAAC,UAAU;AACrB,YAAM,iBAAiB,mBAAK;AAAA,IAC9B,CAAC;AAED,UAAM,sBAAK,oCAAL;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU;AACd,UAAM,mBAAK,qBAAoB,QAAQ;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,WAAW;AAAA,IACT;AAAA,EACF,GAES;AACP,SAAK,OAAO,CAAC,UAAU;AACrB,YAAM,wBAAwB;AAAA,QAC5B,GAAG,MAAM;AAAA,QACT,GAAG;AAAA,MACL;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,6BAA6B,SAA+B;AAC1D,UAAM,iBAAiB,KAAK,yBAAyB;AACrD,UAAM,qBAAqB,OAAO,QAAQ,cAAc,EAAE;AAAA,MACxD,CAAC,CAAC,GAAG,aAAa,MAAM,cAAc,cAAc,YAAY;AAAA,IAClE;AACA,QAAI,uBAAuB,QAAW;AACpC,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAC7D;AACA,WAAO,mBAAmB,CAAC;AAAA,EAC7B;AAoPF;AA3nCE;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAkNM;AAAA,oBAAe,iBAAG;AACtB,OAAK,gBAAgB;AAAA,IACnB;AAAA,IACA,KAAK;AAAA,EACP;AACA,wBAAK,kDAAL;AACA,OAAK,gBAAgB;AAAA,IACnB;AAAA,IACA,KAAK;AAAA,EACP;AACA,QAAM,KAAK,cAAc;AAC3B;AAiRA;AAAA,oBAAe,SAAC,iBAAkD;AAChE,MAAI,oBAAoB,QAAW;AACjC,sBAAkB,KAAK,MAAM;AAAA,EAC/B;AAEA,QAAM,gBAAgB,KAAK,qBAAqB,eAAe;AAC/D,QAAM,WAAW,IAAI,SAAS,cAAc,QAAQ;AAEpD,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,aAAS;AAAA,MACP,EAAE,QAAQ,wBAAwB,QAAQ,CAAC,UAAU,KAAK,EAAE;AAAA,MAC5D,CAAC,OAAgB,UAAoB;AACnC,YAAI,OAAO;AACT,iBAAO,KAAK;AAAA,QACd,OAAO;AAEL,kBAAQ,KAAc;AAAA,QACxB;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH;AA6DM;AAAA,mCAA8B,eAClC,iBAC8B;AAC9B,QAAM,cAAc,MAAM,sBAAK,oCAAL,WAAqB;AAE/C,MAAI,CAAC,aAAa;AAChB,WAAO;AAAA,EACT;AAEA,SAAO,YAAY,kBAAkB;AACvC;AA2TA;AAAA,qDAAgD,WAAqC;AACnF,QAAM,mCACJ,mBAAK,sCACL,sBAAK,oFAAL;AACF,qBAAK,mCAAoC;AACzC,SAAO;AACT;AAQA;AAAA,4CAAuC,WAAqC;AAC1E,SAAO;AAAA,IACL,GAAG,sBAAK,wGAAL;AAAA,IACH,GAAG,sBAAK,wGAAL;AAAA,IACH,GAAG,sBAAK,gIAAL;AAAA,EACL,EAAE;AAAA,IACA,CACE,UACA,CAAC,mBAAmB,iBAAiB,0BAA0B,MAC5D;AACH,YAAM,2BAA2B;AAAA,QAC/B;AAAA,MACF;AACA,UAAI,mBAAmB,SAAS,iBAAiB,GAAG;AAClD,eAAO;AAAA,MACT;AACA,aAAO;AAAA,QACL,GAAG;AAAA,QACH,CAAC,iBAAiB,GAAG;AAAA,UACnB,GAAG,SAAS,iBAAiB;AAAA,UAC7B,CAAC,eAAe,GAAG;AAAA,QACrB;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,sBAAyB,GAAG,CAAC;AAAA,MAC7B,sBAAyB,GAAG,CAAC;AAAA,IAC/B;AAAA,EACF;AACF;AASA;AAAA,sDAAiD,WAI7C;AACF,SAAO,YAAY,iBAAiB,EAAE,IAAI,CAAC,YAAY;AACrD,UAAM,kBAAkB,2BAA2B,OAAO;AAC1D,UAAM,6BAA+D;AAAA,MACnE;AAAA,MACA;AAAA,MACA,iBAAiB,mBAAK;AAAA,MACtB,SAAS,kBAAkB,OAAO,EAAE;AAAA,MACpC,QAAQ,kBAAkB,OAAO,EAAE;AAAA,IACrC;AACA,WAAO;AAAA;AAAA,MAEL;AAAA,MACA;AAAA,IACF;AAAA,EACF,CAAC;AACH;AAQA;AAAA,sDAAiD,WAI7C;AACF,SAAO,OAAO,QAAQ,KAAK,MAAM,qBAAqB,EAAE;AAAA,IACtD,CAAC,CAAC,wBAAwB,oBAAoB,MAAM;AAClD,UAAI,qBAAqB,YAAY,QAAW;AAC9C,cAAM,IAAI,MAAM,mDAAmD;AAAA,MACrE;AACA,UAAI,qBAAqB,WAAW,QAAW;AAC7C,cAAM,IAAI,MAAM,kDAAkD;AAAA,MACpE;AACA,YAAM,kBAAkB;AAAA,QACtB;AAAA,MACF;AACA,YAAM,6BAA+D;AAAA,QACnE;AAAA,QACA,SAAS,qBAAqB;AAAA,QAC9B,QAAQ,qBAAqB;AAAA,QAC7B,QAAQ,qBAAqB;AAAA,MAC/B;AACA,aAAO;AAAA;AAAA,QAEL;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAUA;AAAA,kEAA6D,WAQtD;AACL,QAAM,EAAE,eAAe,IAAI,KAAK;AAEhC,MAAI,uBAAuB,cAAc,GAAG;AAC1C,iCAA6B,cAAc;AAC3C,UAAM,kBAAkB;AAAA,MACtB;AAAA,MACA,KAAK,MAAM;AAAA,IACb;AACA,UAAM,6BAA+D;AAAA,MACnE,SAAS,eAAe;AAAA,MACxB,QAAQ,eAAe;AAAA,MACvB;AAAA,MACA,QAAQ,eAAe;AAAA,IACzB;AACA,WAAO;AAAA,MACL,wBAA2B,iBAAiB,0BAA0B;AAAA,IACxE;AAAA,EACF;AAEA,MAAI,uBAAuB,cAAc,GAAG;AAC1C,WAAO,CAAC;AAAA,EACV;AAEA,QAAM,IAAI,MAAM,+BAA+B,eAAe,IAAI,GAAG;AACvE;AAWA;AAAA,2BAAsB,WAAG;AACvB,MAAI,CAAC,mBAAK,oCAAmC;AAC3C,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,QAAM,EAAE,eAAe,IAAI,KAAK;AAEhC,MAAI;AAEJ,MAAI;AACJ,MAAI,uBAAuB,cAAc,GAAG;AAC1C,UAAM;AACN,sBAAkB,2BAA2B,cAAc;AAC3D,UAAM,+BACJ,mBAAK,mCAAkC,iBAAiB;AAC1D,+BACE,6BAA6B,eAAyC;AACxE,QAAI,CAAC,0BAA0B;AAC7B,YAAM,IAAI;AAAA,QACR,0CAA0C,eAAe;AAAA,MAC3D;AAAA,IACF;AAAA,EACF,WAAW,uBAAuB,cAAc,GAAG;AACjD,iCAA6B,cAAc;AAC3C,UAAM;AACN,sBAAkB;AAAA,MAChB;AAAA,MACA,KAAK,MAAM;AAAA,IACb;AACA,UAAM,8BACJ,mBAAK,mCAAkC,iBAAiB;AAC1D,+BAA2B,4BAA4B,eAAe;AACtE,QAAI,CAAC,0BAA0B;AAC7B,YAAM,IAAI;AAAA,QACR,4CAA4C,eAAe;AAAA,MAC7D;AAAA,IACF;AAAA,EACF,OAAO;AACL,UAAM,IAAI,MAAM,6CAA6C;AAAA,EAC/D;AAEA,OAAK,OAAO,CAAC,UAAU;AACrB,UAAM,0BAA0B;AAChC,QAAI,MAAM,iBAAiB,eAAe,MAAM,QAAW;AACzD,YAAM,iBAAiB,eAAe,IAAI;AAAA,QACxC;AAAA,QACA,MAAM,CAAC;AAAA,MACT;AAAA,IACF;AAAA,EACF,CAAC;AAED,QAAM,EAAE,UAAU,aAAa,IAAI;AAEnC,MAAI,mBAAK,iBAAgB;AACvB,uBAAK,gBAAe,UAAU,QAAQ;AAAA,EACxC,OAAO;AACL,uBAAK,gBAAiB,wBAAwB,QAAQ;AAAA,EACxD;AAEA,MAAI,mBAAK,qBAAoB;AAC3B,uBAAK,oBAAmB,UAAU,YAAY;AAAA,EAChD,OAAO;AACL,uBAAK,oBAAqB,wBAAwB,cAAc;AAAA,MAC9D,aAAa;AAAA,IACf,CAAC;AAAA,EACH;AAEA,qBAAK,WAAY,IAAI,SAAS,mBAAK,eAAc;AACnD;","names":[]}
\ No newline at end of file
diff --git a/dist/chunk-PC5HTMUE.js b/dist/chunk-PC5HTMUE.js
new file mode 100644
index 0000000000000000000000000000000000000000..6ca0ed81d85bf43b4fd53fad67b39acaf0bdc413
--- /dev/null
+++ b/dist/chunk-PC5HTMUE.js
@@ -0,0 +1,1034 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+var _chunkZKNI7MD3js = require('./chunk-ZKNI7MD3.js');
+
+
+var _chunkZV34XXLTjs = require('./chunk-ZV34XXLT.js');
+
+
+
+var _chunkVGYLDDJBjs = require('./chunk-VGYLDDJB.js');
+
+
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/NetworkController.ts
+var _basecontroller = require('@metamask/base-controller');
+
+
+
+
+
+
+
+
+var _controllerutils = require('@metamask/controller-utils');
+var _ethquery = require('@metamask/eth-query'); var _ethquery2 = _interopRequireDefault(_ethquery);
+var _rpcerrors = require('@metamask/rpc-errors');
+var _swappableobjproxy = require('@metamask/swappable-obj-proxy');
+
+
+
+
+var _utils = require('@metamask/utils');
+var _assert = require('assert');
+var _uuid = require('uuid');
+var log = _chunkVGYLDDJBjs.createModuleLogger.call(void 0, _chunkVGYLDDJBjs.projectLogger, "NetworkController");
+function knownKeysOf(object) {
+  return Object.keys(object);
+}
+function assertOfType(value, validate, message) {
+  _assert.strict.ok(validate(value), message);
+}
+function pick(object, keys) {
+  const pickedObject = keys.reduce(
+    (finalObject, key) => {
+      return { ...finalObject, [key]: object[key] };
+    },
+    {}
+  );
+  assertOfType(
+    pickedObject,
+    () => keys.every((key) => key in pickedObject),
+    "The reduce did not produce an object with all of the desired keys."
+  );
+  return pickedObject;
+}
+function isErrorWithCode(error) {
+  return typeof error === "object" && error !== null && "code" in error;
+}
+function buildInfuraNetworkClientId(infuraNetworkOrProviderConfig) {
+  if (typeof infuraNetworkOrProviderConfig === "string") {
+    return infuraNetworkOrProviderConfig;
+  }
+  return infuraNetworkOrProviderConfig.type;
+}
+function buildCustomNetworkClientId(...args) {
+  if (args.length === 1) {
+    return args[0];
+  }
+  const [{ id, rpcUrl }, networkConfigurations] = args;
+  if (id === void 0) {
+    const matchingNetworkConfiguration = Object.values(
+      networkConfigurations
+    ).find((networkConfiguration) => {
+      return networkConfiguration.rpcUrl === rpcUrl.toLowerCase();
+    });
+    if (matchingNetworkConfiguration) {
+      return matchingNetworkConfiguration.id;
+    }
+    return rpcUrl.toLowerCase();
+  }
+  return id;
+}
+function isInfuraProviderConfig(providerConfig) {
+  return _controllerutils.isInfuraNetworkType.call(void 0, providerConfig.type);
+}
+function isCustomProviderConfig(providerConfig) {
+  return providerConfig.type === _controllerutils.NetworkType.rpc;
+}
+function validateCustomProviderConfig(providerConfig) {
+  if (providerConfig.chainId === void 0) {
+    throw new Error("chainId must be provided for custom RPC endpoints");
+  }
+  if (providerConfig.rpcUrl === void 0) {
+    throw new Error("rpcUrl must be provided for custom RPC endpoints");
+  }
+}
+var name = "NetworkController";
+var defaultState = {
+  selectedNetworkClientId: _controllerutils.NetworkType.mainnet,
+  providerConfig: {
+    type: _controllerutils.NetworkType.mainnet,
+    chainId: _controllerutils.ChainId.mainnet,
+    ticker: _controllerutils.NetworksTicker.mainnet
+  },
+  networksMetadata: {},
+  networkConfigurations: {}
+};
+var _ethQuery, _infuraProjectId, _trackMetaMetricsEvent, _previousProviderConfig, _providerProxy, _blockTrackerProxy, _autoManagedNetworkClientRegistry, _refreshNetwork, refreshNetwork_fn, _getLatestBlock, getLatestBlock_fn, _determineEIP1559Compatibility, determineEIP1559Compatibility_fn, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn, _createAutoManagedNetworkClientRegistry, createAutoManagedNetworkClientRegistry_fn, _buildIdentifiedInfuraNetworkClientConfigurations, buildIdentifiedInfuraNetworkClientConfigurations_fn, _buildIdentifiedCustomNetworkClientConfigurations, buildIdentifiedCustomNetworkClientConfigurations_fn, _buildIdentifiedNetworkClientConfigurationsFromProviderConfig, buildIdentifiedNetworkClientConfigurationsFromProviderConfig_fn, _applyNetworkSelection, applyNetworkSelection_fn;
+var NetworkController = class extends _basecontroller.BaseController {
+  constructor({
+    messenger,
+    state,
+    infuraProjectId,
+    trackMetaMetricsEvent
+  }) {
+    super({
+      name,
+      metadata: {
+        selectedNetworkClientId: {
+          persist: true,
+          anonymous: false
+        },
+        networksMetadata: {
+          persist: true,
+          anonymous: false
+        },
+        providerConfig: {
+          persist: true,
+          anonymous: false
+        },
+        networkConfigurations: {
+          persist: true,
+          anonymous: false
+        }
+      },
+      messenger,
+      state: { ...defaultState, ...state }
+    });
+    /**
+     * Executes a series of steps to apply the changes to the provider config:
+     *
+     * 1. Notifies subscribers that the network is about to change.
+     * 2. Looks up a known and preinitialized network client matching the provider
+     * config and re-points the provider and block tracker proxy to it.
+     * 3. Notifies subscribers that the network has changed.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _refreshNetwork);
+    /**
+     * Fetches the latest block for the network.
+     *
+     * @param networkClientId - The networkClientId to fetch the correct provider against which to check the latest block. Defaults to the selectedNetworkClientId.
+     * @returns A promise that either resolves to the block header or null if
+     * there is no latest block, or rejects with an error.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getLatestBlock);
+    /**
+     * Retrieves and checks the latest block from the currently selected
+     * network; if the block has a `baseFeePerGas` property, then we know
+     * that the network supports EIP-1559; otherwise it doesn't.
+     *
+     * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility
+     * @returns A promise that resolves to `true` if the network supports EIP-1559,
+     * `false` otherwise, or `undefined` if unable to retrieve the last block.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _determineEIP1559Compatibility);
+    /**
+     * Before accessing or switching the network, the registry of network clients
+     * needs to be populated. Otherwise, `#applyNetworkSelection` and
+     * `getNetworkClientRegistry` will throw an error. This method checks to see if the
+     * population step has happened yet, and if not, makes it happen.
+     *
+     * @returns The populated network client registry.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _ensureAutoManagedNetworkClientRegistryPopulated);
+    /**
+     * Constructs the registry of network clients based on the set of built-in
+     * networks as well as the custom networks in state.
+     *
+     * @returns The network clients keyed by ID.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _createAutoManagedNetworkClientRegistry);
+    /**
+     * Constructs the list of network clients for built-in networks (that is,
+     * the subset of the networks we know Infura supports that consumers do not
+     * need to explicitly add).
+     *
+     * @returns The network clients.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _buildIdentifiedInfuraNetworkClientConfigurations);
+    /**
+     * Constructs the list of network clients for custom networks (that is, those
+     * which consumers have added via `networkConfigurations`).
+     *
+     * @returns The network clients.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _buildIdentifiedCustomNetworkClientConfigurations);
+    /**
+     * Converts the provider config object in state to a network client
+     * configuration object.
+     *
+     * @returns The network client config.
+     * @throws If the provider config is of type "rpc" and lacks either a
+     * `chainId` or an `rpcUrl`.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _buildIdentifiedNetworkClientConfigurationsFromProviderConfig);
+    /**
+     * Uses the information in the provider config object to look up a known and
+     * preinitialized network client. Once a network client is found, updates the
+     * provider and block tracker proxy to point to those from the network client,
+     * then finally creates an EthQuery that points to the provider proxy.
+     *
+     * @throws If no network client could be found matching the current provider
+     * config.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _applyNetworkSelection);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _ethQuery, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _infuraProjectId, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _trackMetaMetricsEvent, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _previousProviderConfig, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _providerProxy, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _blockTrackerProxy, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _autoManagedNetworkClientRegistry, void 0);
+    if (!infuraProjectId || typeof infuraProjectId !== "string") {
+      throw new Error("Invalid Infura project ID");
+    }
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _infuraProjectId, infuraProjectId);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _trackMetaMetricsEvent, trackMetaMetricsEvent);
+    this.messagingSystem.registerActionHandler(
+      `${this.name}:getProviderConfig`,
+      () => {
+        return this.state.providerConfig;
+      }
+    );
+    this.messagingSystem.registerActionHandler(
+      `${this.name}:getEthQuery`,
+      () => {
+        return _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _ethQuery);
+      }
+    );
+    this.messagingSystem.registerActionHandler(
+      `${this.name}:getNetworkClientById`,
+      this.getNetworkClientById.bind(this)
+    );
+    this.messagingSystem.registerActionHandler(
+      `${this.name}:getEIP1559Compatibility`,
+      this.getEIP1559Compatibility.bind(this)
+    );
+    this.messagingSystem.registerActionHandler(
+      `${this.name}:setActiveNetwork`,
+      this.setActiveNetwork.bind(this)
+    );
+    this.messagingSystem.registerActionHandler(
+      `${this.name}:setProviderType`,
+      this.setProviderType.bind(this)
+    );
+    this.messagingSystem.registerActionHandler(
+      `${this.name}:findNetworkClientIdByChainId`,
+      this.findNetworkClientIdByChainId.bind(this)
+    );
+    this.messagingSystem.registerActionHandler(
+      `${this.name}:getNetworkConfigurationByNetworkClientId`,
+      this.getNetworkConfigurationByNetworkClientId.bind(this)
+    );
+    this.messagingSystem.registerActionHandler(
+      `${this.name}:getSelectedNetworkClient`,
+      this.getSelectedNetworkClient.bind(this)
+    );
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _previousProviderConfig, this.state.providerConfig);
+  }
+  /**
+   * Accesses the provider and block tracker for the currently selected network.
+   * @returns The proxy and block tracker proxies.
+   * @deprecated This method has been replaced by `getSelectedNetworkClient` (which has a more easily used return type) and will be removed in a future release.
+   */
+  getProviderAndBlockTracker() {
+    return {
+      provider: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _providerProxy),
+      blockTracker: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _blockTrackerProxy)
+    };
+  }
+  /**
+   * Accesses the provider and block tracker for the currently selected network.
+   *
+   * @returns an object with the provider and block tracker proxies for the currently selected network.
+   */
+  getSelectedNetworkClient() {
+    if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _providerProxy) && _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _blockTrackerProxy)) {
+      return {
+        provider: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _providerProxy),
+        blockTracker: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _blockTrackerProxy)
+      };
+    }
+    return void 0;
+  }
+  /**
+   * Returns all of the network clients that have been created so far, keyed by
+   * their identifier in the network client registry. This collection represents
+   * not only built-in networks but also any custom networks that consumers have
+   * added.
+   *
+   * @returns The list of known network clients.
+   */
+  getNetworkClientRegistry() {
+    const autoManagedNetworkClientRegistry = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
+    return Object.assign(
+      {},
+      autoManagedNetworkClientRegistry["infura" /* Infura */],
+      autoManagedNetworkClientRegistry["custom" /* Custom */]
+    );
+  }
+  getNetworkClientById(networkClientId) {
+    if (!networkClientId) {
+      throw new Error("No network client ID was provided.");
+    }
+    const autoManagedNetworkClientRegistry = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
+    if (_controllerutils.isInfuraNetworkType.call(void 0, networkClientId)) {
+      const infuraNetworkClient = autoManagedNetworkClientRegistry["infura" /* Infura */][networkClientId];
+      if (!infuraNetworkClient) {
+        throw new Error(
+          `No Infura network client was found with the ID "${networkClientId}".`
+        );
+      }
+      return infuraNetworkClient;
+    }
+    const customNetworkClient = autoManagedNetworkClientRegistry["custom" /* Custom */][networkClientId];
+    if (!customNetworkClient) {
+      throw new Error(
+        `No custom network client was found with the ID "${networkClientId}".`
+      );
+    }
+    return customNetworkClient;
+  }
+  /**
+   * Populates the network clients and establishes the initial network based on
+   * the provider configuration in state.
+   */
+  async initializeProvider() {
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _applyNetworkSelection, applyNetworkSelection_fn).call(this);
+  }
+  /**
+   * Refreshes the network meta with EIP-1559 support and the network status
+   * based on the given network client ID.
+   *
+   * @param networkClientId - The ID of the network client to update.
+   */
+  async lookupNetworkByClientId(networkClientId) {
+    const isInfura = _controllerutils.isInfuraNetworkType.call(void 0, networkClientId);
+    let updatedNetworkStatus;
+    let updatedIsEIP1559Compatible;
+    try {
+      updatedIsEIP1559Compatible = await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _determineEIP1559Compatibility, determineEIP1559Compatibility_fn).call(this, networkClientId);
+      updatedNetworkStatus = "available" /* Available */;
+    } catch (error) {
+      if (isErrorWithCode(error)) {
+        let responseBody;
+        if (isInfura && _utils.hasProperty.call(void 0, error, "message") && typeof error.message === "string") {
+          try {
+            responseBody = JSON.parse(error.message);
+          } catch {
+          }
+        }
+        if (_utils.isPlainObject.call(void 0, responseBody) && responseBody.error === _chunkZKNI7MD3js.INFURA_BLOCKED_KEY) {
+          updatedNetworkStatus = "blocked" /* Blocked */;
+        } else if (error.code === _rpcerrors.errorCodes.rpc.internal) {
+          updatedNetworkStatus = "unknown" /* Unknown */;
+        } else {
+          updatedNetworkStatus = "unavailable" /* Unavailable */;
+        }
+      } else if (typeof Error !== "undefined" && _utils.hasProperty.call(void 0, error, "message") && typeof error.message === "string" && error.message.includes(
+        "No custom network client was found with the ID"
+      )) {
+        throw error;
+      } else {
+        log("NetworkController - could not determine network status", error);
+        updatedNetworkStatus = "unknown" /* Unknown */;
+      }
+    }
+    this.update((state) => {
+      if (state.networksMetadata[networkClientId] === void 0) {
+        state.networksMetadata[networkClientId] = {
+          status: "unknown" /* Unknown */,
+          EIPS: {}
+        };
+      }
+      const meta = state.networksMetadata[networkClientId];
+      meta.status = updatedNetworkStatus;
+      if (updatedIsEIP1559Compatible === void 0) {
+        delete meta.EIPS[1559];
+      } else {
+        meta.EIPS[1559] = updatedIsEIP1559Compatible;
+      }
+    });
+  }
+  /**
+   * Performs side effects after switching to a network. If the network is
+   * available, updates the network state with the network ID of the network and
+   * stores whether the network supports EIP-1559; otherwise clears said
+   * information about the network that may have been previously stored.
+   *
+   * @param networkClientId - (Optional) The ID of the network client to update.
+   * If no ID is provided, uses the currently selected network.
+   * @fires infuraIsBlocked if the network is Infura-supported and is blocking
+   * requests.
+   * @fires infuraIsUnblocked if the network is Infura-supported and is not
+   * blocking requests, or if the network is not Infura-supported.
+   */
+  async lookupNetwork(networkClientId) {
+    if (networkClientId) {
+      await this.lookupNetworkByClientId(networkClientId);
+      return;
+    }
+    if (!_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _ethQuery)) {
+      return;
+    }
+    const isInfura = isInfuraProviderConfig(this.state.providerConfig);
+    let networkChanged = false;
+    const listener = () => {
+      networkChanged = true;
+      this.messagingSystem.unsubscribe(
+        "NetworkController:networkDidChange",
+        listener
+      );
+    };
+    this.messagingSystem.subscribe(
+      "NetworkController:networkDidChange",
+      listener
+    );
+    let updatedNetworkStatus;
+    let updatedIsEIP1559Compatible;
+    try {
+      const isEIP1559Compatible = await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _determineEIP1559Compatibility, determineEIP1559Compatibility_fn).call(this, this.state.selectedNetworkClientId);
+      updatedNetworkStatus = "available" /* Available */;
+      updatedIsEIP1559Compatible = isEIP1559Compatible;
+    } catch (error) {
+      if (isErrorWithCode(error)) {
+        let responseBody;
+        if (isInfura && _utils.hasProperty.call(void 0, error, "message") && typeof error.message === "string") {
+          try {
+            responseBody = JSON.parse(error.message);
+          } catch {
+          }
+        }
+        if (_utils.isPlainObject.call(void 0, responseBody) && responseBody.error === _chunkZKNI7MD3js.INFURA_BLOCKED_KEY) {
+          updatedNetworkStatus = "blocked" /* Blocked */;
+        } else if (error.code === _rpcerrors.errorCodes.rpc.internal) {
+          updatedNetworkStatus = "unknown" /* Unknown */;
+        } else {
+          updatedNetworkStatus = "unavailable" /* Unavailable */;
+        }
+      } else {
+        log("NetworkController - could not determine network status", error);
+        updatedNetworkStatus = "unknown" /* Unknown */;
+      }
+    }
+    if (networkChanged) {
+      return;
+    }
+    this.messagingSystem.unsubscribe(
+      "NetworkController:networkDidChange",
+      listener
+    );
+    this.update((state) => {
+      const meta = state.networksMetadata[state.selectedNetworkClientId];
+      meta.status = updatedNetworkStatus;
+      if (updatedIsEIP1559Compatible === void 0) {
+        delete meta.EIPS[1559];
+      } else {
+        meta.EIPS[1559] = updatedIsEIP1559Compatible;
+      }
+    });
+    if (isInfura) {
+      if (updatedNetworkStatus === "available" /* Available */) {
+        this.messagingSystem.publish("NetworkController:infuraIsUnblocked");
+      } else if (updatedNetworkStatus === "blocked" /* Blocked */) {
+        this.messagingSystem.publish("NetworkController:infuraIsBlocked");
+      }
+    } else {
+      this.messagingSystem.publish("NetworkController:infuraIsUnblocked");
+    }
+  }
+  /**
+   * Convenience method to update provider network type settings.
+   *
+   * @param type - Human readable network name.
+   * @deprecated This has been replaced by `setActiveNetwork`, and will be
+   * removed in a future release
+   */
+  async setProviderType(type) {
+    _assert.strict.notStrictEqual(
+      type,
+      _controllerutils.NetworkType.rpc,
+      `NetworkController - cannot call "setProviderType" with type "${_controllerutils.NetworkType.rpc}". Use "setActiveNetwork"`
+    );
+    _assert.strict.ok(
+      _controllerutils.isInfuraNetworkType.call(void 0, type),
+      `Unknown Infura provider type "${type}".`
+    );
+    await this.setActiveNetwork(type);
+  }
+  /**
+   * Convenience method to update provider RPC settings.
+   *
+   * @param networkConfigurationIdOrType - The unique id for the network configuration to set as the active provider,
+   * or the type of a built-in network.
+   */
+  async setActiveNetwork(networkConfigurationIdOrType) {
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _previousProviderConfig, this.state.providerConfig);
+    let targetNetwork;
+    if (_controllerutils.isInfuraNetworkType.call(void 0, networkConfigurationIdOrType)) {
+      const ticker = _controllerutils.NetworksTicker[networkConfigurationIdOrType];
+      targetNetwork = {
+        chainId: _controllerutils.ChainId[networkConfigurationIdOrType],
+        id: void 0,
+        rpcPrefs: _controllerutils.BUILT_IN_NETWORKS[networkConfigurationIdOrType].rpcPrefs,
+        rpcUrl: void 0,
+        nickname: void 0,
+        ticker,
+        type: networkConfigurationIdOrType
+      };
+    } else {
+      if (!Object.keys(this.state.networkConfigurations).includes(
+        networkConfigurationIdOrType
+      )) {
+        throw new Error(
+          `networkConfigurationId ${networkConfigurationIdOrType} does not match a configured networkConfiguration or built-in network type`
+        );
+      }
+      targetNetwork = {
+        ...this.state.networkConfigurations[networkConfigurationIdOrType],
+        type: _controllerutils.NetworkType.rpc
+      };
+    }
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
+    this.update((state) => {
+      state.providerConfig = targetNetwork;
+    });
+    await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _refreshNetwork, refreshNetwork_fn).call(this);
+  }
+  /**
+   * Determines whether the network supports EIP-1559 by checking whether the
+   * latest block has a `baseFeePerGas` property, then updates state
+   * appropriately.
+   *
+   * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility.
+   * @returns A promise that resolves to true if the network supports EIP-1559
+   * , false otherwise, or `undefined` if unable to determine the compatibility.
+   */
+  async getEIP1559Compatibility(networkClientId) {
+    if (networkClientId) {
+      return this.get1559CompatibilityWithNetworkClientId(networkClientId);
+    }
+    if (!_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _ethQuery)) {
+      return false;
+    }
+    const { EIPS } = this.state.networksMetadata[this.state.selectedNetworkClientId];
+    if (EIPS[1559] !== void 0) {
+      return EIPS[1559];
+    }
+    const isEIP1559Compatible = await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _determineEIP1559Compatibility, determineEIP1559Compatibility_fn).call(this, this.state.selectedNetworkClientId);
+    this.update((state) => {
+      if (isEIP1559Compatible !== void 0) {
+        state.networksMetadata[state.selectedNetworkClientId].EIPS[1559] = isEIP1559Compatible;
+      }
+    });
+    return isEIP1559Compatible;
+  }
+  async get1559CompatibilityWithNetworkClientId(networkClientId) {
+    let metadata = this.state.networksMetadata[networkClientId];
+    if (metadata === void 0) {
+      await this.lookupNetwork(networkClientId);
+      metadata = this.state.networksMetadata[networkClientId];
+    }
+    const { EIPS } = metadata;
+    return EIPS[1559];
+  }
+  /**
+   * Re-initializes the provider and block tracker for the current network.
+   */
+  async resetConnection() {
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
+    await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _refreshNetwork, refreshNetwork_fn).call(this);
+  }
+  /**
+   * Returns a configuration object for the network identified by the given
+   * network client ID. If given an Infura network type, constructs one based on
+   * what we know about the network; otherwise attempts locates a network
+   * configuration in state that corresponds to the network client ID.
+   *
+   * @param networkClientId - The network client ID.
+   * @returns The configuration for the referenced network if one exists, or
+   * undefined otherwise.
+   */
+  getNetworkConfigurationByNetworkClientId(networkClientId) {
+    if (_controllerutils.isInfuraNetworkType.call(void 0, networkClientId)) {
+      const rpcUrl = `https://${networkClientId}.infura.io/v3/${_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _infuraProjectId)}`;
+      return {
+        rpcUrl,
+        ..._controllerutils.BUILT_IN_NETWORKS[networkClientId]
+      };
+    }
+    return this.state.networkConfigurations[networkClientId];
+  }
+  /**
+   * Adds a new custom network or updates the information for an existing
+   * network.
+   *
+   * This may involve updating the `networkConfigurations` property in
+   * state as well and/or adding a new network client to the network client
+   * registry. The `rpcUrl` and `chainId` of the given object are used to
+   * determine which action to take:
+   *
+   * - If the `rpcUrl` corresponds to an existing network configuration
+   * (case-insensitively), then it is overwritten with the object. Furthermore,
+   * if the `chainId` is different from the existing network configuration, then
+   * the existing network client is replaced with a new one.
+   * - If the `rpcUrl` does not correspond to an existing network configuration
+   * (case-insensitively), then the object is used to add a new network
+   * configuration along with a new network client.
+   *
+   * @param networkConfiguration - The network configuration to add or update.
+   * @param options - Additional configuration options.
+   * @param options.referrer - Used to create a metrics event; the site from which the call originated, or 'metamask' for internal calls.
+   * @param options.source - Used to create a metrics event; where the event originated (i.e. from a dapp or from the network form).
+   * @param options.setActive - If true, switches to the network upon adding or updating it (default: false).
+   * @returns The ID for the added or updated network configuration.
+   */
+  async upsertNetworkConfiguration(networkConfiguration, {
+    referrer,
+    source,
+    setActive = false
+  }) {
+    const sanitizedNetworkConfiguration = pick(networkConfiguration, [
+      "rpcUrl",
+      "chainId",
+      "ticker",
+      "nickname",
+      "rpcPrefs",
+      "id"
+    ]);
+    const { rpcUrl, chainId, ticker, id } = sanitizedNetworkConfiguration;
+    _utils.assertIsStrictHexString.call(void 0, chainId);
+    if (!_controllerutils.isSafeChainId.call(void 0, chainId)) {
+      throw new Error(
+        `Invalid chain ID "${chainId}": numerical value greater than max safe value.`
+      );
+    }
+    if (!rpcUrl) {
+      throw new Error(
+        "An rpcUrl is required to add or update network configuration"
+      );
+    }
+    if (!referrer || !source) {
+      throw new Error(
+        "referrer and source are required arguments for adding or updating a network configuration"
+      );
+    }
+    try {
+      new URL(rpcUrl);
+    } catch (e) {
+      if (e.message.includes("Invalid URL")) {
+        throw new Error("rpcUrl must be a valid URL");
+      }
+    }
+    if (!ticker) {
+      throw new Error(
+        "A ticker is required to add or update networkConfiguration"
+      );
+    }
+    const autoManagedNetworkClientRegistry = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
+    const existingNetworkConfigurationWithId = Object.values(
+      this.state.networkConfigurations
+    ).find((networkConfig) => networkConfig.id === id);
+    if (id && !existingNetworkConfigurationWithId) {
+      throw new Error("No network configuration matches the provided id");
+    }
+    const existingNetworkConfigurationWithRpcUrl = Object.values(
+      this.state.networkConfigurations
+    ).find(
+      (networkConfig) => networkConfig.rpcUrl.toLowerCase() === rpcUrl.toLowerCase()
+    );
+    if (id && existingNetworkConfigurationWithRpcUrl && existingNetworkConfigurationWithRpcUrl.id !== id) {
+      throw new Error(
+        "A different network configuration already exists with the provided rpcUrl"
+      );
+    }
+    const existingNetworkConfiguration = existingNetworkConfigurationWithId ?? existingNetworkConfigurationWithRpcUrl;
+    const upsertedNetworkConfigurationId = existingNetworkConfiguration ? existingNetworkConfiguration.id : _uuid.v4.call(void 0, );
+    const networkClientId = buildCustomNetworkClientId(
+      upsertedNetworkConfigurationId
+    );
+    const customNetworkClientRegistry = autoManagedNetworkClientRegistry["custom" /* Custom */];
+    const existingAutoManagedNetworkClient = customNetworkClientRegistry[networkClientId];
+    const shouldDestroyExistingNetworkClient = existingAutoManagedNetworkClient && existingAutoManagedNetworkClient.configuration.chainId !== chainId;
+    if (shouldDestroyExistingNetworkClient) {
+      existingAutoManagedNetworkClient.destroy();
+    }
+    if (!existingAutoManagedNetworkClient || shouldDestroyExistingNetworkClient) {
+      customNetworkClientRegistry[networkClientId] = _chunkZV34XXLTjs.createAutoManagedNetworkClient.call(void 0, {
+        type: "custom" /* Custom */,
+        chainId,
+        rpcUrl,
+        ticker
+      });
+    }
+    this.update((state) => {
+      state.networkConfigurations[upsertedNetworkConfigurationId] = {
+        // Core PR: https://github.com/MetaMask/core/pull/4614
+        // Core Patch Branch: jl/network-controller@19.0.0-patch
+        ...sanitizedNetworkConfiguration,
+        id: upsertedNetworkConfigurationId
+      };
+    });
+    if (!existingNetworkConfiguration) {
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _trackMetaMetricsEvent).call(this, {
+        event: "Custom Network Added",
+        category: "Network",
+        referrer: {
+          url: referrer
+        },
+        properties: {
+          chain_id: chainId,
+          symbol: ticker,
+          source
+        }
+      });
+    }
+    if (setActive) {
+      await this.setActiveNetwork(upsertedNetworkConfigurationId);
+    }
+    return upsertedNetworkConfigurationId;
+  }
+  /**
+   * Removes a custom network from state.
+   *
+   * This involves updating the `networkConfigurations` property in state as
+   * well and removing the network client that corresponds to the network from
+   * the client registry.
+   *
+   * @param networkConfigurationId - The ID of an existing network
+   * configuration.
+   */
+  removeNetworkConfiguration(networkConfigurationId) {
+    if (!this.state.networkConfigurations[networkConfigurationId]) {
+      throw new Error(
+        `networkConfigurationId ${networkConfigurationId} does not match a configured networkConfiguration`
+      );
+    }
+    const autoManagedNetworkClientRegistry = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
+    const networkClientId = buildCustomNetworkClientId(networkConfigurationId);
+    this.update((state) => {
+      delete state.networkConfigurations[networkConfigurationId];
+    });
+    const customNetworkClientRegistry = autoManagedNetworkClientRegistry["custom" /* Custom */];
+    const existingAutoManagedNetworkClient = customNetworkClientRegistry[networkClientId];
+    existingAutoManagedNetworkClient.destroy();
+    delete customNetworkClientRegistry[networkClientId];
+  }
+  /**
+   * Switches to the previously selected network, assuming that there is one
+   * (if not and `initializeProvider` has not been previously called, then this
+   * method is equivalent to calling `resetConnection`).
+   */
+  async rollbackToPreviousProvider() {
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
+    this.update((state) => {
+      state.providerConfig = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _previousProviderConfig);
+    });
+    await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _refreshNetwork, refreshNetwork_fn).call(this);
+  }
+  /**
+   * Deactivates the controller, stopping any ongoing polling.
+   *
+   * In-progress requests will not be aborted.
+   */
+  async destroy() {
+    await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _blockTrackerProxy)?.destroy();
+  }
+  /**
+   * Updates the controller using the given backup data.
+   *
+   * @param backup - The data that has been backed up.
+   * @param backup.networkConfigurations - Network configurations in the backup.
+   */
+  loadBackup({
+    networkConfigurations
+  }) {
+    this.update((state) => {
+      state.networkConfigurations = {
+        ...state.networkConfigurations,
+        ...networkConfigurations
+      };
+    });
+  }
+  /**
+   * Searches for a network configuration ID with the given ChainID and returns it.
+   *
+   * @param chainId - ChainId to search for
+   * @returns networkClientId of the network configuration with the given chainId
+   */
+  findNetworkClientIdByChainId(chainId) {
+    const networkClients = this.getNetworkClientRegistry();
+    const networkClientEntry = Object.entries(networkClients).find(
+      ([_, networkClient]) => networkClient.configuration.chainId === chainId
+    );
+    if (networkClientEntry === void 0) {
+      throw new Error("Couldn't find networkClientId for chainId");
+    }
+    return networkClientEntry[0];
+  }
+};
+_ethQuery = new WeakMap();
+_infuraProjectId = new WeakMap();
+_trackMetaMetricsEvent = new WeakMap();
+_previousProviderConfig = new WeakMap();
+_providerProxy = new WeakMap();
+_blockTrackerProxy = new WeakMap();
+_autoManagedNetworkClientRegistry = new WeakMap();
+_refreshNetwork = new WeakSet();
+refreshNetwork_fn = async function() {
+  this.messagingSystem.publish(
+    "NetworkController:networkWillChange",
+    this.state
+  );
+  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _applyNetworkSelection, applyNetworkSelection_fn).call(this);
+  this.messagingSystem.publish(
+    "NetworkController:networkDidChange",
+    this.state
+  );
+  await this.lookupNetwork();
+};
+_getLatestBlock = new WeakSet();
+getLatestBlock_fn = function(networkClientId) {
+  if (networkClientId === void 0) {
+    networkClientId = this.state.selectedNetworkClientId;
+  }
+  const networkClient = this.getNetworkClientById(networkClientId);
+  const ethQuery = new (0, _ethquery2.default)(networkClient.provider);
+  return new Promise((resolve, reject) => {
+    ethQuery.sendAsync(
+      { method: "eth_getBlockByNumber", params: ["latest", false] },
+      (error, block) => {
+        if (error) {
+          reject(error);
+        } else {
+          resolve(block);
+        }
+      }
+    );
+  });
+};
+_determineEIP1559Compatibility = new WeakSet();
+determineEIP1559Compatibility_fn = async function(networkClientId) {
+  const latestBlock = await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getLatestBlock, getLatestBlock_fn).call(this, networkClientId);
+  if (!latestBlock) {
+    return void 0;
+  }
+  return latestBlock.baseFeePerGas !== void 0;
+};
+_ensureAutoManagedNetworkClientRegistryPopulated = new WeakSet();
+ensureAutoManagedNetworkClientRegistryPopulated_fn = function() {
+  const autoManagedNetworkClientRegistry = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _autoManagedNetworkClientRegistry) ?? _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createAutoManagedNetworkClientRegistry, createAutoManagedNetworkClientRegistry_fn).call(this);
+  _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _autoManagedNetworkClientRegistry, autoManagedNetworkClientRegistry);
+  return autoManagedNetworkClientRegistry;
+};
+_createAutoManagedNetworkClientRegistry = new WeakSet();
+createAutoManagedNetworkClientRegistry_fn = function() {
+  return [
+    ..._chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _buildIdentifiedInfuraNetworkClientConfigurations, buildIdentifiedInfuraNetworkClientConfigurations_fn).call(this),
+    ..._chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _buildIdentifiedCustomNetworkClientConfigurations, buildIdentifiedCustomNetworkClientConfigurations_fn).call(this),
+    ..._chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _buildIdentifiedNetworkClientConfigurationsFromProviderConfig, buildIdentifiedNetworkClientConfigurationsFromProviderConfig_fn).call(this)
+  ].reduce(
+    (registry, [networkClientType, networkClientId, networkClientConfiguration]) => {
+      const autoManagedNetworkClient = _chunkZV34XXLTjs.createAutoManagedNetworkClient.call(void 0, 
+        networkClientConfiguration
+      );
+      if (networkClientId in registry[networkClientType]) {
+        return registry;
+      }
+      return {
+        ...registry,
+        [networkClientType]: {
+          ...registry[networkClientType],
+          [networkClientId]: autoManagedNetworkClient
+        }
+      };
+    },
+    {
+      ["infura" /* Infura */]: {},
+      ["custom" /* Custom */]: {}
+    }
+  );
+};
+_buildIdentifiedInfuraNetworkClientConfigurations = new WeakSet();
+buildIdentifiedInfuraNetworkClientConfigurations_fn = function() {
+  return knownKeysOf(_controllerutils.InfuraNetworkType).map((network) => {
+    const networkClientId = buildInfuraNetworkClientId(network);
+    const networkClientConfiguration = {
+      type: "infura" /* Infura */,
+      network,
+      infuraProjectId: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _infuraProjectId),
+      chainId: _controllerutils.BUILT_IN_NETWORKS[network].chainId,
+      ticker: _controllerutils.BUILT_IN_NETWORKS[network].ticker
+    };
+    return [
+      "infura" /* Infura */,
+      networkClientId,
+      networkClientConfiguration
+    ];
+  });
+};
+_buildIdentifiedCustomNetworkClientConfigurations = new WeakSet();
+buildIdentifiedCustomNetworkClientConfigurations_fn = function() {
+  return Object.entries(this.state.networkConfigurations).map(
+    ([networkConfigurationId, networkConfiguration]) => {
+      if (networkConfiguration.chainId === void 0) {
+        throw new Error("chainId must be provided for custom RPC endpoints");
+      }
+      if (networkConfiguration.rpcUrl === void 0) {
+        throw new Error("rpcUrl must be provided for custom RPC endpoints");
+      }
+      const networkClientId = buildCustomNetworkClientId(
+        networkConfigurationId
+      );
+      const networkClientConfiguration = {
+        type: "custom" /* Custom */,
+        chainId: networkConfiguration.chainId,
+        rpcUrl: networkConfiguration.rpcUrl,
+        ticker: networkConfiguration.ticker
+      };
+      return [
+        "custom" /* Custom */,
+        networkClientId,
+        networkClientConfiguration
+      ];
+    }
+  );
+};
+_buildIdentifiedNetworkClientConfigurationsFromProviderConfig = new WeakSet();
+buildIdentifiedNetworkClientConfigurationsFromProviderConfig_fn = function() {
+  const { providerConfig } = this.state;
+  if (isCustomProviderConfig(providerConfig)) {
+    validateCustomProviderConfig(providerConfig);
+    const networkClientId = buildCustomNetworkClientId(
+      providerConfig,
+      this.state.networkConfigurations
+    );
+    const networkClientConfiguration = {
+      chainId: providerConfig.chainId,
+      rpcUrl: providerConfig.rpcUrl,
+      type: "custom" /* Custom */,
+      ticker: providerConfig.ticker
+    };
+    return [
+      ["custom" /* Custom */, networkClientId, networkClientConfiguration]
+    ];
+  }
+  if (isInfuraProviderConfig(providerConfig)) {
+    return [];
+  }
+  throw new Error(`Unrecognized network type: '${providerConfig.type}'`);
+};
+_applyNetworkSelection = new WeakSet();
+applyNetworkSelection_fn = function() {
+  if (!_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _autoManagedNetworkClientRegistry)) {
+    throw new Error(
+      "initializeProvider must be called first in order to switch the network"
+    );
+  }
+  const { providerConfig } = this.state;
+  let autoManagedNetworkClient;
+  let networkClientId;
+  if (isInfuraProviderConfig(providerConfig)) {
+    const networkClientType = "infura" /* Infura */;
+    networkClientId = buildInfuraNetworkClientId(providerConfig);
+    const builtInNetworkClientRegistry = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _autoManagedNetworkClientRegistry)[networkClientType];
+    autoManagedNetworkClient = builtInNetworkClientRegistry[networkClientId];
+    if (!autoManagedNetworkClient) {
+      throw new Error(
+        `Could not find custom network matching ${networkClientId}`
+      );
+    }
+  } else if (isCustomProviderConfig(providerConfig)) {
+    validateCustomProviderConfig(providerConfig);
+    const networkClientType = "custom" /* Custom */;
+    networkClientId = buildCustomNetworkClientId(
+      providerConfig,
+      this.state.networkConfigurations
+    );
+    const customNetworkClientRegistry = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _autoManagedNetworkClientRegistry)[networkClientType];
+    autoManagedNetworkClient = customNetworkClientRegistry[networkClientId];
+    if (!autoManagedNetworkClient) {
+      throw new Error(
+        `Could not find built-in network matching ${networkClientId}`
+      );
+    }
+  } else {
+    throw new Error("Could not determine type of provider config");
+  }
+  this.update((state) => {
+    state.selectedNetworkClientId = networkClientId;
+    if (state.networksMetadata[networkClientId] === void 0) {
+      state.networksMetadata[networkClientId] = {
+        status: "unknown" /* Unknown */,
+        EIPS: {}
+      };
+    }
+  });
+  const { provider, blockTracker } = autoManagedNetworkClient;
+  if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _providerProxy)) {
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _providerProxy).setTarget(provider);
+  } else {
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _providerProxy, _swappableobjproxy.createEventEmitterProxy.call(void 0, provider));
+  }
+  if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _blockTrackerProxy)) {
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _blockTrackerProxy).setTarget(blockTracker);
+  } else {
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _blockTrackerProxy, _swappableobjproxy.createEventEmitterProxy.call(void 0, blockTracker, {
+      eventFilter: "skipInternal"
+    }));
+  }
+  _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _ethQuery, new (0, _ethquery2.default)(_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _providerProxy)));
+};
+
+
+
+
+
+exports.knownKeysOf = knownKeysOf; exports.defaultState = defaultState; exports.NetworkController = NetworkController;
+//# sourceMappingURL=chunk-PC5HTMUE.js.map
\ No newline at end of file
diff --git a/dist/chunk-PC5HTMUE.js.map b/dist/chunk-PC5HTMUE.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..3c973efbd752bd16417255ab4d12b368227dd322
--- /dev/null
+++ b/dist/chunk-PC5HTMUE.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/NetworkController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport {\n  BUILT_IN_NETWORKS,\n  NetworksTicker,\n  ChainId,\n  InfuraNetworkType,\n  NetworkType,\n  isSafeChainId,\n  isInfuraNetworkType,\n} from '@metamask/controller-utils';\nimport EthQuery from '@metamask/eth-query';\nimport { errorCodes } from '@metamask/rpc-errors';\nimport { createEventEmitterProxy } from '@metamask/swappable-obj-proxy';\nimport type { SwappableProxy } from '@metamask/swappable-obj-proxy';\nimport type { Hex } from '@metamask/utils';\nimport {\n  assertIsStrictHexString,\n  hasProperty,\n  isPlainObject,\n} from '@metamask/utils';\nimport { strict as assert } from 'assert';\nimport { v4 as random } from 'uuid';\n\nimport { INFURA_BLOCKED_KEY, NetworkStatus } from './constants';\nimport type {\n  AutoManagedNetworkClient,\n  ProxyWithAccessibleTarget,\n} from './create-auto-managed-network-client';\nimport { createAutoManagedNetworkClient } from './create-auto-managed-network-client';\nimport { projectLogger, createModuleLogger } from './logger';\nimport { NetworkClientType } from './types';\nimport type {\n  BlockTracker,\n  Provider,\n  CustomNetworkClientConfiguration,\n  InfuraNetworkClientConfiguration,\n  NetworkClientConfiguration,\n} from './types';\n\nconst log = createModuleLogger(projectLogger, 'NetworkController');\n\n/**\n * @type ProviderConfig\n *\n * Configuration passed to web3-provider-engine\n * @property rpcUrl - RPC target URL.\n * @property type - Human-readable network name.\n * @property chainId - Network ID as per EIP-155.\n * @property ticker - Currency ticker.\n * @property nickname - Personalized network name.\n * @property id - Network Configuration Id.\n */\nexport type ProviderConfig = {\n  rpcUrl?: string;\n  type: NetworkType;\n  chainId: Hex;\n  ticker: string;\n  nickname?: string;\n  rpcPrefs?: { blockExplorerUrl?: string };\n  id?: NetworkConfigurationId;\n};\n\nexport type Block = {\n  baseFeePerGas?: string;\n};\n\n/**\n * Information about a network not held by any other part of state.\n */\nexport type NetworkMetadata = {\n  /**\n   * EIPs supported by the network.\n   */\n  EIPS: {\n    [eipNumber: number]: boolean;\n  };\n  /**\n   * Indicates the availability of the network\n   */\n  status: NetworkStatus;\n};\n\n/**\n * Custom RPC network information\n *\n * @property rpcUrl - RPC target URL.\n * @property chainId - Network ID as per EIP-155\n * @property nickname - Personalized network name.\n * @property ticker - Currency ticker.\n * @property rpcPrefs - Personalized preferences.\n */\nexport type NetworkConfiguration = {\n  rpcUrl: string;\n  chainId: Hex;\n  ticker: string;\n  nickname?: string;\n  rpcPrefs?: {\n    blockExplorerUrl: string;\n  };\n};\n\n/**\n * The collection of network configurations in state.\n */\ntype NetworkConfigurations = Record<\n  NetworkConfigurationId,\n  NetworkConfiguration & { id: NetworkConfigurationId }\n>;\n\n/**\n * `Object.keys()` is intentionally generic: it returns the keys of an object,\n * but it cannot make guarantees about the contents of that object, so the type\n * of the keys is merely `string[]`. While this is technically accurate, it is\n * also unnecessary if we have an object that we own and whose contents are\n * known exactly.\n *\n * TODO: Move to @metamask/utils.\n *\n * @param object - The object.\n * @returns The keys of an object, typed according to the type of the object\n * itself.\n */\nexport function knownKeysOf<K extends PropertyKey>(\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  object: Partial<Record<K, any>>,\n) {\n  return Object.keys(object) as K[];\n}\n\n/**\n * Asserts that the given value is of the given type if the given validation\n * function returns a truthy result.\n *\n * @param value - The value to validate.\n * @param validate - A function used to validate that the value is of the given\n * type. Takes the `value` as an argument and is expected to return true or\n * false.\n * @param message - The message to throw if the function does not return a\n * truthy result.\n * @throws if the function does not return a truthy result.\n */\nfunction assertOfType<Type>(\n  value: unknown,\n  validate: (value: unknown) => boolean,\n  message: string,\n): asserts value is Type {\n  assert.ok(validate(value), message);\n}\n\n/**\n * Returns a portion of the given object with only the given keys.\n *\n * @param object - An object.\n * @param keys - The keys to pick from the object.\n * @returns the portion of the object.\n */\n// TODO: Replace `any` with type\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction pick<Obj extends Record<any, any>, Keys extends keyof Obj>(\n  object: Obj,\n  keys: Keys[],\n): Pick<Obj, Keys> {\n  const pickedObject = keys.reduce<Partial<Pick<Obj, Keys>>>(\n    (finalObject, key) => {\n      return { ...finalObject, [key]: object[key] };\n    },\n    {},\n  );\n  assertOfType<Pick<Obj, Keys>>(\n    pickedObject,\n    () => keys.every((key) => key in pickedObject),\n    'The reduce did not produce an object with all of the desired keys.',\n  );\n  return pickedObject;\n}\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `code` property, such as an instance of Error.\n *\n * TODO: Move this to @metamask/utils.\n *\n * @param error - The object to check.\n * @returns True if `error` has a `code`, false otherwise.\n */\nfunction isErrorWithCode(error: unknown): error is { code: string | number } {\n  return typeof error === 'object' && error !== null && 'code' in error;\n}\n\n/**\n * Builds an identifier for an Infura network client for lookup purposes.\n *\n * @param infuraNetworkOrProviderConfig - The name of an Infura network or a\n * provider config.\n * @returns The built identifier.\n */\nfunction buildInfuraNetworkClientId(\n  infuraNetworkOrProviderConfig:\n    | InfuraNetworkType\n    | (ProviderConfig & { type: InfuraNetworkType }),\n): BuiltInNetworkClientId {\n  if (typeof infuraNetworkOrProviderConfig === 'string') {\n    return infuraNetworkOrProviderConfig;\n  }\n  return infuraNetworkOrProviderConfig.type;\n}\n\n/**\n * Builds an identifier for a custom network client for lookup purposes.\n *\n * @param args - This function can be called two ways:\n * 1. The ID of a network configuration.\n * 2. A provider config and a set of network configurations.\n * @returns The built identifier.\n */\nfunction buildCustomNetworkClientId(\n  ...args:\n    | [NetworkConfigurationId]\n    | [\n        ProviderConfig & { type: typeof NetworkType.rpc; rpcUrl: string },\n        NetworkConfigurations,\n      ]\n): CustomNetworkClientId {\n  if (args.length === 1) {\n    return args[0];\n  }\n  const [{ id, rpcUrl }, networkConfigurations] = args;\n  if (id === undefined) {\n    const matchingNetworkConfiguration = Object.values(\n      networkConfigurations,\n    ).find((networkConfiguration) => {\n      return networkConfiguration.rpcUrl === rpcUrl.toLowerCase();\n    });\n    if (matchingNetworkConfiguration) {\n      return matchingNetworkConfiguration.id;\n    }\n    return rpcUrl.toLowerCase();\n  }\n  return id;\n}\n\n/**\n * Returns whether the given provider config refers to an Infura network.\n *\n * @param providerConfig - The provider config.\n * @returns True if the provider config refers to an Infura network, false\n * otherwise.\n */\nfunction isInfuraProviderConfig(\n  providerConfig: ProviderConfig,\n): providerConfig is ProviderConfig & { type: InfuraNetworkType } {\n  return isInfuraNetworkType(providerConfig.type);\n}\n\n/**\n * Returns whether the given provider config refers to an Infura network.\n *\n * @param providerConfig - The provider config.\n * @returns True if the provider config refers to an Infura network, false\n * otherwise.\n */\nfunction isCustomProviderConfig(\n  providerConfig: ProviderConfig,\n): providerConfig is ProviderConfig & { type: typeof NetworkType.rpc } {\n  return providerConfig.type === NetworkType.rpc;\n}\n\n/**\n * As a provider config represents the settings that are used to interface with\n * an RPC endpoint, it must have both a chain ID and an RPC URL if it represents\n * a custom network. These properties _should_ be set as they are validated in\n * the UI when a user adds a custom network, but just to be safe we validate\n * them here.\n *\n * In addition, historically the `rpcUrl` property on the ProviderConfig type\n * has been optional, even though it should not be. Making this non-optional\n * would be a breaking change, so this function types the provider config\n * correctly so that we don't have to check `rpcUrl` in other places.\n *\n * @param providerConfig - A provider config.\n * @throws if the provider config does not have a chain ID or an RPC URL.\n */\nfunction validateCustomProviderConfig(\n  providerConfig: ProviderConfig & { type: typeof NetworkType.rpc },\n): asserts providerConfig is typeof providerConfig & { rpcUrl: string } {\n  if (providerConfig.chainId === undefined) {\n    throw new Error('chainId must be provided for custom RPC endpoints');\n  }\n  if (providerConfig.rpcUrl === undefined) {\n    throw new Error('rpcUrl must be provided for custom RPC endpoints');\n  }\n}\n/**\n * The string that uniquely identifies an Infura network client.\n */\nexport type BuiltInNetworkClientId = InfuraNetworkType;\n\n/**\n * The string that uniquely identifies a custom network client.\n */\nexport type CustomNetworkClientId = string;\n\n/**\n * The string that uniquely identifies a network client.\n */\nexport type NetworkClientId = BuiltInNetworkClientId | CustomNetworkClientId;\n\n/**\n * Information about networks not held by any other part of state.\n */\nexport type NetworksMetadata = {\n  [networkClientId: NetworkClientId]: NetworkMetadata;\n};\n\n/**\n * @type NetworkState\n *\n * Network controller state\n * @property providerConfig - RPC URL and network name provider settings of the currently connected network\n * @property properties - an additional set of network properties for the currently connected network\n * @property networkConfigurations - the full list of configured networks either preloaded or added by the user.\n */\nexport type NetworkState = {\n  selectedNetworkClientId: NetworkClientId;\n  providerConfig: ProviderConfig;\n  networkConfigurations: NetworkConfigurations;\n  networksMetadata: NetworksMetadata;\n};\n\nconst name = 'NetworkController';\n\n/**\n * Represents the block tracker for the currently selected network. (Note that\n * this is a proxy around a proxy: the inner one exists so that the block\n * tracker doesn't have to exist until it's used, and the outer one exists so\n * that the currently selected network can change without consumers needing to\n * refresh the object reference to that network.)\n */\nexport type BlockTrackerProxy = SwappableProxy<\n  ProxyWithAccessibleTarget<BlockTracker>\n>;\n\n/**\n * Represents the provider for the currently selected network. (Note that this\n * is a proxy around a proxy: the inner one exists so that the provider doesn't\n * have to exist until it's used, and the outer one exists so that the currently\n * selected network can change without consumers needing to refresh the object\n * reference to that network.)\n */\nexport type ProviderProxy = SwappableProxy<ProxyWithAccessibleTarget<Provider>>;\n\nexport type NetworkControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof name,\n  NetworkState\n>;\n\n/**\n * `networkWillChange` is published when the current network is about to be\n * switched, but the new provider has not been created and no state changes have\n * occurred yet.\n */\nexport type NetworkControllerNetworkWillChangeEvent = {\n  type: 'NetworkController:networkWillChange';\n  payload: [NetworkState];\n};\n\n/**\n * `networkDidChange` is published after a provider has been created for a newly\n * switched network (but before the network has been confirmed to be available).\n */\nexport type NetworkControllerNetworkDidChangeEvent = {\n  type: 'NetworkController:networkDidChange';\n  payload: [NetworkState];\n};\n\n/**\n * `infuraIsBlocked` is published after the network is switched to an Infura\n * network, but when Infura returns an error blocking the user based on their\n * location.\n */\nexport type NetworkControllerInfuraIsBlockedEvent = {\n  type: 'NetworkController:infuraIsBlocked';\n  payload: [];\n};\n\n/**\n * `infuraIsBlocked` is published either after the network is switched to an\n * Infura network and Infura does not return an error blocking the user based on\n * their location, or the network is switched to a non-Infura network.\n */\nexport type NetworkControllerInfuraIsUnblockedEvent = {\n  type: 'NetworkController:infuraIsUnblocked';\n  payload: [];\n};\n\nexport type NetworkControllerEvents =\n  | NetworkControllerStateChangeEvent\n  | NetworkControllerNetworkWillChangeEvent\n  | NetworkControllerNetworkDidChangeEvent\n  | NetworkControllerInfuraIsBlockedEvent\n  | NetworkControllerInfuraIsUnblockedEvent;\n\nexport type NetworkControllerGetStateAction = ControllerGetStateAction<\n  typeof name,\n  NetworkState\n>;\n\nexport type NetworkControllerGetProviderConfigAction = {\n  type: `NetworkController:getProviderConfig`;\n  handler: () => ProviderConfig;\n};\n\nexport type NetworkControllerGetEthQueryAction = {\n  type: `NetworkController:getEthQuery`;\n  handler: () => EthQuery | undefined;\n};\n\nexport type NetworkControllerGetNetworkClientByIdAction = {\n  type: `NetworkController:getNetworkClientById`;\n  handler: NetworkController['getNetworkClientById'];\n};\n\nexport type NetworkControllerGetSelectedNetworkClientAction = {\n  type: `NetworkController:getSelectedNetworkClient`;\n  handler: NetworkController['getSelectedNetworkClient'];\n};\n\nexport type NetworkControllerGetEIP1559CompatibilityAction = {\n  type: `NetworkController:getEIP1559Compatibility`;\n  handler: NetworkController['getEIP1559Compatibility'];\n};\n\nexport type NetworkControllerFindNetworkClientIdByChainIdAction = {\n  type: `NetworkController:findNetworkClientIdByChainId`;\n  handler: NetworkController['findNetworkClientIdByChainId'];\n};\n\n/**\n * Change the currently selected network to the given built-in network type.\n *\n * @deprecated This action has been replaced by `setActiveNetwork`, and will be\n * removed in a future release.\n */\nexport type NetworkControllerSetProviderTypeAction = {\n  type: `NetworkController:setProviderType`;\n  handler: NetworkController['setProviderType'];\n};\n\nexport type NetworkControllerSetActiveNetworkAction = {\n  type: `NetworkController:setActiveNetwork`;\n  handler: NetworkController['setActiveNetwork'];\n};\n\nexport type NetworkControllerGetNetworkConfigurationByNetworkClientId = {\n  type: `NetworkController:getNetworkConfigurationByNetworkClientId`;\n  handler: NetworkController['getNetworkConfigurationByNetworkClientId'];\n};\n\nexport type NetworkControllerActions =\n  | NetworkControllerGetStateAction\n  | NetworkControllerGetProviderConfigAction\n  | NetworkControllerGetEthQueryAction\n  | NetworkControllerGetNetworkClientByIdAction\n  | NetworkControllerGetSelectedNetworkClientAction\n  | NetworkControllerGetEIP1559CompatibilityAction\n  | NetworkControllerFindNetworkClientIdByChainIdAction\n  | NetworkControllerSetActiveNetworkAction\n  | NetworkControllerSetProviderTypeAction\n  | NetworkControllerGetNetworkConfigurationByNetworkClientId;\n\nexport type NetworkControllerMessenger = RestrictedControllerMessenger<\n  typeof name,\n  NetworkControllerActions,\n  NetworkControllerEvents,\n  never,\n  never\n>;\n\nexport type NetworkControllerOptions = {\n  messenger: NetworkControllerMessenger;\n  trackMetaMetricsEvent: () => void;\n  infuraProjectId: string;\n  state?: Partial<NetworkState>;\n};\n\nexport const defaultState: NetworkState = {\n  selectedNetworkClientId: NetworkType.mainnet,\n  providerConfig: {\n    type: NetworkType.mainnet,\n    chainId: ChainId.mainnet,\n    ticker: NetworksTicker.mainnet,\n  },\n  networksMetadata: {},\n  networkConfigurations: {},\n};\n\ntype MetaMetricsEventPayload = {\n  event: string;\n  category: string;\n  referrer?: { url: string };\n  actionId?: number;\n  environmentType?: string;\n  properties?: unknown;\n  sensitiveProperties?: unknown;\n  revenue?: number;\n  currency?: string;\n  value?: number;\n};\n\ntype NetworkConfigurationId = string;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks.\n */\ntype AutoManagedBuiltInNetworkClientRegistry = Record<\n  BuiltInNetworkClientId,\n  AutoManagedNetworkClient<InfuraNetworkClientConfiguration>\n>;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks.\n */\ntype AutoManagedCustomNetworkClientRegistry = Record<\n  CustomNetworkClientId,\n  AutoManagedNetworkClient<CustomNetworkClientConfiguration>\n>;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks\n * as well as custom networks that users have added.\n */\ntype AutoManagedNetworkClientRegistry = {\n  [NetworkClientType.Infura]: AutoManagedBuiltInNetworkClientRegistry;\n  [NetworkClientType.Custom]: AutoManagedCustomNetworkClientRegistry;\n};\n\n/**\n * Controller that creates and manages an Ethereum network provider.\n */\nexport class NetworkController extends BaseController<\n  typeof name,\n  NetworkState,\n  NetworkControllerMessenger\n> {\n  #ethQuery?: EthQuery;\n\n  #infuraProjectId: string;\n\n  #trackMetaMetricsEvent: (event: MetaMetricsEventPayload) => void;\n\n  #previousProviderConfig: ProviderConfig;\n\n  #providerProxy: ProviderProxy | undefined;\n\n  #blockTrackerProxy: BlockTrackerProxy | undefined;\n\n  #autoManagedNetworkClientRegistry?: AutoManagedNetworkClientRegistry;\n\n  constructor({\n    messenger,\n    state,\n    infuraProjectId,\n    trackMetaMetricsEvent,\n  }: NetworkControllerOptions) {\n    super({\n      name,\n      metadata: {\n        selectedNetworkClientId: {\n          persist: true,\n          anonymous: false,\n        },\n        networksMetadata: {\n          persist: true,\n          anonymous: false,\n        },\n        providerConfig: {\n          persist: true,\n          anonymous: false,\n        },\n        networkConfigurations: {\n          persist: true,\n          anonymous: false,\n        },\n      },\n      messenger,\n      state: { ...defaultState, ...state },\n    });\n    if (!infuraProjectId || typeof infuraProjectId !== 'string') {\n      throw new Error('Invalid Infura project ID');\n    }\n    this.#infuraProjectId = infuraProjectId;\n    this.#trackMetaMetricsEvent = trackMetaMetricsEvent;\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getProviderConfig`,\n      () => {\n        return this.state.providerConfig;\n      },\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getEthQuery`,\n      () => {\n        return this.#ethQuery;\n      },\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getNetworkClientById`,\n      this.getNetworkClientById.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getEIP1559Compatibility`,\n      this.getEIP1559Compatibility.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:setActiveNetwork`,\n      this.setActiveNetwork.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:setProviderType`,\n      this.setProviderType.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:findNetworkClientIdByChainId`,\n      this.findNetworkClientIdByChainId.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getNetworkConfigurationByNetworkClientId`,\n      this.getNetworkConfigurationByNetworkClientId.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getSelectedNetworkClient`,\n      this.getSelectedNetworkClient.bind(this),\n    );\n\n    this.#previousProviderConfig = this.state.providerConfig;\n  }\n\n  /**\n   * Accesses the provider and block tracker for the currently selected network.\n   * @returns The proxy and block tracker proxies.\n   * @deprecated This method has been replaced by `getSelectedNetworkClient` (which has a more easily used return type) and will be removed in a future release.\n   */\n  getProviderAndBlockTracker(): {\n    provider: SwappableProxy<ProxyWithAccessibleTarget<Provider>> | undefined;\n    blockTracker:\n      | SwappableProxy<ProxyWithAccessibleTarget<BlockTracker>>\n      | undefined;\n  } {\n    return {\n      provider: this.#providerProxy,\n      blockTracker: this.#blockTrackerProxy,\n    };\n  }\n\n  /**\n   * Accesses the provider and block tracker for the currently selected network.\n   *\n   * @returns an object with the provider and block tracker proxies for the currently selected network.\n   */\n  getSelectedNetworkClient():\n    | {\n        provider: SwappableProxy<ProxyWithAccessibleTarget<Provider>>;\n        blockTracker: SwappableProxy<ProxyWithAccessibleTarget<BlockTracker>>;\n      }\n    | undefined {\n    if (this.#providerProxy && this.#blockTrackerProxy) {\n      return {\n        provider: this.#providerProxy,\n        blockTracker: this.#blockTrackerProxy,\n      };\n    }\n    return undefined;\n  }\n\n  /**\n   * Returns all of the network clients that have been created so far, keyed by\n   * their identifier in the network client registry. This collection represents\n   * not only built-in networks but also any custom networks that consumers have\n   * added.\n   *\n   * @returns The list of known network clients.\n   */\n  getNetworkClientRegistry(): AutoManagedBuiltInNetworkClientRegistry &\n    AutoManagedCustomNetworkClientRegistry {\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    return Object.assign(\n      {},\n      autoManagedNetworkClientRegistry[NetworkClientType.Infura],\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom],\n    );\n  }\n\n  /**\n   * Returns the Infura network client with the given ID.\n   *\n   * @param infuraNetworkClientId - An Infura network client ID.\n   * @returns The Infura network client.\n   * @throws If an Infura network client does not exist with the given ID.\n   */\n  getNetworkClientById(\n    infuraNetworkClientId: BuiltInNetworkClientId,\n  ): AutoManagedNetworkClient<InfuraNetworkClientConfiguration>;\n\n  /**\n   * Returns the custom network client with the given ID.\n   *\n   * @param customNetworkClientId - A custom network client ID.\n   * @returns The custom network client.\n   * @throws If a custom network client does not exist with the given ID.\n   */\n  getNetworkClientById(\n    customNetworkClientId: CustomNetworkClientId,\n  ): AutoManagedNetworkClient<CustomNetworkClientConfiguration>;\n\n  getNetworkClientById(\n    networkClientId: NetworkClientId,\n  ): AutoManagedNetworkClient<NetworkClientConfiguration> {\n    if (!networkClientId) {\n      throw new Error('No network client ID was provided.');\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    if (isInfuraNetworkType(networkClientId)) {\n      const infuraNetworkClient =\n        autoManagedNetworkClientRegistry[NetworkClientType.Infura][\n          networkClientId\n        ];\n      if (!infuraNetworkClient) {\n        throw new Error(\n          `No Infura network client was found with the ID \"${networkClientId}\".`,\n        );\n      }\n      return infuraNetworkClient;\n    }\n\n    const customNetworkClient =\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom][\n        networkClientId\n      ];\n    if (!customNetworkClient) {\n      throw new Error(\n        `No custom network client was found with the ID \"${networkClientId}\".`,\n      );\n    }\n    return customNetworkClient;\n  }\n\n  /**\n   * Executes a series of steps to apply the changes to the provider config:\n   *\n   * 1. Notifies subscribers that the network is about to change.\n   * 2. Looks up a known and preinitialized network client matching the provider\n   * config and re-points the provider and block tracker proxy to it.\n   * 3. Notifies subscribers that the network has changed.\n   */\n  async #refreshNetwork() {\n    this.messagingSystem.publish(\n      'NetworkController:networkWillChange',\n      this.state,\n    );\n    this.#applyNetworkSelection();\n    this.messagingSystem.publish(\n      'NetworkController:networkDidChange',\n      this.state,\n    );\n    await this.lookupNetwork();\n  }\n\n  /**\n   * Populates the network clients and establishes the initial network based on\n   * the provider configuration in state.\n   */\n  async initializeProvider() {\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.#applyNetworkSelection();\n    // Core Patch Branch: jl/network-controller@19.0.0-patch\n    // await this.lookupNetwork();\n  }\n\n  /**\n   * Refreshes the network meta with EIP-1559 support and the network status\n   * based on the given network client ID.\n   *\n   * @param networkClientId - The ID of the network client to update.\n   */\n  async lookupNetworkByClientId(networkClientId: NetworkClientId) {\n    const isInfura = isInfuraNetworkType(networkClientId);\n    let updatedNetworkStatus: NetworkStatus;\n    let updatedIsEIP1559Compatible: boolean | undefined;\n\n    try {\n      updatedIsEIP1559Compatible = await this.#determineEIP1559Compatibility(\n        networkClientId,\n      );\n      updatedNetworkStatus = NetworkStatus.Available;\n    } catch (error) {\n      if (isErrorWithCode(error)) {\n        let responseBody;\n        if (\n          isInfura &&\n          hasProperty(error, 'message') &&\n          typeof error.message === 'string'\n        ) {\n          try {\n            responseBody = JSON.parse(error.message);\n          } catch {\n            // error.message must not be JSON\n          }\n        }\n\n        if (\n          isPlainObject(responseBody) &&\n          responseBody.error === INFURA_BLOCKED_KEY\n        ) {\n          updatedNetworkStatus = NetworkStatus.Blocked;\n        } else if (error.code === errorCodes.rpc.internal) {\n          updatedNetworkStatus = NetworkStatus.Unknown;\n        } else {\n          updatedNetworkStatus = NetworkStatus.Unavailable;\n        }\n      } else if (\n        typeof Error !== 'undefined' &&\n        hasProperty(error as unknown as Error, 'message') &&\n        typeof (error as unknown as Error).message === 'string' &&\n        (error as unknown as Error).message.includes(\n          'No custom network client was found with the ID',\n        )\n      ) {\n        throw error;\n      } else {\n        log('NetworkController - could not determine network status', error);\n        updatedNetworkStatus = NetworkStatus.Unknown;\n      }\n    }\n    this.update((state) => {\n      if (state.networksMetadata[networkClientId] === undefined) {\n        state.networksMetadata[networkClientId] = {\n          status: NetworkStatus.Unknown,\n          EIPS: {},\n        };\n      }\n      const meta = state.networksMetadata[networkClientId];\n      meta.status = updatedNetworkStatus;\n      if (updatedIsEIP1559Compatible === undefined) {\n        delete meta.EIPS[1559];\n      } else {\n        meta.EIPS[1559] = updatedIsEIP1559Compatible;\n      }\n    });\n  }\n\n  /**\n   * Performs side effects after switching to a network. If the network is\n   * available, updates the network state with the network ID of the network and\n   * stores whether the network supports EIP-1559; otherwise clears said\n   * information about the network that may have been previously stored.\n   *\n   * @param networkClientId - (Optional) The ID of the network client to update.\n   * If no ID is provided, uses the currently selected network.\n   * @fires infuraIsBlocked if the network is Infura-supported and is blocking\n   * requests.\n   * @fires infuraIsUnblocked if the network is Infura-supported and is not\n   * blocking requests, or if the network is not Infura-supported.\n   */\n  async lookupNetwork(networkClientId?: NetworkClientId) {\n    if (networkClientId) {\n      await this.lookupNetworkByClientId(networkClientId);\n      return;\n    }\n\n    if (!this.#ethQuery) {\n      return;\n    }\n\n    const isInfura = isInfuraProviderConfig(this.state.providerConfig);\n\n    let networkChanged = false;\n    const listener = () => {\n      networkChanged = true;\n      this.messagingSystem.unsubscribe(\n        'NetworkController:networkDidChange',\n        listener,\n      );\n    };\n    this.messagingSystem.subscribe(\n      'NetworkController:networkDidChange',\n      listener,\n    );\n\n    let updatedNetworkStatus: NetworkStatus;\n    let updatedIsEIP1559Compatible: boolean | undefined;\n\n    try {\n      const isEIP1559Compatible = await this.#determineEIP1559Compatibility(\n        this.state.selectedNetworkClientId,\n      );\n      updatedNetworkStatus = NetworkStatus.Available;\n      updatedIsEIP1559Compatible = isEIP1559Compatible;\n    } catch (error) {\n      if (isErrorWithCode(error)) {\n        let responseBody;\n        if (\n          isInfura &&\n          hasProperty(error, 'message') &&\n          typeof error.message === 'string'\n        ) {\n          try {\n            responseBody = JSON.parse(error.message);\n          } catch {\n            // error.message must not be JSON\n          }\n        }\n\n        if (\n          isPlainObject(responseBody) &&\n          responseBody.error === INFURA_BLOCKED_KEY\n        ) {\n          updatedNetworkStatus = NetworkStatus.Blocked;\n        } else if (error.code === errorCodes.rpc.internal) {\n          updatedNetworkStatus = NetworkStatus.Unknown;\n        } else {\n          updatedNetworkStatus = NetworkStatus.Unavailable;\n        }\n      } else {\n        log('NetworkController - could not determine network status', error);\n        updatedNetworkStatus = NetworkStatus.Unknown;\n      }\n    }\n\n    if (networkChanged) {\n      // If the network has changed, then `lookupNetwork` either has been or is\n      // in the process of being called, so we don't need to go further.\n      return;\n    }\n    this.messagingSystem.unsubscribe(\n      'NetworkController:networkDidChange',\n      listener,\n    );\n\n    this.update((state) => {\n      const meta = state.networksMetadata[state.selectedNetworkClientId];\n      meta.status = updatedNetworkStatus;\n      if (updatedIsEIP1559Compatible === undefined) {\n        delete meta.EIPS[1559];\n      } else {\n        meta.EIPS[1559] = updatedIsEIP1559Compatible;\n      }\n    });\n\n    if (isInfura) {\n      if (updatedNetworkStatus === NetworkStatus.Available) {\n        this.messagingSystem.publish('NetworkController:infuraIsUnblocked');\n      } else if (updatedNetworkStatus === NetworkStatus.Blocked) {\n        this.messagingSystem.publish('NetworkController:infuraIsBlocked');\n      }\n    } else {\n      // Always publish infuraIsUnblocked regardless of network status to\n      // prevent consumers from being stuck in a blocked state if they were\n      // previously connected to an Infura network that was blocked\n      this.messagingSystem.publish('NetworkController:infuraIsUnblocked');\n    }\n  }\n\n  /**\n   * Convenience method to update provider network type settings.\n   *\n   * @param type - Human readable network name.\n   * @deprecated This has been replaced by `setActiveNetwork`, and will be\n   * removed in a future release\n   */\n  async setProviderType(type: InfuraNetworkType) {\n    assert.notStrictEqual(\n      type,\n      NetworkType.rpc,\n      `NetworkController - cannot call \"setProviderType\" with type \"${NetworkType.rpc}\". Use \"setActiveNetwork\"`,\n    );\n    assert.ok(\n      isInfuraNetworkType(type),\n      `Unknown Infura provider type \"${type}\".`,\n    );\n\n    await this.setActiveNetwork(type);\n  }\n\n  /**\n   * Convenience method to update provider RPC settings.\n   *\n   * @param networkConfigurationIdOrType - The unique id for the network configuration to set as the active provider,\n   * or the type of a built-in network.\n   */\n  async setActiveNetwork(networkConfigurationIdOrType: string) {\n    this.#previousProviderConfig = this.state.providerConfig;\n\n    let targetNetwork: ProviderConfig;\n    if (isInfuraNetworkType(networkConfigurationIdOrType)) {\n      const ticker = NetworksTicker[networkConfigurationIdOrType];\n\n      targetNetwork = {\n        chainId: ChainId[networkConfigurationIdOrType],\n        id: undefined,\n        rpcPrefs: BUILT_IN_NETWORKS[networkConfigurationIdOrType].rpcPrefs,\n        rpcUrl: undefined,\n        nickname: undefined,\n        ticker,\n        type: networkConfigurationIdOrType,\n      };\n    } else {\n      if (\n        !Object.keys(this.state.networkConfigurations).includes(\n          networkConfigurationIdOrType,\n        )\n      ) {\n        throw new Error(\n          `networkConfigurationId ${networkConfigurationIdOrType} does not match a configured networkConfiguration or built-in network type`,\n        );\n      }\n      targetNetwork = {\n        ...this.state.networkConfigurations[networkConfigurationIdOrType],\n        type: NetworkType.rpc,\n      };\n    }\n\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.update((state) => {\n      state.providerConfig = targetNetwork;\n    });\n\n    await this.#refreshNetwork();\n  }\n\n  /**\n   * Fetches the latest block for the network.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check the latest block. Defaults to the selectedNetworkClientId.\n   * @returns A promise that either resolves to the block header or null if\n   * there is no latest block, or rejects with an error.\n   */\n  #getLatestBlock(networkClientId: NetworkClientId): Promise<Block> {\n    if (networkClientId === undefined) {\n      networkClientId = this.state.selectedNetworkClientId;\n    }\n\n    const networkClient = this.getNetworkClientById(networkClientId);\n    const ethQuery = new EthQuery(networkClient.provider);\n\n    return new Promise((resolve, reject) => {\n      ethQuery.sendAsync(\n        { method: 'eth_getBlockByNumber', params: ['latest', false] },\n        (error: unknown, block?: unknown) => {\n          if (error) {\n            reject(error);\n          } else {\n            // TODO: Validate this type\n            resolve(block as Block);\n          }\n        },\n      );\n    });\n  }\n\n  /**\n   * Determines whether the network supports EIP-1559 by checking whether the\n   * latest block has a `baseFeePerGas` property, then updates state\n   * appropriately.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility.\n   * @returns A promise that resolves to true if the network supports EIP-1559\n   * , false otherwise, or `undefined` if unable to determine the compatibility.\n   */\n  async getEIP1559Compatibility(networkClientId?: NetworkClientId) {\n    if (networkClientId) {\n      return this.get1559CompatibilityWithNetworkClientId(networkClientId);\n    }\n    if (!this.#ethQuery) {\n      return false;\n    }\n\n    const { EIPS } =\n      this.state.networksMetadata[this.state.selectedNetworkClientId];\n\n    if (EIPS[1559] !== undefined) {\n      return EIPS[1559];\n    }\n\n    const isEIP1559Compatible = await this.#determineEIP1559Compatibility(\n      this.state.selectedNetworkClientId,\n    );\n    this.update((state) => {\n      if (isEIP1559Compatible !== undefined) {\n        state.networksMetadata[state.selectedNetworkClientId].EIPS[1559] =\n          isEIP1559Compatible;\n      }\n    });\n    return isEIP1559Compatible;\n  }\n\n  async get1559CompatibilityWithNetworkClientId(\n    networkClientId: NetworkClientId,\n  ) {\n    let metadata = this.state.networksMetadata[networkClientId];\n    if (metadata === undefined) {\n      await this.lookupNetwork(networkClientId);\n      metadata = this.state.networksMetadata[networkClientId];\n    }\n    const { EIPS } = metadata;\n\n    // may want to include some 'freshness' value - something to make sure we refetch this from time to time\n    return EIPS[1559];\n  }\n\n  /**\n   * Retrieves and checks the latest block from the currently selected\n   * network; if the block has a `baseFeePerGas` property, then we know\n   * that the network supports EIP-1559; otherwise it doesn't.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility\n   * @returns A promise that resolves to `true` if the network supports EIP-1559,\n   * `false` otherwise, or `undefined` if unable to retrieve the last block.\n   */\n  async #determineEIP1559Compatibility(\n    networkClientId: NetworkClientId,\n  ): Promise<boolean | undefined> {\n    const latestBlock = await this.#getLatestBlock(networkClientId);\n\n    if (!latestBlock) {\n      return undefined;\n    }\n\n    return latestBlock.baseFeePerGas !== undefined;\n  }\n\n  /**\n   * Re-initializes the provider and block tracker for the current network.\n   */\n  async resetConnection() {\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n    await this.#refreshNetwork();\n  }\n\n  /**\n   * Returns a configuration object for the network identified by the given\n   * network client ID. If given an Infura network type, constructs one based on\n   * what we know about the network; otherwise attempts locates a network\n   * configuration in state that corresponds to the network client ID.\n   *\n   * @param networkClientId - The network client ID.\n   * @returns The configuration for the referenced network if one exists, or\n   * undefined otherwise.\n   */\n  getNetworkConfigurationByNetworkClientId(\n    networkClientId: NetworkClientId,\n  ): NetworkConfiguration | undefined {\n    if (isInfuraNetworkType(networkClientId)) {\n      const rpcUrl = `https://${networkClientId}.infura.io/v3/${\n        this.#infuraProjectId\n      }`;\n      return {\n        rpcUrl,\n        ...BUILT_IN_NETWORKS[networkClientId],\n      };\n    }\n\n    return this.state.networkConfigurations[networkClientId];\n  }\n\n  /**\n   * Adds a new custom network or updates the information for an existing\n   * network.\n   *\n   * This may involve updating the `networkConfigurations` property in\n   * state as well and/or adding a new network client to the network client\n   * registry. The `rpcUrl` and `chainId` of the given object are used to\n   * determine which action to take:\n   *\n   * - If the `rpcUrl` corresponds to an existing network configuration\n   * (case-insensitively), then it is overwritten with the object. Furthermore,\n   * if the `chainId` is different from the existing network configuration, then\n   * the existing network client is replaced with a new one.\n   * - If the `rpcUrl` does not correspond to an existing network configuration\n   * (case-insensitively), then the object is used to add a new network\n   * configuration along with a new network client.\n   *\n   * @param networkConfiguration - The network configuration to add or update.\n   * @param options - Additional configuration options.\n   * @param options.referrer - Used to create a metrics event; the site from which the call originated, or 'metamask' for internal calls.\n   * @param options.source - Used to create a metrics event; where the event originated (i.e. from a dapp or from the network form).\n   * @param options.setActive - If true, switches to the network upon adding or updating it (default: false).\n   * @returns The ID for the added or updated network configuration.\n   */\n  async upsertNetworkConfiguration(\n    // Core PR: https://github.com/MetaMask/core/pull/4614\n    // Core Patch Branch: jl/network-controller@19.0.0-patch\n    networkConfiguration: NetworkConfiguration & {\n      id?: NetworkConfigurationId;\n    },\n    {\n      referrer,\n      source,\n      setActive = false,\n    }: {\n      referrer: string;\n      source: string;\n      setActive?: boolean;\n    },\n  ): Promise<string> {\n    // Core PR: https://github.com/MetaMask/core/pull/4614\n    // Core Patch Branch: jl/network-controller@19.0.0-patch\n    const sanitizedNetworkConfiguration: NetworkConfiguration & {\n      id?: NetworkConfigurationId;\n    } = pick(networkConfiguration, [\n      'rpcUrl',\n      'chainId',\n      'ticker',\n      'nickname',\n      'rpcPrefs',\n      'id',\n    ]);\n    const { rpcUrl, chainId, ticker, id } = sanitizedNetworkConfiguration;\n\n    assertIsStrictHexString(chainId);\n    if (!isSafeChainId(chainId)) {\n      throw new Error(\n        `Invalid chain ID \"${chainId}\": numerical value greater than max safe value.`,\n      );\n    }\n    if (!rpcUrl) {\n      throw new Error(\n        'An rpcUrl is required to add or update network configuration',\n      );\n    }\n    if (!referrer || !source) {\n      throw new Error(\n        'referrer and source are required arguments for adding or updating a network configuration',\n      );\n    }\n    try {\n      new URL(rpcUrl);\n      // TODO: Replace `any` with type\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      if (e.message.includes('Invalid URL')) {\n        throw new Error('rpcUrl must be a valid URL');\n      }\n    }\n    if (!ticker) {\n      throw new Error(\n        'A ticker is required to add or update networkConfiguration',\n      );\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    // Core PR: https://github.com/MetaMask/core/pull/4614\n    // Core Patch Branch: jl/network-controller@19.0.0-patch\n    const existingNetworkConfigurationWithId = Object.values(\n      this.state.networkConfigurations,\n    ).find((networkConfig) => networkConfig.id === id);\n    if (id && !existingNetworkConfigurationWithId) {\n      throw new Error('No network configuration matches the provided id');\n    }\n\n    const existingNetworkConfigurationWithRpcUrl = Object.values(\n      this.state.networkConfigurations,\n    ).find(\n      (networkConfig) =>\n        networkConfig.rpcUrl.toLowerCase() === rpcUrl.toLowerCase(),\n    );\n    if (\n      id &&\n      existingNetworkConfigurationWithRpcUrl &&\n      existingNetworkConfigurationWithRpcUrl.id !== id\n    ) {\n      throw new Error(\n        'A different network configuration already exists with the provided rpcUrl',\n      );\n    }\n\n    const existingNetworkConfiguration =\n      existingNetworkConfigurationWithId ??\n      existingNetworkConfigurationWithRpcUrl;\n\n    const upsertedNetworkConfigurationId = existingNetworkConfiguration\n      ? existingNetworkConfiguration.id\n      : random();\n    const networkClientId = buildCustomNetworkClientId(\n      upsertedNetworkConfigurationId,\n    );\n\n    const customNetworkClientRegistry =\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom];\n    const existingAutoManagedNetworkClient =\n      customNetworkClientRegistry[networkClientId];\n    const shouldDestroyExistingNetworkClient =\n      existingAutoManagedNetworkClient &&\n      existingAutoManagedNetworkClient.configuration.chainId !== chainId;\n    if (shouldDestroyExistingNetworkClient) {\n      existingAutoManagedNetworkClient.destroy();\n    }\n    if (\n      !existingAutoManagedNetworkClient ||\n      shouldDestroyExistingNetworkClient\n    ) {\n      customNetworkClientRegistry[networkClientId] =\n        createAutoManagedNetworkClient({\n          type: NetworkClientType.Custom,\n          chainId,\n          rpcUrl,\n          ticker,\n        });\n    }\n\n    this.update((state) => {\n      state.networkConfigurations[upsertedNetworkConfigurationId] = {\n        // Core PR: https://github.com/MetaMask/core/pull/4614\n        // Core Patch Branch: jl/network-controller@19.0.0-patch\n        ...sanitizedNetworkConfiguration,\n        id: upsertedNetworkConfigurationId,\n      };\n    });\n\n    if (!existingNetworkConfiguration) {\n      this.#trackMetaMetricsEvent({\n        event: 'Custom Network Added',\n        category: 'Network',\n        referrer: {\n          url: referrer,\n        },\n        properties: {\n          chain_id: chainId,\n          symbol: ticker,\n          source,\n        },\n      });\n    }\n\n    if (setActive) {\n      await this.setActiveNetwork(upsertedNetworkConfigurationId);\n    }\n\n    return upsertedNetworkConfigurationId;\n  }\n\n  /**\n   * Removes a custom network from state.\n   *\n   * This involves updating the `networkConfigurations` property in state as\n   * well and removing the network client that corresponds to the network from\n   * the client registry.\n   *\n   * @param networkConfigurationId - The ID of an existing network\n   * configuration.\n   */\n  removeNetworkConfiguration(networkConfigurationId: string) {\n    if (!this.state.networkConfigurations[networkConfigurationId]) {\n      throw new Error(\n        `networkConfigurationId ${networkConfigurationId} does not match a configured networkConfiguration`,\n      );\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n    const networkClientId = buildCustomNetworkClientId(networkConfigurationId);\n\n    this.update((state) => {\n      delete state.networkConfigurations[networkConfigurationId];\n    });\n\n    const customNetworkClientRegistry =\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom];\n    const existingAutoManagedNetworkClient =\n      customNetworkClientRegistry[networkClientId];\n    existingAutoManagedNetworkClient.destroy();\n    delete customNetworkClientRegistry[networkClientId];\n  }\n\n  /**\n   * Switches to the previously selected network, assuming that there is one\n   * (if not and `initializeProvider` has not been previously called, then this\n   * method is equivalent to calling `resetConnection`).\n   */\n  async rollbackToPreviousProvider() {\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.update((state) => {\n      state.providerConfig = this.#previousProviderConfig;\n    });\n\n    await this.#refreshNetwork();\n  }\n\n  /**\n   * Deactivates the controller, stopping any ongoing polling.\n   *\n   * In-progress requests will not be aborted.\n   */\n  async destroy() {\n    await this.#blockTrackerProxy?.destroy();\n  }\n\n  /**\n   * Updates the controller using the given backup data.\n   *\n   * @param backup - The data that has been backed up.\n   * @param backup.networkConfigurations - Network configurations in the backup.\n   */\n  loadBackup({\n    networkConfigurations,\n  }: {\n    networkConfigurations: NetworkState['networkConfigurations'];\n  }): void {\n    this.update((state) => {\n      state.networkConfigurations = {\n        ...state.networkConfigurations,\n        ...networkConfigurations,\n      };\n    });\n  }\n\n  /**\n   * Searches for a network configuration ID with the given ChainID and returns it.\n   *\n   * @param chainId - ChainId to search for\n   * @returns networkClientId of the network configuration with the given chainId\n   */\n  findNetworkClientIdByChainId(chainId: Hex): NetworkClientId {\n    const networkClients = this.getNetworkClientRegistry();\n    const networkClientEntry = Object.entries(networkClients).find(\n      ([_, networkClient]) => networkClient.configuration.chainId === chainId,\n    );\n    if (networkClientEntry === undefined) {\n      throw new Error(\"Couldn't find networkClientId for chainId\");\n    }\n    return networkClientEntry[0];\n  }\n\n  /**\n   * Before accessing or switching the network, the registry of network clients\n   * needs to be populated. Otherwise, `#applyNetworkSelection` and\n   * `getNetworkClientRegistry` will throw an error. This method checks to see if the\n   * population step has happened yet, and if not, makes it happen.\n   *\n   * @returns The populated network client registry.\n   */\n  #ensureAutoManagedNetworkClientRegistryPopulated(): AutoManagedNetworkClientRegistry {\n    const autoManagedNetworkClientRegistry =\n      this.#autoManagedNetworkClientRegistry ??\n      this.#createAutoManagedNetworkClientRegistry();\n    this.#autoManagedNetworkClientRegistry = autoManagedNetworkClientRegistry;\n    return autoManagedNetworkClientRegistry;\n  }\n\n  /**\n   * Constructs the registry of network clients based on the set of built-in\n   * networks as well as the custom networks in state.\n   *\n   * @returns The network clients keyed by ID.\n   */\n  #createAutoManagedNetworkClientRegistry(): AutoManagedNetworkClientRegistry {\n    return [\n      ...this.#buildIdentifiedInfuraNetworkClientConfigurations(),\n      ...this.#buildIdentifiedCustomNetworkClientConfigurations(),\n      ...this.#buildIdentifiedNetworkClientConfigurationsFromProviderConfig(),\n    ].reduce(\n      (\n        registry,\n        [networkClientType, networkClientId, networkClientConfiguration],\n      ) => {\n        const autoManagedNetworkClient = createAutoManagedNetworkClient(\n          networkClientConfiguration,\n        );\n        if (networkClientId in registry[networkClientType]) {\n          return registry;\n        }\n        return {\n          ...registry,\n          [networkClientType]: {\n            ...registry[networkClientType],\n            [networkClientId]: autoManagedNetworkClient,\n          },\n        };\n      },\n      {\n        [NetworkClientType.Infura]: {},\n        [NetworkClientType.Custom]: {},\n      },\n    ) as AutoManagedNetworkClientRegistry;\n  }\n\n  /**\n   * Constructs the list of network clients for built-in networks (that is,\n   * the subset of the networks we know Infura supports that consumers do not\n   * need to explicitly add).\n   *\n   * @returns The network clients.\n   */\n  #buildIdentifiedInfuraNetworkClientConfigurations(): [\n    NetworkClientType.Infura,\n    BuiltInNetworkClientId,\n    InfuraNetworkClientConfiguration,\n  ][] {\n    return knownKeysOf(InfuraNetworkType).map((network) => {\n      const networkClientId = buildInfuraNetworkClientId(network);\n      const networkClientConfiguration: InfuraNetworkClientConfiguration = {\n        type: NetworkClientType.Infura,\n        network,\n        infuraProjectId: this.#infuraProjectId,\n        chainId: BUILT_IN_NETWORKS[network].chainId,\n        ticker: BUILT_IN_NETWORKS[network].ticker,\n      };\n      return [\n        NetworkClientType.Infura,\n        networkClientId,\n        networkClientConfiguration,\n      ];\n    });\n  }\n\n  /**\n   * Constructs the list of network clients for custom networks (that is, those\n   * which consumers have added via `networkConfigurations`).\n   *\n   * @returns The network clients.\n   */\n  #buildIdentifiedCustomNetworkClientConfigurations(): [\n    NetworkClientType.Custom,\n    CustomNetworkClientId,\n    CustomNetworkClientConfiguration,\n  ][] {\n    return Object.entries(this.state.networkConfigurations).map(\n      ([networkConfigurationId, networkConfiguration]) => {\n        if (networkConfiguration.chainId === undefined) {\n          throw new Error('chainId must be provided for custom RPC endpoints');\n        }\n        if (networkConfiguration.rpcUrl === undefined) {\n          throw new Error('rpcUrl must be provided for custom RPC endpoints');\n        }\n        const networkClientId = buildCustomNetworkClientId(\n          networkConfigurationId,\n        );\n        const networkClientConfiguration: CustomNetworkClientConfiguration = {\n          type: NetworkClientType.Custom,\n          chainId: networkConfiguration.chainId,\n          rpcUrl: networkConfiguration.rpcUrl,\n          ticker: networkConfiguration.ticker,\n        };\n        return [\n          NetworkClientType.Custom,\n          networkClientId,\n          networkClientConfiguration,\n        ];\n      },\n    );\n  }\n\n  /**\n   * Converts the provider config object in state to a network client\n   * configuration object.\n   *\n   * @returns The network client config.\n   * @throws If the provider config is of type \"rpc\" and lacks either a\n   * `chainId` or an `rpcUrl`.\n   */\n  #buildIdentifiedNetworkClientConfigurationsFromProviderConfig():\n    | [\n        [\n          NetworkClientType.Custom,\n          CustomNetworkClientId,\n          CustomNetworkClientConfiguration,\n        ],\n      ]\n    | [] {\n    const { providerConfig } = this.state;\n\n    if (isCustomProviderConfig(providerConfig)) {\n      validateCustomProviderConfig(providerConfig);\n      const networkClientId = buildCustomNetworkClientId(\n        providerConfig,\n        this.state.networkConfigurations,\n      );\n      const networkClientConfiguration: CustomNetworkClientConfiguration = {\n        chainId: providerConfig.chainId,\n        rpcUrl: providerConfig.rpcUrl,\n        type: NetworkClientType.Custom,\n        ticker: providerConfig.ticker,\n      };\n      return [\n        [NetworkClientType.Custom, networkClientId, networkClientConfiguration],\n      ];\n    }\n\n    if (isInfuraProviderConfig(providerConfig)) {\n      return [];\n    }\n\n    throw new Error(`Unrecognized network type: '${providerConfig.type}'`);\n  }\n\n  /**\n   * Uses the information in the provider config object to look up a known and\n   * preinitialized network client. Once a network client is found, updates the\n   * provider and block tracker proxy to point to those from the network client,\n   * then finally creates an EthQuery that points to the provider proxy.\n   *\n   * @throws If no network client could be found matching the current provider\n   * config.\n   */\n  #applyNetworkSelection() {\n    if (!this.#autoManagedNetworkClientRegistry) {\n      throw new Error(\n        'initializeProvider must be called first in order to switch the network',\n      );\n    }\n\n    const { providerConfig } = this.state;\n\n    let autoManagedNetworkClient: AutoManagedNetworkClient<NetworkClientConfiguration>;\n\n    let networkClientId: NetworkClientId;\n    if (isInfuraProviderConfig(providerConfig)) {\n      const networkClientType = NetworkClientType.Infura;\n      networkClientId = buildInfuraNetworkClientId(providerConfig);\n      const builtInNetworkClientRegistry =\n        this.#autoManagedNetworkClientRegistry[networkClientType];\n      autoManagedNetworkClient =\n        builtInNetworkClientRegistry[networkClientId as BuiltInNetworkClientId];\n      if (!autoManagedNetworkClient) {\n        throw new Error(\n          `Could not find custom network matching ${networkClientId}`,\n        );\n      }\n    } else if (isCustomProviderConfig(providerConfig)) {\n      validateCustomProviderConfig(providerConfig);\n      const networkClientType = NetworkClientType.Custom;\n      networkClientId = buildCustomNetworkClientId(\n        providerConfig,\n        this.state.networkConfigurations,\n      );\n      const customNetworkClientRegistry =\n        this.#autoManagedNetworkClientRegistry[networkClientType];\n      autoManagedNetworkClient = customNetworkClientRegistry[networkClientId];\n      if (!autoManagedNetworkClient) {\n        throw new Error(\n          `Could not find built-in network matching ${networkClientId}`,\n        );\n      }\n    } else {\n      throw new Error('Could not determine type of provider config');\n    }\n\n    this.update((state) => {\n      state.selectedNetworkClientId = networkClientId;\n      if (state.networksMetadata[networkClientId] === undefined) {\n        state.networksMetadata[networkClientId] = {\n          status: NetworkStatus.Unknown,\n          EIPS: {},\n        };\n      }\n    });\n\n    const { provider, blockTracker } = autoManagedNetworkClient;\n\n    if (this.#providerProxy) {\n      this.#providerProxy.setTarget(provider);\n    } else {\n      this.#providerProxy = createEventEmitterProxy(provider);\n    }\n\n    if (this.#blockTrackerProxy) {\n      this.#blockTrackerProxy.setTarget(blockTracker);\n    } else {\n      this.#blockTrackerProxy = createEventEmitterProxy(blockTracker, {\n        eventFilter: 'skipInternal',\n      });\n    }\n\n    this.#ethQuery = new EthQuery(this.#providerProxy);\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/chunk-UG2NYGJD.mjs b/dist/chunk-UG2NYGJD.mjs
deleted file mode 100644
index c39eb49a4a1d2b4ddb78aadb4fb03446b1705528..0000000000000000000000000000000000000000
--- a/dist/chunk-UG2NYGJD.mjs
+++ /dev/null
@@ -1,1017 +0,0 @@
-import {
-  INFURA_BLOCKED_KEY
-} from "./chunk-2QJYHWIP.mjs";
-import {
-  createAutoManagedNetworkClient
-} from "./chunk-G5HYTGGH.mjs";
-import {
-  createModuleLogger,
-  projectLogger
-} from "./chunk-VTLOAS2R.mjs";
-import {
-  __privateAdd,
-  __privateGet,
-  __privateMethod,
-  __privateSet
-} from "./chunk-XUI43LEZ.mjs";
-
-// src/NetworkController.ts
-import { BaseController } from "@metamask/base-controller";
-import {
-  BUILT_IN_NETWORKS,
-  NetworksTicker,
-  ChainId,
-  InfuraNetworkType,
-  NetworkType,
-  isSafeChainId,
-  isInfuraNetworkType
-} from "@metamask/controller-utils";
-import EthQuery from "@metamask/eth-query";
-import { errorCodes } from "@metamask/rpc-errors";
-import { createEventEmitterProxy } from "@metamask/swappable-obj-proxy";
-import {
-  assertIsStrictHexString,
-  hasProperty,
-  isPlainObject
-} from "@metamask/utils";
-import { strict as assert } from "assert";
-import { v4 as random } from "uuid";
-var log = createModuleLogger(projectLogger, "NetworkController");
-function knownKeysOf(object) {
-  return Object.keys(object);
-}
-function assertOfType(value, validate, message) {
-  assert.ok(validate(value), message);
-}
-function pick(object, keys) {
-  const pickedObject = keys.reduce(
-    (finalObject, key) => {
-      return { ...finalObject, [key]: object[key] };
-    },
-    {}
-  );
-  assertOfType(
-    pickedObject,
-    () => keys.every((key) => key in pickedObject),
-    "The reduce did not produce an object with all of the desired keys."
-  );
-  return pickedObject;
-}
-function isErrorWithCode(error) {
-  return typeof error === "object" && error !== null && "code" in error;
-}
-function buildInfuraNetworkClientId(infuraNetworkOrProviderConfig) {
-  if (typeof infuraNetworkOrProviderConfig === "string") {
-    return infuraNetworkOrProviderConfig;
-  }
-  return infuraNetworkOrProviderConfig.type;
-}
-function buildCustomNetworkClientId(...args) {
-  if (args.length === 1) {
-    return args[0];
-  }
-  const [{ id, rpcUrl }, networkConfigurations] = args;
-  if (id === void 0) {
-    const matchingNetworkConfiguration = Object.values(
-      networkConfigurations
-    ).find((networkConfiguration) => {
-      return networkConfiguration.rpcUrl === rpcUrl.toLowerCase();
-    });
-    if (matchingNetworkConfiguration) {
-      return matchingNetworkConfiguration.id;
-    }
-    return rpcUrl.toLowerCase();
-  }
-  return id;
-}
-function isInfuraProviderConfig(providerConfig) {
-  return isInfuraNetworkType(providerConfig.type);
-}
-function isCustomProviderConfig(providerConfig) {
-  return providerConfig.type === NetworkType.rpc;
-}
-function validateCustomProviderConfig(providerConfig) {
-  if (providerConfig.chainId === void 0) {
-    throw new Error("chainId must be provided for custom RPC endpoints");
-  }
-  if (providerConfig.rpcUrl === void 0) {
-    throw new Error("rpcUrl must be provided for custom RPC endpoints");
-  }
-}
-var name = "NetworkController";
-var defaultState = {
-  selectedNetworkClientId: NetworkType.mainnet,
-  providerConfig: {
-    type: NetworkType.mainnet,
-    chainId: ChainId.mainnet,
-    ticker: NetworksTicker.mainnet
-  },
-  networksMetadata: {},
-  networkConfigurations: {}
-};
-var _ethQuery, _infuraProjectId, _trackMetaMetricsEvent, _previousProviderConfig, _providerProxy, _blockTrackerProxy, _autoManagedNetworkClientRegistry, _refreshNetwork, refreshNetwork_fn, _getLatestBlock, getLatestBlock_fn, _determineEIP1559Compatibility, determineEIP1559Compatibility_fn, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn, _createAutoManagedNetworkClientRegistry, createAutoManagedNetworkClientRegistry_fn, _buildIdentifiedInfuraNetworkClientConfigurations, buildIdentifiedInfuraNetworkClientConfigurations_fn, _buildIdentifiedCustomNetworkClientConfigurations, buildIdentifiedCustomNetworkClientConfigurations_fn, _buildIdentifiedNetworkClientConfigurationsFromProviderConfig, buildIdentifiedNetworkClientConfigurationsFromProviderConfig_fn, _applyNetworkSelection, applyNetworkSelection_fn;
-var NetworkController = class extends BaseController {
-  constructor({
-    messenger,
-    state,
-    infuraProjectId,
-    trackMetaMetricsEvent
-  }) {
-    super({
-      name,
-      metadata: {
-        selectedNetworkClientId: {
-          persist: true,
-          anonymous: false
-        },
-        networksMetadata: {
-          persist: true,
-          anonymous: false
-        },
-        providerConfig: {
-          persist: true,
-          anonymous: false
-        },
-        networkConfigurations: {
-          persist: true,
-          anonymous: false
-        }
-      },
-      messenger,
-      state: { ...defaultState, ...state }
-    });
-    /**
-     * Executes a series of steps to apply the changes to the provider config:
-     *
-     * 1. Notifies subscribers that the network is about to change.
-     * 2. Looks up a known and preinitialized network client matching the provider
-     * config and re-points the provider and block tracker proxy to it.
-     * 3. Notifies subscribers that the network has changed.
-     */
-    __privateAdd(this, _refreshNetwork);
-    /**
-     * Fetches the latest block for the network.
-     *
-     * @param networkClientId - The networkClientId to fetch the correct provider against which to check the latest block. Defaults to the selectedNetworkClientId.
-     * @returns A promise that either resolves to the block header or null if
-     * there is no latest block, or rejects with an error.
-     */
-    __privateAdd(this, _getLatestBlock);
-    /**
-     * Retrieves and checks the latest block from the currently selected
-     * network; if the block has a `baseFeePerGas` property, then we know
-     * that the network supports EIP-1559; otherwise it doesn't.
-     *
-     * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility
-     * @returns A promise that resolves to `true` if the network supports EIP-1559,
-     * `false` otherwise, or `undefined` if unable to retrieve the last block.
-     */
-    __privateAdd(this, _determineEIP1559Compatibility);
-    /**
-     * Before accessing or switching the network, the registry of network clients
-     * needs to be populated. Otherwise, `#applyNetworkSelection` and
-     * `getNetworkClientRegistry` will throw an error. This method checks to see if the
-     * population step has happened yet, and if not, makes it happen.
-     *
-     * @returns The populated network client registry.
-     */
-    __privateAdd(this, _ensureAutoManagedNetworkClientRegistryPopulated);
-    /**
-     * Constructs the registry of network clients based on the set of built-in
-     * networks as well as the custom networks in state.
-     *
-     * @returns The network clients keyed by ID.
-     */
-    __privateAdd(this, _createAutoManagedNetworkClientRegistry);
-    /**
-     * Constructs the list of network clients for built-in networks (that is,
-     * the subset of the networks we know Infura supports that consumers do not
-     * need to explicitly add).
-     *
-     * @returns The network clients.
-     */
-    __privateAdd(this, _buildIdentifiedInfuraNetworkClientConfigurations);
-    /**
-     * Constructs the list of network clients for custom networks (that is, those
-     * which consumers have added via `networkConfigurations`).
-     *
-     * @returns The network clients.
-     */
-    __privateAdd(this, _buildIdentifiedCustomNetworkClientConfigurations);
-    /**
-     * Converts the provider config object in state to a network client
-     * configuration object.
-     *
-     * @returns The network client config.
-     * @throws If the provider config is of type "rpc" and lacks either a
-     * `chainId` or an `rpcUrl`.
-     */
-    __privateAdd(this, _buildIdentifiedNetworkClientConfigurationsFromProviderConfig);
-    /**
-     * Uses the information in the provider config object to look up a known and
-     * preinitialized network client. Once a network client is found, updates the
-     * provider and block tracker proxy to point to those from the network client,
-     * then finally creates an EthQuery that points to the provider proxy.
-     *
-     * @throws If no network client could be found matching the current provider
-     * config.
-     */
-    __privateAdd(this, _applyNetworkSelection);
-    __privateAdd(this, _ethQuery, void 0);
-    __privateAdd(this, _infuraProjectId, void 0);
-    __privateAdd(this, _trackMetaMetricsEvent, void 0);
-    __privateAdd(this, _previousProviderConfig, void 0);
-    __privateAdd(this, _providerProxy, void 0);
-    __privateAdd(this, _blockTrackerProxy, void 0);
-    __privateAdd(this, _autoManagedNetworkClientRegistry, void 0);
-    if (!infuraProjectId || typeof infuraProjectId !== "string") {
-      throw new Error("Invalid Infura project ID");
-    }
-    __privateSet(this, _infuraProjectId, infuraProjectId);
-    __privateSet(this, _trackMetaMetricsEvent, trackMetaMetricsEvent);
-    this.messagingSystem.registerActionHandler(
-      `${this.name}:getProviderConfig`,
-      () => {
-        return this.state.providerConfig;
-      }
-    );
-    this.messagingSystem.registerActionHandler(
-      `${this.name}:getEthQuery`,
-      () => {
-        return __privateGet(this, _ethQuery);
-      }
-    );
-    this.messagingSystem.registerActionHandler(
-      `${this.name}:getNetworkClientById`,
-      this.getNetworkClientById.bind(this)
-    );
-    this.messagingSystem.registerActionHandler(
-      `${this.name}:getEIP1559Compatibility`,
-      this.getEIP1559Compatibility.bind(this)
-    );
-    this.messagingSystem.registerActionHandler(
-      `${this.name}:setActiveNetwork`,
-      this.setActiveNetwork.bind(this)
-    );
-    this.messagingSystem.registerActionHandler(
-      `${this.name}:setProviderType`,
-      this.setProviderType.bind(this)
-    );
-    this.messagingSystem.registerActionHandler(
-      `${this.name}:findNetworkClientIdByChainId`,
-      this.findNetworkClientIdByChainId.bind(this)
-    );
-    this.messagingSystem.registerActionHandler(
-      `${this.name}:getNetworkConfigurationByNetworkClientId`,
-      this.getNetworkConfigurationByNetworkClientId.bind(this)
-    );
-    this.messagingSystem.registerActionHandler(
-      `${this.name}:getSelectedNetworkClient`,
-      this.getSelectedNetworkClient.bind(this)
-    );
-    __privateSet(this, _previousProviderConfig, this.state.providerConfig);
-  }
-  /**
-   * Accesses the provider and block tracker for the currently selected network.
-   * @returns The proxy and block tracker proxies.
-   * @deprecated This method has been replaced by `getSelectedNetworkClient` (which has a more easily used return type) and will be removed in a future release.
-   */
-  getProviderAndBlockTracker() {
-    return {
-      provider: __privateGet(this, _providerProxy),
-      blockTracker: __privateGet(this, _blockTrackerProxy)
-    };
-  }
-  /**
-   * Accesses the provider and block tracker for the currently selected network.
-   *
-   * @returns an object with the provider and block tracker proxies for the currently selected network.
-   */
-  getSelectedNetworkClient() {
-    if (__privateGet(this, _providerProxy) && __privateGet(this, _blockTrackerProxy)) {
-      return {
-        provider: __privateGet(this, _providerProxy),
-        blockTracker: __privateGet(this, _blockTrackerProxy)
-      };
-    }
-    return void 0;
-  }
-  /**
-   * Returns all of the network clients that have been created so far, keyed by
-   * their identifier in the network client registry. This collection represents
-   * not only built-in networks but also any custom networks that consumers have
-   * added.
-   *
-   * @returns The list of known network clients.
-   */
-  getNetworkClientRegistry() {
-    const autoManagedNetworkClientRegistry = __privateMethod(this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
-    return Object.assign(
-      {},
-      autoManagedNetworkClientRegistry["infura" /* Infura */],
-      autoManagedNetworkClientRegistry["custom" /* Custom */]
-    );
-  }
-  getNetworkClientById(networkClientId) {
-    if (!networkClientId) {
-      throw new Error("No network client ID was provided.");
-    }
-    const autoManagedNetworkClientRegistry = __privateMethod(this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
-    if (isInfuraNetworkType(networkClientId)) {
-      const infuraNetworkClient = autoManagedNetworkClientRegistry["infura" /* Infura */][networkClientId];
-      if (!infuraNetworkClient) {
-        throw new Error(
-          `No Infura network client was found with the ID "${networkClientId}".`
-        );
-      }
-      return infuraNetworkClient;
-    }
-    const customNetworkClient = autoManagedNetworkClientRegistry["custom" /* Custom */][networkClientId];
-    if (!customNetworkClient) {
-      throw new Error(
-        `No custom network client was found with the ID "${networkClientId}".`
-      );
-    }
-    return customNetworkClient;
-  }
-  /**
-   * Populates the network clients and establishes the initial network based on
-   * the provider configuration in state.
-   */
-  async initializeProvider() {
-    __privateMethod(this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
-    __privateMethod(this, _applyNetworkSelection, applyNetworkSelection_fn).call(this);
-    await this.lookupNetwork();
-  }
-  /**
-   * Refreshes the network meta with EIP-1559 support and the network status
-   * based on the given network client ID.
-   *
-   * @param networkClientId - The ID of the network client to update.
-   */
-  async lookupNetworkByClientId(networkClientId) {
-    const isInfura = isInfuraNetworkType(networkClientId);
-    let updatedNetworkStatus;
-    let updatedIsEIP1559Compatible;
-    try {
-      updatedIsEIP1559Compatible = await __privateMethod(this, _determineEIP1559Compatibility, determineEIP1559Compatibility_fn).call(this, networkClientId);
-      updatedNetworkStatus = "available" /* Available */;
-    } catch (error) {
-      if (isErrorWithCode(error)) {
-        let responseBody;
-        if (isInfura && hasProperty(error, "message") && typeof error.message === "string") {
-          try {
-            responseBody = JSON.parse(error.message);
-          } catch {
-          }
-        }
-        if (isPlainObject(responseBody) && responseBody.error === INFURA_BLOCKED_KEY) {
-          updatedNetworkStatus = "blocked" /* Blocked */;
-        } else if (error.code === errorCodes.rpc.internal) {
-          updatedNetworkStatus = "unknown" /* Unknown */;
-        } else {
-          updatedNetworkStatus = "unavailable" /* Unavailable */;
-        }
-      } else if (typeof Error !== "undefined" && hasProperty(error, "message") && typeof error.message === "string" && error.message.includes(
-        "No custom network client was found with the ID"
-      )) {
-        throw error;
-      } else {
-        log("NetworkController - could not determine network status", error);
-        updatedNetworkStatus = "unknown" /* Unknown */;
-      }
-    }
-    this.update((state) => {
-      if (state.networksMetadata[networkClientId] === void 0) {
-        state.networksMetadata[networkClientId] = {
-          status: "unknown" /* Unknown */,
-          EIPS: {}
-        };
-      }
-      const meta = state.networksMetadata[networkClientId];
-      meta.status = updatedNetworkStatus;
-      if (updatedIsEIP1559Compatible === void 0) {
-        delete meta.EIPS[1559];
-      } else {
-        meta.EIPS[1559] = updatedIsEIP1559Compatible;
-      }
-    });
-  }
-  /**
-   * Performs side effects after switching to a network. If the network is
-   * available, updates the network state with the network ID of the network and
-   * stores whether the network supports EIP-1559; otherwise clears said
-   * information about the network that may have been previously stored.
-   *
-   * @param networkClientId - (Optional) The ID of the network client to update.
-   * If no ID is provided, uses the currently selected network.
-   * @fires infuraIsBlocked if the network is Infura-supported and is blocking
-   * requests.
-   * @fires infuraIsUnblocked if the network is Infura-supported and is not
-   * blocking requests, or if the network is not Infura-supported.
-   */
-  async lookupNetwork(networkClientId) {
-    if (networkClientId) {
-      await this.lookupNetworkByClientId(networkClientId);
-      return;
-    }
-    if (!__privateGet(this, _ethQuery)) {
-      return;
-    }
-    const isInfura = isInfuraProviderConfig(this.state.providerConfig);
-    let networkChanged = false;
-    const listener = () => {
-      networkChanged = true;
-      this.messagingSystem.unsubscribe(
-        "NetworkController:networkDidChange",
-        listener
-      );
-    };
-    this.messagingSystem.subscribe(
-      "NetworkController:networkDidChange",
-      listener
-    );
-    let updatedNetworkStatus;
-    let updatedIsEIP1559Compatible;
-    try {
-      const isEIP1559Compatible = await __privateMethod(this, _determineEIP1559Compatibility, determineEIP1559Compatibility_fn).call(this, this.state.selectedNetworkClientId);
-      updatedNetworkStatus = "available" /* Available */;
-      updatedIsEIP1559Compatible = isEIP1559Compatible;
-    } catch (error) {
-      if (isErrorWithCode(error)) {
-        let responseBody;
-        if (isInfura && hasProperty(error, "message") && typeof error.message === "string") {
-          try {
-            responseBody = JSON.parse(error.message);
-          } catch {
-          }
-        }
-        if (isPlainObject(responseBody) && responseBody.error === INFURA_BLOCKED_KEY) {
-          updatedNetworkStatus = "blocked" /* Blocked */;
-        } else if (error.code === errorCodes.rpc.internal) {
-          updatedNetworkStatus = "unknown" /* Unknown */;
-        } else {
-          updatedNetworkStatus = "unavailable" /* Unavailable */;
-        }
-      } else {
-        log("NetworkController - could not determine network status", error);
-        updatedNetworkStatus = "unknown" /* Unknown */;
-      }
-    }
-    if (networkChanged) {
-      return;
-    }
-    this.messagingSystem.unsubscribe(
-      "NetworkController:networkDidChange",
-      listener
-    );
-    this.update((state) => {
-      const meta = state.networksMetadata[state.selectedNetworkClientId];
-      meta.status = updatedNetworkStatus;
-      if (updatedIsEIP1559Compatible === void 0) {
-        delete meta.EIPS[1559];
-      } else {
-        meta.EIPS[1559] = updatedIsEIP1559Compatible;
-      }
-    });
-    if (isInfura) {
-      if (updatedNetworkStatus === "available" /* Available */) {
-        this.messagingSystem.publish("NetworkController:infuraIsUnblocked");
-      } else if (updatedNetworkStatus === "blocked" /* Blocked */) {
-        this.messagingSystem.publish("NetworkController:infuraIsBlocked");
-      }
-    } else {
-      this.messagingSystem.publish("NetworkController:infuraIsUnblocked");
-    }
-  }
-  /**
-   * Convenience method to update provider network type settings.
-   *
-   * @param type - Human readable network name.
-   * @deprecated This has been replaced by `setActiveNetwork`, and will be
-   * removed in a future release
-   */
-  async setProviderType(type) {
-    assert.notStrictEqual(
-      type,
-      NetworkType.rpc,
-      `NetworkController - cannot call "setProviderType" with type "${NetworkType.rpc}". Use "setActiveNetwork"`
-    );
-    assert.ok(
-      isInfuraNetworkType(type),
-      `Unknown Infura provider type "${type}".`
-    );
-    await this.setActiveNetwork(type);
-  }
-  /**
-   * Convenience method to update provider RPC settings.
-   *
-   * @param networkConfigurationIdOrType - The unique id for the network configuration to set as the active provider,
-   * or the type of a built-in network.
-   */
-  async setActiveNetwork(networkConfigurationIdOrType) {
-    __privateSet(this, _previousProviderConfig, this.state.providerConfig);
-    let targetNetwork;
-    if (isInfuraNetworkType(networkConfigurationIdOrType)) {
-      const ticker = NetworksTicker[networkConfigurationIdOrType];
-      targetNetwork = {
-        chainId: ChainId[networkConfigurationIdOrType],
-        id: void 0,
-        rpcPrefs: BUILT_IN_NETWORKS[networkConfigurationIdOrType].rpcPrefs,
-        rpcUrl: void 0,
-        nickname: void 0,
-        ticker,
-        type: networkConfigurationIdOrType
-      };
-    } else {
-      if (!Object.keys(this.state.networkConfigurations).includes(
-        networkConfigurationIdOrType
-      )) {
-        throw new Error(
-          `networkConfigurationId ${networkConfigurationIdOrType} does not match a configured networkConfiguration or built-in network type`
-        );
-      }
-      targetNetwork = {
-        ...this.state.networkConfigurations[networkConfigurationIdOrType],
-        type: NetworkType.rpc
-      };
-    }
-    __privateMethod(this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
-    this.update((state) => {
-      state.providerConfig = targetNetwork;
-    });
-    await __privateMethod(this, _refreshNetwork, refreshNetwork_fn).call(this);
-  }
-  /**
-   * Determines whether the network supports EIP-1559 by checking whether the
-   * latest block has a `baseFeePerGas` property, then updates state
-   * appropriately.
-   *
-   * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility.
-   * @returns A promise that resolves to true if the network supports EIP-1559
-   * , false otherwise, or `undefined` if unable to determine the compatibility.
-   */
-  async getEIP1559Compatibility(networkClientId) {
-    if (networkClientId) {
-      return this.get1559CompatibilityWithNetworkClientId(networkClientId);
-    }
-    if (!__privateGet(this, _ethQuery)) {
-      return false;
-    }
-    const { EIPS } = this.state.networksMetadata[this.state.selectedNetworkClientId];
-    if (EIPS[1559] !== void 0) {
-      return EIPS[1559];
-    }
-    const isEIP1559Compatible = await __privateMethod(this, _determineEIP1559Compatibility, determineEIP1559Compatibility_fn).call(this, this.state.selectedNetworkClientId);
-    this.update((state) => {
-      if (isEIP1559Compatible !== void 0) {
-        state.networksMetadata[state.selectedNetworkClientId].EIPS[1559] = isEIP1559Compatible;
-      }
-    });
-    return isEIP1559Compatible;
-  }
-  async get1559CompatibilityWithNetworkClientId(networkClientId) {
-    let metadata = this.state.networksMetadata[networkClientId];
-    if (metadata === void 0) {
-      await this.lookupNetwork(networkClientId);
-      metadata = this.state.networksMetadata[networkClientId];
-    }
-    const { EIPS } = metadata;
-    return EIPS[1559];
-  }
-  /**
-   * Re-initializes the provider and block tracker for the current network.
-   */
-  async resetConnection() {
-    __privateMethod(this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
-    await __privateMethod(this, _refreshNetwork, refreshNetwork_fn).call(this);
-  }
-  /**
-   * Returns a configuration object for the network identified by the given
-   * network client ID. If given an Infura network type, constructs one based on
-   * what we know about the network; otherwise attempts locates a network
-   * configuration in state that corresponds to the network client ID.
-   *
-   * @param networkClientId - The network client ID.
-   * @returns The configuration for the referenced network if one exists, or
-   * undefined otherwise.
-   */
-  getNetworkConfigurationByNetworkClientId(networkClientId) {
-    if (isInfuraNetworkType(networkClientId)) {
-      const rpcUrl = `https://${networkClientId}.infura.io/v3/${__privateGet(this, _infuraProjectId)}`;
-      return {
-        rpcUrl,
-        ...BUILT_IN_NETWORKS[networkClientId]
-      };
-    }
-    return this.state.networkConfigurations[networkClientId];
-  }
-  /**
-   * Adds a new custom network or updates the information for an existing
-   * network.
-   *
-   * This may involve updating the `networkConfigurations` property in
-   * state as well and/or adding a new network client to the network client
-   * registry. The `rpcUrl` and `chainId` of the given object are used to
-   * determine which action to take:
-   *
-   * - If the `rpcUrl` corresponds to an existing network configuration
-   * (case-insensitively), then it is overwritten with the object. Furthermore,
-   * if the `chainId` is different from the existing network configuration, then
-   * the existing network client is replaced with a new one.
-   * - If the `rpcUrl` does not correspond to an existing network configuration
-   * (case-insensitively), then the object is used to add a new network
-   * configuration along with a new network client.
-   *
-   * @param networkConfiguration - The network configuration to add or update.
-   * @param options - Additional configuration options.
-   * @param options.referrer - Used to create a metrics event; the site from which the call originated, or 'metamask' for internal calls.
-   * @param options.source - Used to create a metrics event; where the event originated (i.e. from a dapp or from the network form).
-   * @param options.setActive - If true, switches to the network upon adding or updating it (default: false).
-   * @returns The ID for the added or updated network configuration.
-   */
-  async upsertNetworkConfiguration(networkConfiguration, {
-    referrer,
-    source,
-    setActive = false
-  }) {
-    const sanitizedNetworkConfiguration = pick(
-      networkConfiguration,
-      ["rpcUrl", "chainId", "ticker", "nickname", "rpcPrefs"]
-    );
-    const { rpcUrl, chainId, ticker } = sanitizedNetworkConfiguration;
-    assertIsStrictHexString(chainId);
-    if (!isSafeChainId(chainId)) {
-      throw new Error(
-        `Invalid chain ID "${chainId}": numerical value greater than max safe value.`
-      );
-    }
-    if (!rpcUrl) {
-      throw new Error(
-        "An rpcUrl is required to add or update network configuration"
-      );
-    }
-    if (!referrer || !source) {
-      throw new Error(
-        "referrer and source are required arguments for adding or updating a network configuration"
-      );
-    }
-    try {
-      new URL(rpcUrl);
-    } catch (e) {
-      if (e.message.includes("Invalid URL")) {
-        throw new Error("rpcUrl must be a valid URL");
-      }
-    }
-    if (!ticker) {
-      throw new Error(
-        "A ticker is required to add or update networkConfiguration"
-      );
-    }
-    const autoManagedNetworkClientRegistry = __privateMethod(this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
-    const existingNetworkConfiguration = Object.values(
-      this.state.networkConfigurations
-    ).find(
-      (networkConfig) => networkConfig.rpcUrl.toLowerCase() === rpcUrl.toLowerCase()
-    );
-    const upsertedNetworkConfigurationId = existingNetworkConfiguration ? existingNetworkConfiguration.id : random();
-    const networkClientId = buildCustomNetworkClientId(
-      upsertedNetworkConfigurationId
-    );
-    const customNetworkClientRegistry = autoManagedNetworkClientRegistry["custom" /* Custom */];
-    const existingAutoManagedNetworkClient = customNetworkClientRegistry[networkClientId];
-    const shouldDestroyExistingNetworkClient = existingAutoManagedNetworkClient && existingAutoManagedNetworkClient.configuration.chainId !== chainId;
-    if (shouldDestroyExistingNetworkClient) {
-      existingAutoManagedNetworkClient.destroy();
-    }
-    if (!existingAutoManagedNetworkClient || shouldDestroyExistingNetworkClient) {
-      customNetworkClientRegistry[networkClientId] = createAutoManagedNetworkClient({
-        type: "custom" /* Custom */,
-        chainId,
-        rpcUrl,
-        ticker
-      });
-    }
-    this.update((state) => {
-      state.networkConfigurations[upsertedNetworkConfigurationId] = {
-        id: upsertedNetworkConfigurationId,
-        ...sanitizedNetworkConfiguration
-      };
-    });
-    if (!existingNetworkConfiguration) {
-      __privateGet(this, _trackMetaMetricsEvent).call(this, {
-        event: "Custom Network Added",
-        category: "Network",
-        referrer: {
-          url: referrer
-        },
-        properties: {
-          chain_id: chainId,
-          symbol: ticker,
-          source
-        }
-      });
-    }
-    if (setActive) {
-      await this.setActiveNetwork(upsertedNetworkConfigurationId);
-    }
-    return upsertedNetworkConfigurationId;
-  }
-  /**
-   * Removes a custom network from state.
-   *
-   * This involves updating the `networkConfigurations` property in state as
-   * well and removing the network client that corresponds to the network from
-   * the client registry.
-   *
-   * @param networkConfigurationId - The ID of an existing network
-   * configuration.
-   */
-  removeNetworkConfiguration(networkConfigurationId) {
-    if (!this.state.networkConfigurations[networkConfigurationId]) {
-      throw new Error(
-        `networkConfigurationId ${networkConfigurationId} does not match a configured networkConfiguration`
-      );
-    }
-    const autoManagedNetworkClientRegistry = __privateMethod(this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
-    const networkClientId = buildCustomNetworkClientId(networkConfigurationId);
-    this.update((state) => {
-      delete state.networkConfigurations[networkConfigurationId];
-    });
-    const customNetworkClientRegistry = autoManagedNetworkClientRegistry["custom" /* Custom */];
-    const existingAutoManagedNetworkClient = customNetworkClientRegistry[networkClientId];
-    existingAutoManagedNetworkClient.destroy();
-    delete customNetworkClientRegistry[networkClientId];
-  }
-  /**
-   * Switches to the previously selected network, assuming that there is one
-   * (if not and `initializeProvider` has not been previously called, then this
-   * method is equivalent to calling `resetConnection`).
-   */
-  async rollbackToPreviousProvider() {
-    __privateMethod(this, _ensureAutoManagedNetworkClientRegistryPopulated, ensureAutoManagedNetworkClientRegistryPopulated_fn).call(this);
-    this.update((state) => {
-      state.providerConfig = __privateGet(this, _previousProviderConfig);
-    });
-    await __privateMethod(this, _refreshNetwork, refreshNetwork_fn).call(this);
-  }
-  /**
-   * Deactivates the controller, stopping any ongoing polling.
-   *
-   * In-progress requests will not be aborted.
-   */
-  async destroy() {
-    await __privateGet(this, _blockTrackerProxy)?.destroy();
-  }
-  /**
-   * Updates the controller using the given backup data.
-   *
-   * @param backup - The data that has been backed up.
-   * @param backup.networkConfigurations - Network configurations in the backup.
-   */
-  loadBackup({
-    networkConfigurations
-  }) {
-    this.update((state) => {
-      state.networkConfigurations = {
-        ...state.networkConfigurations,
-        ...networkConfigurations
-      };
-    });
-  }
-  /**
-   * Searches for a network configuration ID with the given ChainID and returns it.
-   *
-   * @param chainId - ChainId to search for
-   * @returns networkClientId of the network configuration with the given chainId
-   */
-  findNetworkClientIdByChainId(chainId) {
-    const networkClients = this.getNetworkClientRegistry();
-    const networkClientEntry = Object.entries(networkClients).find(
-      ([_, networkClient]) => networkClient.configuration.chainId === chainId
-    );
-    if (networkClientEntry === void 0) {
-      throw new Error("Couldn't find networkClientId for chainId");
-    }
-    return networkClientEntry[0];
-  }
-};
-_ethQuery = new WeakMap();
-_infuraProjectId = new WeakMap();
-_trackMetaMetricsEvent = new WeakMap();
-_previousProviderConfig = new WeakMap();
-_providerProxy = new WeakMap();
-_blockTrackerProxy = new WeakMap();
-_autoManagedNetworkClientRegistry = new WeakMap();
-_refreshNetwork = new WeakSet();
-refreshNetwork_fn = async function() {
-  this.messagingSystem.publish(
-    "NetworkController:networkWillChange",
-    this.state
-  );
-  __privateMethod(this, _applyNetworkSelection, applyNetworkSelection_fn).call(this);
-  this.messagingSystem.publish(
-    "NetworkController:networkDidChange",
-    this.state
-  );
-  await this.lookupNetwork();
-};
-_getLatestBlock = new WeakSet();
-getLatestBlock_fn = function(networkClientId) {
-  if (networkClientId === void 0) {
-    networkClientId = this.state.selectedNetworkClientId;
-  }
-  const networkClient = this.getNetworkClientById(networkClientId);
-  const ethQuery = new EthQuery(networkClient.provider);
-  return new Promise((resolve, reject) => {
-    ethQuery.sendAsync(
-      { method: "eth_getBlockByNumber", params: ["latest", false] },
-      (error, block) => {
-        if (error) {
-          reject(error);
-        } else {
-          resolve(block);
-        }
-      }
-    );
-  });
-};
-_determineEIP1559Compatibility = new WeakSet();
-determineEIP1559Compatibility_fn = async function(networkClientId) {
-  const latestBlock = await __privateMethod(this, _getLatestBlock, getLatestBlock_fn).call(this, networkClientId);
-  if (!latestBlock) {
-    return void 0;
-  }
-  return latestBlock.baseFeePerGas !== void 0;
-};
-_ensureAutoManagedNetworkClientRegistryPopulated = new WeakSet();
-ensureAutoManagedNetworkClientRegistryPopulated_fn = function() {
-  const autoManagedNetworkClientRegistry = __privateGet(this, _autoManagedNetworkClientRegistry) ?? __privateMethod(this, _createAutoManagedNetworkClientRegistry, createAutoManagedNetworkClientRegistry_fn).call(this);
-  __privateSet(this, _autoManagedNetworkClientRegistry, autoManagedNetworkClientRegistry);
-  return autoManagedNetworkClientRegistry;
-};
-_createAutoManagedNetworkClientRegistry = new WeakSet();
-createAutoManagedNetworkClientRegistry_fn = function() {
-  return [
-    ...__privateMethod(this, _buildIdentifiedInfuraNetworkClientConfigurations, buildIdentifiedInfuraNetworkClientConfigurations_fn).call(this),
-    ...__privateMethod(this, _buildIdentifiedCustomNetworkClientConfigurations, buildIdentifiedCustomNetworkClientConfigurations_fn).call(this),
-    ...__privateMethod(this, _buildIdentifiedNetworkClientConfigurationsFromProviderConfig, buildIdentifiedNetworkClientConfigurationsFromProviderConfig_fn).call(this)
-  ].reduce(
-    (registry, [networkClientType, networkClientId, networkClientConfiguration]) => {
-      const autoManagedNetworkClient = createAutoManagedNetworkClient(
-        networkClientConfiguration
-      );
-      if (networkClientId in registry[networkClientType]) {
-        return registry;
-      }
-      return {
-        ...registry,
-        [networkClientType]: {
-          ...registry[networkClientType],
-          [networkClientId]: autoManagedNetworkClient
-        }
-      };
-    },
-    {
-      ["infura" /* Infura */]: {},
-      ["custom" /* Custom */]: {}
-    }
-  );
-};
-_buildIdentifiedInfuraNetworkClientConfigurations = new WeakSet();
-buildIdentifiedInfuraNetworkClientConfigurations_fn = function() {
-  return knownKeysOf(InfuraNetworkType).map((network) => {
-    const networkClientId = buildInfuraNetworkClientId(network);
-    const networkClientConfiguration = {
-      type: "infura" /* Infura */,
-      network,
-      infuraProjectId: __privateGet(this, _infuraProjectId),
-      chainId: BUILT_IN_NETWORKS[network].chainId,
-      ticker: BUILT_IN_NETWORKS[network].ticker
-    };
-    return [
-      "infura" /* Infura */,
-      networkClientId,
-      networkClientConfiguration
-    ];
-  });
-};
-_buildIdentifiedCustomNetworkClientConfigurations = new WeakSet();
-buildIdentifiedCustomNetworkClientConfigurations_fn = function() {
-  return Object.entries(this.state.networkConfigurations).map(
-    ([networkConfigurationId, networkConfiguration]) => {
-      if (networkConfiguration.chainId === void 0) {
-        throw new Error("chainId must be provided for custom RPC endpoints");
-      }
-      if (networkConfiguration.rpcUrl === void 0) {
-        throw new Error("rpcUrl must be provided for custom RPC endpoints");
-      }
-      const networkClientId = buildCustomNetworkClientId(
-        networkConfigurationId
-      );
-      const networkClientConfiguration = {
-        type: "custom" /* Custom */,
-        chainId: networkConfiguration.chainId,
-        rpcUrl: networkConfiguration.rpcUrl,
-        ticker: networkConfiguration.ticker
-      };
-      return [
-        "custom" /* Custom */,
-        networkClientId,
-        networkClientConfiguration
-      ];
-    }
-  );
-};
-_buildIdentifiedNetworkClientConfigurationsFromProviderConfig = new WeakSet();
-buildIdentifiedNetworkClientConfigurationsFromProviderConfig_fn = function() {
-  const { providerConfig } = this.state;
-  if (isCustomProviderConfig(providerConfig)) {
-    validateCustomProviderConfig(providerConfig);
-    const networkClientId = buildCustomNetworkClientId(
-      providerConfig,
-      this.state.networkConfigurations
-    );
-    const networkClientConfiguration = {
-      chainId: providerConfig.chainId,
-      rpcUrl: providerConfig.rpcUrl,
-      type: "custom" /* Custom */,
-      ticker: providerConfig.ticker
-    };
-    return [
-      ["custom" /* Custom */, networkClientId, networkClientConfiguration]
-    ];
-  }
-  if (isInfuraProviderConfig(providerConfig)) {
-    return [];
-  }
-  throw new Error(`Unrecognized network type: '${providerConfig.type}'`);
-};
-_applyNetworkSelection = new WeakSet();
-applyNetworkSelection_fn = function() {
-  if (!__privateGet(this, _autoManagedNetworkClientRegistry)) {
-    throw new Error(
-      "initializeProvider must be called first in order to switch the network"
-    );
-  }
-  const { providerConfig } = this.state;
-  let autoManagedNetworkClient;
-  let networkClientId;
-  if (isInfuraProviderConfig(providerConfig)) {
-    const networkClientType = "infura" /* Infura */;
-    networkClientId = buildInfuraNetworkClientId(providerConfig);
-    const builtInNetworkClientRegistry = __privateGet(this, _autoManagedNetworkClientRegistry)[networkClientType];
-    autoManagedNetworkClient = builtInNetworkClientRegistry[networkClientId];
-    if (!autoManagedNetworkClient) {
-      throw new Error(
-        `Could not find custom network matching ${networkClientId}`
-      );
-    }
-  } else if (isCustomProviderConfig(providerConfig)) {
-    validateCustomProviderConfig(providerConfig);
-    const networkClientType = "custom" /* Custom */;
-    networkClientId = buildCustomNetworkClientId(
-      providerConfig,
-      this.state.networkConfigurations
-    );
-    const customNetworkClientRegistry = __privateGet(this, _autoManagedNetworkClientRegistry)[networkClientType];
-    autoManagedNetworkClient = customNetworkClientRegistry[networkClientId];
-    if (!autoManagedNetworkClient) {
-      throw new Error(
-        `Could not find built-in network matching ${networkClientId}`
-      );
-    }
-  } else {
-    throw new Error("Could not determine type of provider config");
-  }
-  this.update((state) => {
-    state.selectedNetworkClientId = networkClientId;
-    if (state.networksMetadata[networkClientId] === void 0) {
-      state.networksMetadata[networkClientId] = {
-        status: "unknown" /* Unknown */,
-        EIPS: {}
-      };
-    }
-  });
-  const { provider, blockTracker } = autoManagedNetworkClient;
-  if (__privateGet(this, _providerProxy)) {
-    __privateGet(this, _providerProxy).setTarget(provider);
-  } else {
-    __privateSet(this, _providerProxy, createEventEmitterProxy(provider));
-  }
-  if (__privateGet(this, _blockTrackerProxy)) {
-    __privateGet(this, _blockTrackerProxy).setTarget(blockTracker);
-  } else {
-    __privateSet(this, _blockTrackerProxy, createEventEmitterProxy(blockTracker, {
-      eventFilter: "skipInternal"
-    }));
-  }
-  __privateSet(this, _ethQuery, new EthQuery(__privateGet(this, _providerProxy)));
-};
-
-export {
-  knownKeysOf,
-  defaultState,
-  NetworkController
-};
-//# sourceMappingURL=chunk-UG2NYGJD.mjs.map
\ No newline at end of file
diff --git a/dist/chunk-UG2NYGJD.mjs.map b/dist/chunk-UG2NYGJD.mjs.map
deleted file mode 100644
index 527a5afd1e2545a26b42d139f9ce037299566a67..0000000000000000000000000000000000000000
--- a/dist/chunk-UG2NYGJD.mjs.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/NetworkController.ts"],"sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport {\n  BUILT_IN_NETWORKS,\n  NetworksTicker,\n  ChainId,\n  InfuraNetworkType,\n  NetworkType,\n  isSafeChainId,\n  isInfuraNetworkType,\n} from '@metamask/controller-utils';\nimport EthQuery from '@metamask/eth-query';\nimport { errorCodes } from '@metamask/rpc-errors';\nimport { createEventEmitterProxy } from '@metamask/swappable-obj-proxy';\nimport type { SwappableProxy } from '@metamask/swappable-obj-proxy';\nimport type { Hex } from '@metamask/utils';\nimport {\n  assertIsStrictHexString,\n  hasProperty,\n  isPlainObject,\n} from '@metamask/utils';\nimport { strict as assert } from 'assert';\nimport { v4 as random } from 'uuid';\n\nimport { INFURA_BLOCKED_KEY, NetworkStatus } from './constants';\nimport type {\n  AutoManagedNetworkClient,\n  ProxyWithAccessibleTarget,\n} from './create-auto-managed-network-client';\nimport { createAutoManagedNetworkClient } from './create-auto-managed-network-client';\nimport { projectLogger, createModuleLogger } from './logger';\nimport { NetworkClientType } from './types';\nimport type {\n  BlockTracker,\n  Provider,\n  CustomNetworkClientConfiguration,\n  InfuraNetworkClientConfiguration,\n  NetworkClientConfiguration,\n} from './types';\n\nconst log = createModuleLogger(projectLogger, 'NetworkController');\n\n/**\n * @type ProviderConfig\n *\n * Configuration passed to web3-provider-engine\n * @property rpcUrl - RPC target URL.\n * @property type - Human-readable network name.\n * @property chainId - Network ID as per EIP-155.\n * @property ticker - Currency ticker.\n * @property nickname - Personalized network name.\n * @property id - Network Configuration Id.\n */\nexport type ProviderConfig = {\n  rpcUrl?: string;\n  type: NetworkType;\n  chainId: Hex;\n  ticker: string;\n  nickname?: string;\n  rpcPrefs?: { blockExplorerUrl?: string };\n  id?: NetworkConfigurationId;\n};\n\nexport type Block = {\n  baseFeePerGas?: string;\n};\n\n/**\n * Information about a network not held by any other part of state.\n */\nexport type NetworkMetadata = {\n  /**\n   * EIPs supported by the network.\n   */\n  EIPS: {\n    [eipNumber: number]: boolean;\n  };\n  /**\n   * Indicates the availability of the network\n   */\n  status: NetworkStatus;\n};\n\n/**\n * Custom RPC network information\n *\n * @property rpcUrl - RPC target URL.\n * @property chainId - Network ID as per EIP-155\n * @property nickname - Personalized network name.\n * @property ticker - Currency ticker.\n * @property rpcPrefs - Personalized preferences.\n */\nexport type NetworkConfiguration = {\n  rpcUrl: string;\n  chainId: Hex;\n  ticker: string;\n  nickname?: string;\n  rpcPrefs?: {\n    blockExplorerUrl: string;\n  };\n};\n\n/**\n * The collection of network configurations in state.\n */\ntype NetworkConfigurations = Record<\n  NetworkConfigurationId,\n  NetworkConfiguration & { id: NetworkConfigurationId }\n>;\n\n/**\n * `Object.keys()` is intentionally generic: it returns the keys of an object,\n * but it cannot make guarantees about the contents of that object, so the type\n * of the keys is merely `string[]`. While this is technically accurate, it is\n * also unnecessary if we have an object that we own and whose contents are\n * known exactly.\n *\n * TODO: Move to @metamask/utils.\n *\n * @param object - The object.\n * @returns The keys of an object, typed according to the type of the object\n * itself.\n */\nexport function knownKeysOf<K extends PropertyKey>(\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  object: Partial<Record<K, any>>,\n) {\n  return Object.keys(object) as K[];\n}\n\n/**\n * Asserts that the given value is of the given type if the given validation\n * function returns a truthy result.\n *\n * @param value - The value to validate.\n * @param validate - A function used to validate that the value is of the given\n * type. Takes the `value` as an argument and is expected to return true or\n * false.\n * @param message - The message to throw if the function does not return a\n * truthy result.\n * @throws if the function does not return a truthy result.\n */\nfunction assertOfType<Type>(\n  value: unknown,\n  validate: (value: unknown) => boolean,\n  message: string,\n): asserts value is Type {\n  assert.ok(validate(value), message);\n}\n\n/**\n * Returns a portion of the given object with only the given keys.\n *\n * @param object - An object.\n * @param keys - The keys to pick from the object.\n * @returns the portion of the object.\n */\n// TODO: Replace `any` with type\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction pick<Obj extends Record<any, any>, Keys extends keyof Obj>(\n  object: Obj,\n  keys: Keys[],\n): Pick<Obj, Keys> {\n  const pickedObject = keys.reduce<Partial<Pick<Obj, Keys>>>(\n    (finalObject, key) => {\n      return { ...finalObject, [key]: object[key] };\n    },\n    {},\n  );\n  assertOfType<Pick<Obj, Keys>>(\n    pickedObject,\n    () => keys.every((key) => key in pickedObject),\n    'The reduce did not produce an object with all of the desired keys.',\n  );\n  return pickedObject;\n}\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `code` property, such as an instance of Error.\n *\n * TODO: Move this to @metamask/utils.\n *\n * @param error - The object to check.\n * @returns True if `error` has a `code`, false otherwise.\n */\nfunction isErrorWithCode(error: unknown): error is { code: string | number } {\n  return typeof error === 'object' && error !== null && 'code' in error;\n}\n\n/**\n * Builds an identifier for an Infura network client for lookup purposes.\n *\n * @param infuraNetworkOrProviderConfig - The name of an Infura network or a\n * provider config.\n * @returns The built identifier.\n */\nfunction buildInfuraNetworkClientId(\n  infuraNetworkOrProviderConfig:\n    | InfuraNetworkType\n    | (ProviderConfig & { type: InfuraNetworkType }),\n): BuiltInNetworkClientId {\n  if (typeof infuraNetworkOrProviderConfig === 'string') {\n    return infuraNetworkOrProviderConfig;\n  }\n  return infuraNetworkOrProviderConfig.type;\n}\n\n/**\n * Builds an identifier for a custom network client for lookup purposes.\n *\n * @param args - This function can be called two ways:\n * 1. The ID of a network configuration.\n * 2. A provider config and a set of network configurations.\n * @returns The built identifier.\n */\nfunction buildCustomNetworkClientId(\n  ...args:\n    | [NetworkConfigurationId]\n    | [\n        ProviderConfig & { type: typeof NetworkType.rpc; rpcUrl: string },\n        NetworkConfigurations,\n      ]\n): CustomNetworkClientId {\n  if (args.length === 1) {\n    return args[0];\n  }\n  const [{ id, rpcUrl }, networkConfigurations] = args;\n  if (id === undefined) {\n    const matchingNetworkConfiguration = Object.values(\n      networkConfigurations,\n    ).find((networkConfiguration) => {\n      return networkConfiguration.rpcUrl === rpcUrl.toLowerCase();\n    });\n    if (matchingNetworkConfiguration) {\n      return matchingNetworkConfiguration.id;\n    }\n    return rpcUrl.toLowerCase();\n  }\n  return id;\n}\n\n/**\n * Returns whether the given provider config refers to an Infura network.\n *\n * @param providerConfig - The provider config.\n * @returns True if the provider config refers to an Infura network, false\n * otherwise.\n */\nfunction isInfuraProviderConfig(\n  providerConfig: ProviderConfig,\n): providerConfig is ProviderConfig & { type: InfuraNetworkType } {\n  return isInfuraNetworkType(providerConfig.type);\n}\n\n/**\n * Returns whether the given provider config refers to an Infura network.\n *\n * @param providerConfig - The provider config.\n * @returns True if the provider config refers to an Infura network, false\n * otherwise.\n */\nfunction isCustomProviderConfig(\n  providerConfig: ProviderConfig,\n): providerConfig is ProviderConfig & { type: typeof NetworkType.rpc } {\n  return providerConfig.type === NetworkType.rpc;\n}\n\n/**\n * As a provider config represents the settings that are used to interface with\n * an RPC endpoint, it must have both a chain ID and an RPC URL if it represents\n * a custom network. These properties _should_ be set as they are validated in\n * the UI when a user adds a custom network, but just to be safe we validate\n * them here.\n *\n * In addition, historically the `rpcUrl` property on the ProviderConfig type\n * has been optional, even though it should not be. Making this non-optional\n * would be a breaking change, so this function types the provider config\n * correctly so that we don't have to check `rpcUrl` in other places.\n *\n * @param providerConfig - A provider config.\n * @throws if the provider config does not have a chain ID or an RPC URL.\n */\nfunction validateCustomProviderConfig(\n  providerConfig: ProviderConfig & { type: typeof NetworkType.rpc },\n): asserts providerConfig is typeof providerConfig & { rpcUrl: string } {\n  if (providerConfig.chainId === undefined) {\n    throw new Error('chainId must be provided for custom RPC endpoints');\n  }\n  if (providerConfig.rpcUrl === undefined) {\n    throw new Error('rpcUrl must be provided for custom RPC endpoints');\n  }\n}\n/**\n * The string that uniquely identifies an Infura network client.\n */\nexport type BuiltInNetworkClientId = InfuraNetworkType;\n\n/**\n * The string that uniquely identifies a custom network client.\n */\nexport type CustomNetworkClientId = string;\n\n/**\n * The string that uniquely identifies a network client.\n */\nexport type NetworkClientId = BuiltInNetworkClientId | CustomNetworkClientId;\n\n/**\n * Information about networks not held by any other part of state.\n */\nexport type NetworksMetadata = {\n  [networkClientId: NetworkClientId]: NetworkMetadata;\n};\n\n/**\n * @type NetworkState\n *\n * Network controller state\n * @property providerConfig - RPC URL and network name provider settings of the currently connected network\n * @property properties - an additional set of network properties for the currently connected network\n * @property networkConfigurations - the full list of configured networks either preloaded or added by the user.\n */\nexport type NetworkState = {\n  selectedNetworkClientId: NetworkClientId;\n  providerConfig: ProviderConfig;\n  networkConfigurations: NetworkConfigurations;\n  networksMetadata: NetworksMetadata;\n};\n\nconst name = 'NetworkController';\n\n/**\n * Represents the block tracker for the currently selected network. (Note that\n * this is a proxy around a proxy: the inner one exists so that the block\n * tracker doesn't have to exist until it's used, and the outer one exists so\n * that the currently selected network can change without consumers needing to\n * refresh the object reference to that network.)\n */\nexport type BlockTrackerProxy = SwappableProxy<\n  ProxyWithAccessibleTarget<BlockTracker>\n>;\n\n/**\n * Represents the provider for the currently selected network. (Note that this\n * is a proxy around a proxy: the inner one exists so that the provider doesn't\n * have to exist until it's used, and the outer one exists so that the currently\n * selected network can change without consumers needing to refresh the object\n * reference to that network.)\n */\nexport type ProviderProxy = SwappableProxy<ProxyWithAccessibleTarget<Provider>>;\n\nexport type NetworkControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof name,\n  NetworkState\n>;\n\n/**\n * `networkWillChange` is published when the current network is about to be\n * switched, but the new provider has not been created and no state changes have\n * occurred yet.\n */\nexport type NetworkControllerNetworkWillChangeEvent = {\n  type: 'NetworkController:networkWillChange';\n  payload: [NetworkState];\n};\n\n/**\n * `networkDidChange` is published after a provider has been created for a newly\n * switched network (but before the network has been confirmed to be available).\n */\nexport type NetworkControllerNetworkDidChangeEvent = {\n  type: 'NetworkController:networkDidChange';\n  payload: [NetworkState];\n};\n\n/**\n * `infuraIsBlocked` is published after the network is switched to an Infura\n * network, but when Infura returns an error blocking the user based on their\n * location.\n */\nexport type NetworkControllerInfuraIsBlockedEvent = {\n  type: 'NetworkController:infuraIsBlocked';\n  payload: [];\n};\n\n/**\n * `infuraIsBlocked` is published either after the network is switched to an\n * Infura network and Infura does not return an error blocking the user based on\n * their location, or the network is switched to a non-Infura network.\n */\nexport type NetworkControllerInfuraIsUnblockedEvent = {\n  type: 'NetworkController:infuraIsUnblocked';\n  payload: [];\n};\n\nexport type NetworkControllerEvents =\n  | NetworkControllerStateChangeEvent\n  | NetworkControllerNetworkWillChangeEvent\n  | NetworkControllerNetworkDidChangeEvent\n  | NetworkControllerInfuraIsBlockedEvent\n  | NetworkControllerInfuraIsUnblockedEvent;\n\nexport type NetworkControllerGetStateAction = ControllerGetStateAction<\n  typeof name,\n  NetworkState\n>;\n\nexport type NetworkControllerGetProviderConfigAction = {\n  type: `NetworkController:getProviderConfig`;\n  handler: () => ProviderConfig;\n};\n\nexport type NetworkControllerGetEthQueryAction = {\n  type: `NetworkController:getEthQuery`;\n  handler: () => EthQuery | undefined;\n};\n\nexport type NetworkControllerGetNetworkClientByIdAction = {\n  type: `NetworkController:getNetworkClientById`;\n  handler: NetworkController['getNetworkClientById'];\n};\n\nexport type NetworkControllerGetSelectedNetworkClientAction = {\n  type: `NetworkController:getSelectedNetworkClient`;\n  handler: NetworkController['getSelectedNetworkClient'];\n};\n\nexport type NetworkControllerGetEIP1559CompatibilityAction = {\n  type: `NetworkController:getEIP1559Compatibility`;\n  handler: NetworkController['getEIP1559Compatibility'];\n};\n\nexport type NetworkControllerFindNetworkClientIdByChainIdAction = {\n  type: `NetworkController:findNetworkClientIdByChainId`;\n  handler: NetworkController['findNetworkClientIdByChainId'];\n};\n\n/**\n * Change the currently selected network to the given built-in network type.\n *\n * @deprecated This action has been replaced by `setActiveNetwork`, and will be\n * removed in a future release.\n */\nexport type NetworkControllerSetProviderTypeAction = {\n  type: `NetworkController:setProviderType`;\n  handler: NetworkController['setProviderType'];\n};\n\nexport type NetworkControllerSetActiveNetworkAction = {\n  type: `NetworkController:setActiveNetwork`;\n  handler: NetworkController['setActiveNetwork'];\n};\n\nexport type NetworkControllerGetNetworkConfigurationByNetworkClientId = {\n  type: `NetworkController:getNetworkConfigurationByNetworkClientId`;\n  handler: NetworkController['getNetworkConfigurationByNetworkClientId'];\n};\n\nexport type NetworkControllerActions =\n  | NetworkControllerGetStateAction\n  | NetworkControllerGetProviderConfigAction\n  | NetworkControllerGetEthQueryAction\n  | NetworkControllerGetNetworkClientByIdAction\n  | NetworkControllerGetSelectedNetworkClientAction\n  | NetworkControllerGetEIP1559CompatibilityAction\n  | NetworkControllerFindNetworkClientIdByChainIdAction\n  | NetworkControllerSetActiveNetworkAction\n  | NetworkControllerSetProviderTypeAction\n  | NetworkControllerGetNetworkConfigurationByNetworkClientId;\n\nexport type NetworkControllerMessenger = RestrictedControllerMessenger<\n  typeof name,\n  NetworkControllerActions,\n  NetworkControllerEvents,\n  never,\n  never\n>;\n\nexport type NetworkControllerOptions = {\n  messenger: NetworkControllerMessenger;\n  trackMetaMetricsEvent: () => void;\n  infuraProjectId: string;\n  state?: Partial<NetworkState>;\n};\n\nexport const defaultState: NetworkState = {\n  selectedNetworkClientId: NetworkType.mainnet,\n  providerConfig: {\n    type: NetworkType.mainnet,\n    chainId: ChainId.mainnet,\n    ticker: NetworksTicker.mainnet,\n  },\n  networksMetadata: {},\n  networkConfigurations: {},\n};\n\ntype MetaMetricsEventPayload = {\n  event: string;\n  category: string;\n  referrer?: { url: string };\n  actionId?: number;\n  environmentType?: string;\n  properties?: unknown;\n  sensitiveProperties?: unknown;\n  revenue?: number;\n  currency?: string;\n  value?: number;\n};\n\ntype NetworkConfigurationId = string;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks.\n */\ntype AutoManagedBuiltInNetworkClientRegistry = Record<\n  BuiltInNetworkClientId,\n  AutoManagedNetworkClient<InfuraNetworkClientConfiguration>\n>;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks.\n */\ntype AutoManagedCustomNetworkClientRegistry = Record<\n  CustomNetworkClientId,\n  AutoManagedNetworkClient<CustomNetworkClientConfiguration>\n>;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks\n * as well as custom networks that users have added.\n */\ntype AutoManagedNetworkClientRegistry = {\n  [NetworkClientType.Infura]: AutoManagedBuiltInNetworkClientRegistry;\n  [NetworkClientType.Custom]: AutoManagedCustomNetworkClientRegistry;\n};\n\n/**\n * Controller that creates and manages an Ethereum network provider.\n */\nexport class NetworkController extends BaseController<\n  typeof name,\n  NetworkState,\n  NetworkControllerMessenger\n> {\n  #ethQuery?: EthQuery;\n\n  #infuraProjectId: string;\n\n  #trackMetaMetricsEvent: (event: MetaMetricsEventPayload) => void;\n\n  #previousProviderConfig: ProviderConfig;\n\n  #providerProxy: ProviderProxy | undefined;\n\n  #blockTrackerProxy: BlockTrackerProxy | undefined;\n\n  #autoManagedNetworkClientRegistry?: AutoManagedNetworkClientRegistry;\n\n  constructor({\n    messenger,\n    state,\n    infuraProjectId,\n    trackMetaMetricsEvent,\n  }: NetworkControllerOptions) {\n    super({\n      name,\n      metadata: {\n        selectedNetworkClientId: {\n          persist: true,\n          anonymous: false,\n        },\n        networksMetadata: {\n          persist: true,\n          anonymous: false,\n        },\n        providerConfig: {\n          persist: true,\n          anonymous: false,\n        },\n        networkConfigurations: {\n          persist: true,\n          anonymous: false,\n        },\n      },\n      messenger,\n      state: { ...defaultState, ...state },\n    });\n    if (!infuraProjectId || typeof infuraProjectId !== 'string') {\n      throw new Error('Invalid Infura project ID');\n    }\n    this.#infuraProjectId = infuraProjectId;\n    this.#trackMetaMetricsEvent = trackMetaMetricsEvent;\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getProviderConfig`,\n      () => {\n        return this.state.providerConfig;\n      },\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getEthQuery`,\n      () => {\n        return this.#ethQuery;\n      },\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getNetworkClientById`,\n      this.getNetworkClientById.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getEIP1559Compatibility`,\n      this.getEIP1559Compatibility.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:setActiveNetwork`,\n      this.setActiveNetwork.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:setProviderType`,\n      this.setProviderType.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:findNetworkClientIdByChainId`,\n      this.findNetworkClientIdByChainId.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getNetworkConfigurationByNetworkClientId`,\n      this.getNetworkConfigurationByNetworkClientId.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getSelectedNetworkClient`,\n      this.getSelectedNetworkClient.bind(this),\n    );\n\n    this.#previousProviderConfig = this.state.providerConfig;\n  }\n\n  /**\n   * Accesses the provider and block tracker for the currently selected network.\n   * @returns The proxy and block tracker proxies.\n   * @deprecated This method has been replaced by `getSelectedNetworkClient` (which has a more easily used return type) and will be removed in a future release.\n   */\n  getProviderAndBlockTracker(): {\n    provider: SwappableProxy<ProxyWithAccessibleTarget<Provider>> | undefined;\n    blockTracker:\n      | SwappableProxy<ProxyWithAccessibleTarget<BlockTracker>>\n      | undefined;\n  } {\n    return {\n      provider: this.#providerProxy,\n      blockTracker: this.#blockTrackerProxy,\n    };\n  }\n\n  /**\n   * Accesses the provider and block tracker for the currently selected network.\n   *\n   * @returns an object with the provider and block tracker proxies for the currently selected network.\n   */\n  getSelectedNetworkClient():\n    | {\n        provider: SwappableProxy<ProxyWithAccessibleTarget<Provider>>;\n        blockTracker: SwappableProxy<ProxyWithAccessibleTarget<BlockTracker>>;\n      }\n    | undefined {\n    if (this.#providerProxy && this.#blockTrackerProxy) {\n      return {\n        provider: this.#providerProxy,\n        blockTracker: this.#blockTrackerProxy,\n      };\n    }\n    return undefined;\n  }\n\n  /**\n   * Returns all of the network clients that have been created so far, keyed by\n   * their identifier in the network client registry. This collection represents\n   * not only built-in networks but also any custom networks that consumers have\n   * added.\n   *\n   * @returns The list of known network clients.\n   */\n  getNetworkClientRegistry(): AutoManagedBuiltInNetworkClientRegistry &\n    AutoManagedCustomNetworkClientRegistry {\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    return Object.assign(\n      {},\n      autoManagedNetworkClientRegistry[NetworkClientType.Infura],\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom],\n    );\n  }\n\n  /**\n   * Returns the Infura network client with the given ID.\n   *\n   * @param infuraNetworkClientId - An Infura network client ID.\n   * @returns The Infura network client.\n   * @throws If an Infura network client does not exist with the given ID.\n   */\n  getNetworkClientById(\n    infuraNetworkClientId: BuiltInNetworkClientId,\n  ): AutoManagedNetworkClient<InfuraNetworkClientConfiguration>;\n\n  /**\n   * Returns the custom network client with the given ID.\n   *\n   * @param customNetworkClientId - A custom network client ID.\n   * @returns The custom network client.\n   * @throws If a custom network client does not exist with the given ID.\n   */\n  getNetworkClientById(\n    customNetworkClientId: CustomNetworkClientId,\n  ): AutoManagedNetworkClient<CustomNetworkClientConfiguration>;\n\n  getNetworkClientById(\n    networkClientId: NetworkClientId,\n  ): AutoManagedNetworkClient<NetworkClientConfiguration> {\n    if (!networkClientId) {\n      throw new Error('No network client ID was provided.');\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    if (isInfuraNetworkType(networkClientId)) {\n      const infuraNetworkClient =\n        autoManagedNetworkClientRegistry[NetworkClientType.Infura][\n          networkClientId\n        ];\n      if (!infuraNetworkClient) {\n        throw new Error(\n          `No Infura network client was found with the ID \"${networkClientId}\".`,\n        );\n      }\n      return infuraNetworkClient;\n    }\n\n    const customNetworkClient =\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom][\n        networkClientId\n      ];\n    if (!customNetworkClient) {\n      throw new Error(\n        `No custom network client was found with the ID \"${networkClientId}\".`,\n      );\n    }\n    return customNetworkClient;\n  }\n\n  /**\n   * Executes a series of steps to apply the changes to the provider config:\n   *\n   * 1. Notifies subscribers that the network is about to change.\n   * 2. Looks up a known and preinitialized network client matching the provider\n   * config and re-points the provider and block tracker proxy to it.\n   * 3. Notifies subscribers that the network has changed.\n   */\n  async #refreshNetwork() {\n    this.messagingSystem.publish(\n      'NetworkController:networkWillChange',\n      this.state,\n    );\n    this.#applyNetworkSelection();\n    this.messagingSystem.publish(\n      'NetworkController:networkDidChange',\n      this.state,\n    );\n    await this.lookupNetwork();\n  }\n\n  /**\n   * Populates the network clients and establishes the initial network based on\n   * the provider configuration in state.\n   */\n  async initializeProvider() {\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.#applyNetworkSelection();\n    await this.lookupNetwork();\n  }\n\n  /**\n   * Refreshes the network meta with EIP-1559 support and the network status\n   * based on the given network client ID.\n   *\n   * @param networkClientId - The ID of the network client to update.\n   */\n  async lookupNetworkByClientId(networkClientId: NetworkClientId) {\n    const isInfura = isInfuraNetworkType(networkClientId);\n    let updatedNetworkStatus: NetworkStatus;\n    let updatedIsEIP1559Compatible: boolean | undefined;\n\n    try {\n      updatedIsEIP1559Compatible = await this.#determineEIP1559Compatibility(\n        networkClientId,\n      );\n      updatedNetworkStatus = NetworkStatus.Available;\n    } catch (error) {\n      if (isErrorWithCode(error)) {\n        let responseBody;\n        if (\n          isInfura &&\n          hasProperty(error, 'message') &&\n          typeof error.message === 'string'\n        ) {\n          try {\n            responseBody = JSON.parse(error.message);\n          } catch {\n            // error.message must not be JSON\n          }\n        }\n\n        if (\n          isPlainObject(responseBody) &&\n          responseBody.error === INFURA_BLOCKED_KEY\n        ) {\n          updatedNetworkStatus = NetworkStatus.Blocked;\n        } else if (error.code === errorCodes.rpc.internal) {\n          updatedNetworkStatus = NetworkStatus.Unknown;\n        } else {\n          updatedNetworkStatus = NetworkStatus.Unavailable;\n        }\n      } else if (\n        typeof Error !== 'undefined' &&\n        hasProperty(error as unknown as Error, 'message') &&\n        typeof (error as unknown as Error).message === 'string' &&\n        (error as unknown as Error).message.includes(\n          'No custom network client was found with the ID',\n        )\n      ) {\n        throw error;\n      } else {\n        log('NetworkController - could not determine network status', error);\n        updatedNetworkStatus = NetworkStatus.Unknown;\n      }\n    }\n    this.update((state) => {\n      if (state.networksMetadata[networkClientId] === undefined) {\n        state.networksMetadata[networkClientId] = {\n          status: NetworkStatus.Unknown,\n          EIPS: {},\n        };\n      }\n      const meta = state.networksMetadata[networkClientId];\n      meta.status = updatedNetworkStatus;\n      if (updatedIsEIP1559Compatible === undefined) {\n        delete meta.EIPS[1559];\n      } else {\n        meta.EIPS[1559] = updatedIsEIP1559Compatible;\n      }\n    });\n  }\n\n  /**\n   * Performs side effects after switching to a network. If the network is\n   * available, updates the network state with the network ID of the network and\n   * stores whether the network supports EIP-1559; otherwise clears said\n   * information about the network that may have been previously stored.\n   *\n   * @param networkClientId - (Optional) The ID of the network client to update.\n   * If no ID is provided, uses the currently selected network.\n   * @fires infuraIsBlocked if the network is Infura-supported and is blocking\n   * requests.\n   * @fires infuraIsUnblocked if the network is Infura-supported and is not\n   * blocking requests, or if the network is not Infura-supported.\n   */\n  async lookupNetwork(networkClientId?: NetworkClientId) {\n    if (networkClientId) {\n      await this.lookupNetworkByClientId(networkClientId);\n      return;\n    }\n\n    if (!this.#ethQuery) {\n      return;\n    }\n\n    const isInfura = isInfuraProviderConfig(this.state.providerConfig);\n\n    let networkChanged = false;\n    const listener = () => {\n      networkChanged = true;\n      this.messagingSystem.unsubscribe(\n        'NetworkController:networkDidChange',\n        listener,\n      );\n    };\n    this.messagingSystem.subscribe(\n      'NetworkController:networkDidChange',\n      listener,\n    );\n\n    let updatedNetworkStatus: NetworkStatus;\n    let updatedIsEIP1559Compatible: boolean | undefined;\n\n    try {\n      const isEIP1559Compatible = await this.#determineEIP1559Compatibility(\n        this.state.selectedNetworkClientId,\n      );\n      updatedNetworkStatus = NetworkStatus.Available;\n      updatedIsEIP1559Compatible = isEIP1559Compatible;\n    } catch (error) {\n      if (isErrorWithCode(error)) {\n        let responseBody;\n        if (\n          isInfura &&\n          hasProperty(error, 'message') &&\n          typeof error.message === 'string'\n        ) {\n          try {\n            responseBody = JSON.parse(error.message);\n          } catch {\n            // error.message must not be JSON\n          }\n        }\n\n        if (\n          isPlainObject(responseBody) &&\n          responseBody.error === INFURA_BLOCKED_KEY\n        ) {\n          updatedNetworkStatus = NetworkStatus.Blocked;\n        } else if (error.code === errorCodes.rpc.internal) {\n          updatedNetworkStatus = NetworkStatus.Unknown;\n        } else {\n          updatedNetworkStatus = NetworkStatus.Unavailable;\n        }\n      } else {\n        log('NetworkController - could not determine network status', error);\n        updatedNetworkStatus = NetworkStatus.Unknown;\n      }\n    }\n\n    if (networkChanged) {\n      // If the network has changed, then `lookupNetwork` either has been or is\n      // in the process of being called, so we don't need to go further.\n      return;\n    }\n    this.messagingSystem.unsubscribe(\n      'NetworkController:networkDidChange',\n      listener,\n    );\n\n    this.update((state) => {\n      const meta = state.networksMetadata[state.selectedNetworkClientId];\n      meta.status = updatedNetworkStatus;\n      if (updatedIsEIP1559Compatible === undefined) {\n        delete meta.EIPS[1559];\n      } else {\n        meta.EIPS[1559] = updatedIsEIP1559Compatible;\n      }\n    });\n\n    if (isInfura) {\n      if (updatedNetworkStatus === NetworkStatus.Available) {\n        this.messagingSystem.publish('NetworkController:infuraIsUnblocked');\n      } else if (updatedNetworkStatus === NetworkStatus.Blocked) {\n        this.messagingSystem.publish('NetworkController:infuraIsBlocked');\n      }\n    } else {\n      // Always publish infuraIsUnblocked regardless of network status to\n      // prevent consumers from being stuck in a blocked state if they were\n      // previously connected to an Infura network that was blocked\n      this.messagingSystem.publish('NetworkController:infuraIsUnblocked');\n    }\n  }\n\n  /**\n   * Convenience method to update provider network type settings.\n   *\n   * @param type - Human readable network name.\n   * @deprecated This has been replaced by `setActiveNetwork`, and will be\n   * removed in a future release\n   */\n  async setProviderType(type: InfuraNetworkType) {\n    assert.notStrictEqual(\n      type,\n      NetworkType.rpc,\n      `NetworkController - cannot call \"setProviderType\" with type \"${NetworkType.rpc}\". Use \"setActiveNetwork\"`,\n    );\n    assert.ok(\n      isInfuraNetworkType(type),\n      `Unknown Infura provider type \"${type}\".`,\n    );\n\n    await this.setActiveNetwork(type);\n  }\n\n  /**\n   * Convenience method to update provider RPC settings.\n   *\n   * @param networkConfigurationIdOrType - The unique id for the network configuration to set as the active provider,\n   * or the type of a built-in network.\n   */\n  async setActiveNetwork(networkConfigurationIdOrType: string) {\n    this.#previousProviderConfig = this.state.providerConfig;\n\n    let targetNetwork: ProviderConfig;\n    if (isInfuraNetworkType(networkConfigurationIdOrType)) {\n      const ticker = NetworksTicker[networkConfigurationIdOrType];\n\n      targetNetwork = {\n        chainId: ChainId[networkConfigurationIdOrType],\n        id: undefined,\n        rpcPrefs: BUILT_IN_NETWORKS[networkConfigurationIdOrType].rpcPrefs,\n        rpcUrl: undefined,\n        nickname: undefined,\n        ticker,\n        type: networkConfigurationIdOrType,\n      };\n    } else {\n      if (\n        !Object.keys(this.state.networkConfigurations).includes(\n          networkConfigurationIdOrType,\n        )\n      ) {\n        throw new Error(\n          `networkConfigurationId ${networkConfigurationIdOrType} does not match a configured networkConfiguration or built-in network type`,\n        );\n      }\n      targetNetwork = {\n        ...this.state.networkConfigurations[networkConfigurationIdOrType],\n        type: NetworkType.rpc,\n      };\n    }\n\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.update((state) => {\n      state.providerConfig = targetNetwork;\n    });\n\n    await this.#refreshNetwork();\n  }\n\n  /**\n   * Fetches the latest block for the network.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check the latest block. Defaults to the selectedNetworkClientId.\n   * @returns A promise that either resolves to the block header or null if\n   * there is no latest block, or rejects with an error.\n   */\n  #getLatestBlock(networkClientId: NetworkClientId): Promise<Block> {\n    if (networkClientId === undefined) {\n      networkClientId = this.state.selectedNetworkClientId;\n    }\n\n    const networkClient = this.getNetworkClientById(networkClientId);\n    const ethQuery = new EthQuery(networkClient.provider);\n\n    return new Promise((resolve, reject) => {\n      ethQuery.sendAsync(\n        { method: 'eth_getBlockByNumber', params: ['latest', false] },\n        (error: unknown, block?: unknown) => {\n          if (error) {\n            reject(error);\n          } else {\n            // TODO: Validate this type\n            resolve(block as Block);\n          }\n        },\n      );\n    });\n  }\n\n  /**\n   * Determines whether the network supports EIP-1559 by checking whether the\n   * latest block has a `baseFeePerGas` property, then updates state\n   * appropriately.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility.\n   * @returns A promise that resolves to true if the network supports EIP-1559\n   * , false otherwise, or `undefined` if unable to determine the compatibility.\n   */\n  async getEIP1559Compatibility(networkClientId?: NetworkClientId) {\n    if (networkClientId) {\n      return this.get1559CompatibilityWithNetworkClientId(networkClientId);\n    }\n    if (!this.#ethQuery) {\n      return false;\n    }\n\n    const { EIPS } =\n      this.state.networksMetadata[this.state.selectedNetworkClientId];\n\n    if (EIPS[1559] !== undefined) {\n      return EIPS[1559];\n    }\n\n    const isEIP1559Compatible = await this.#determineEIP1559Compatibility(\n      this.state.selectedNetworkClientId,\n    );\n    this.update((state) => {\n      if (isEIP1559Compatible !== undefined) {\n        state.networksMetadata[state.selectedNetworkClientId].EIPS[1559] =\n          isEIP1559Compatible;\n      }\n    });\n    return isEIP1559Compatible;\n  }\n\n  async get1559CompatibilityWithNetworkClientId(\n    networkClientId: NetworkClientId,\n  ) {\n    let metadata = this.state.networksMetadata[networkClientId];\n    if (metadata === undefined) {\n      await this.lookupNetwork(networkClientId);\n      metadata = this.state.networksMetadata[networkClientId];\n    }\n    const { EIPS } = metadata;\n\n    // may want to include some 'freshness' value - something to make sure we refetch this from time to time\n    return EIPS[1559];\n  }\n\n  /**\n   * Retrieves and checks the latest block from the currently selected\n   * network; if the block has a `baseFeePerGas` property, then we know\n   * that the network supports EIP-1559; otherwise it doesn't.\n   *\n   * @param networkClientId - The networkClientId to fetch the correct provider against which to check 1559 compatibility\n   * @returns A promise that resolves to `true` if the network supports EIP-1559,\n   * `false` otherwise, or `undefined` if unable to retrieve the last block.\n   */\n  async #determineEIP1559Compatibility(\n    networkClientId: NetworkClientId,\n  ): Promise<boolean | undefined> {\n    const latestBlock = await this.#getLatestBlock(networkClientId);\n\n    if (!latestBlock) {\n      return undefined;\n    }\n\n    return latestBlock.baseFeePerGas !== undefined;\n  }\n\n  /**\n   * Re-initializes the provider and block tracker for the current network.\n   */\n  async resetConnection() {\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n    await this.#refreshNetwork();\n  }\n\n  /**\n   * Returns a configuration object for the network identified by the given\n   * network client ID. If given an Infura network type, constructs one based on\n   * what we know about the network; otherwise attempts locates a network\n   * configuration in state that corresponds to the network client ID.\n   *\n   * @param networkClientId - The network client ID.\n   * @returns The configuration for the referenced network if one exists, or\n   * undefined otherwise.\n   */\n  getNetworkConfigurationByNetworkClientId(\n    networkClientId: NetworkClientId,\n  ): NetworkConfiguration | undefined {\n    if (isInfuraNetworkType(networkClientId)) {\n      const rpcUrl = `https://${networkClientId}.infura.io/v3/${\n        this.#infuraProjectId\n      }`;\n      return {\n        rpcUrl,\n        ...BUILT_IN_NETWORKS[networkClientId],\n      };\n    }\n\n    return this.state.networkConfigurations[networkClientId];\n  }\n\n  /**\n   * Adds a new custom network or updates the information for an existing\n   * network.\n   *\n   * This may involve updating the `networkConfigurations` property in\n   * state as well and/or adding a new network client to the network client\n   * registry. The `rpcUrl` and `chainId` of the given object are used to\n   * determine which action to take:\n   *\n   * - If the `rpcUrl` corresponds to an existing network configuration\n   * (case-insensitively), then it is overwritten with the object. Furthermore,\n   * if the `chainId` is different from the existing network configuration, then\n   * the existing network client is replaced with a new one.\n   * - If the `rpcUrl` does not correspond to an existing network configuration\n   * (case-insensitively), then the object is used to add a new network\n   * configuration along with a new network client.\n   *\n   * @param networkConfiguration - The network configuration to add or update.\n   * @param options - Additional configuration options.\n   * @param options.referrer - Used to create a metrics event; the site from which the call originated, or 'metamask' for internal calls.\n   * @param options.source - Used to create a metrics event; where the event originated (i.e. from a dapp or from the network form).\n   * @param options.setActive - If true, switches to the network upon adding or updating it (default: false).\n   * @returns The ID for the added or updated network configuration.\n   */\n  async upsertNetworkConfiguration(\n    networkConfiguration: NetworkConfiguration,\n    {\n      referrer,\n      source,\n      setActive = false,\n    }: {\n      referrer: string;\n      source: string;\n      setActive?: boolean;\n    },\n  ): Promise<string> {\n    const sanitizedNetworkConfiguration: NetworkConfiguration = pick(\n      networkConfiguration,\n      ['rpcUrl', 'chainId', 'ticker', 'nickname', 'rpcPrefs'],\n    );\n    const { rpcUrl, chainId, ticker } = sanitizedNetworkConfiguration;\n\n    assertIsStrictHexString(chainId);\n    if (!isSafeChainId(chainId)) {\n      throw new Error(\n        `Invalid chain ID \"${chainId}\": numerical value greater than max safe value.`,\n      );\n    }\n    if (!rpcUrl) {\n      throw new Error(\n        'An rpcUrl is required to add or update network configuration',\n      );\n    }\n    if (!referrer || !source) {\n      throw new Error(\n        'referrer and source are required arguments for adding or updating a network configuration',\n      );\n    }\n    try {\n      new URL(rpcUrl);\n      // TODO: Replace `any` with type\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      if (e.message.includes('Invalid URL')) {\n        throw new Error('rpcUrl must be a valid URL');\n      }\n    }\n    if (!ticker) {\n      throw new Error(\n        'A ticker is required to add or update networkConfiguration',\n      );\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    const existingNetworkConfiguration = Object.values(\n      this.state.networkConfigurations,\n    ).find(\n      (networkConfig) =>\n        networkConfig.rpcUrl.toLowerCase() === rpcUrl.toLowerCase(),\n    );\n    const upsertedNetworkConfigurationId = existingNetworkConfiguration\n      ? existingNetworkConfiguration.id\n      : random();\n    const networkClientId = buildCustomNetworkClientId(\n      upsertedNetworkConfigurationId,\n    );\n\n    const customNetworkClientRegistry =\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom];\n    const existingAutoManagedNetworkClient =\n      customNetworkClientRegistry[networkClientId];\n    const shouldDestroyExistingNetworkClient =\n      existingAutoManagedNetworkClient &&\n      existingAutoManagedNetworkClient.configuration.chainId !== chainId;\n    if (shouldDestroyExistingNetworkClient) {\n      existingAutoManagedNetworkClient.destroy();\n    }\n    if (\n      !existingAutoManagedNetworkClient ||\n      shouldDestroyExistingNetworkClient\n    ) {\n      customNetworkClientRegistry[networkClientId] =\n        createAutoManagedNetworkClient({\n          type: NetworkClientType.Custom,\n          chainId,\n          rpcUrl,\n          ticker,\n        });\n    }\n\n    this.update((state) => {\n      state.networkConfigurations[upsertedNetworkConfigurationId] = {\n        id: upsertedNetworkConfigurationId,\n        ...sanitizedNetworkConfiguration,\n      };\n    });\n\n    if (!existingNetworkConfiguration) {\n      this.#trackMetaMetricsEvent({\n        event: 'Custom Network Added',\n        category: 'Network',\n        referrer: {\n          url: referrer,\n        },\n        properties: {\n          chain_id: chainId,\n          symbol: ticker,\n          source,\n        },\n      });\n    }\n\n    if (setActive) {\n      await this.setActiveNetwork(upsertedNetworkConfigurationId);\n    }\n\n    return upsertedNetworkConfigurationId;\n  }\n\n  /**\n   * Removes a custom network from state.\n   *\n   * This involves updating the `networkConfigurations` property in state as\n   * well and removing the network client that corresponds to the network from\n   * the client registry.\n   *\n   * @param networkConfigurationId - The ID of an existing network\n   * configuration.\n   */\n  removeNetworkConfiguration(networkConfigurationId: string) {\n    if (!this.state.networkConfigurations[networkConfigurationId]) {\n      throw new Error(\n        `networkConfigurationId ${networkConfigurationId} does not match a configured networkConfiguration`,\n      );\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n    const networkClientId = buildCustomNetworkClientId(networkConfigurationId);\n\n    this.update((state) => {\n      delete state.networkConfigurations[networkConfigurationId];\n    });\n\n    const customNetworkClientRegistry =\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom];\n    const existingAutoManagedNetworkClient =\n      customNetworkClientRegistry[networkClientId];\n    existingAutoManagedNetworkClient.destroy();\n    delete customNetworkClientRegistry[networkClientId];\n  }\n\n  /**\n   * Switches to the previously selected network, assuming that there is one\n   * (if not and `initializeProvider` has not been previously called, then this\n   * method is equivalent to calling `resetConnection`).\n   */\n  async rollbackToPreviousProvider() {\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.update((state) => {\n      state.providerConfig = this.#previousProviderConfig;\n    });\n\n    await this.#refreshNetwork();\n  }\n\n  /**\n   * Deactivates the controller, stopping any ongoing polling.\n   *\n   * In-progress requests will not be aborted.\n   */\n  async destroy() {\n    await this.#blockTrackerProxy?.destroy();\n  }\n\n  /**\n   * Updates the controller using the given backup data.\n   *\n   * @param backup - The data that has been backed up.\n   * @param backup.networkConfigurations - Network configurations in the backup.\n   */\n  loadBackup({\n    networkConfigurations,\n  }: {\n    networkConfigurations: NetworkState['networkConfigurations'];\n  }): void {\n    this.update((state) => {\n      state.networkConfigurations = {\n        ...state.networkConfigurations,\n        ...networkConfigurations,\n      };\n    });\n  }\n\n  /**\n   * Searches for a network configuration ID with the given ChainID and returns it.\n   *\n   * @param chainId - ChainId to search for\n   * @returns networkClientId of the network configuration with the given chainId\n   */\n  findNetworkClientIdByChainId(chainId: Hex): NetworkClientId {\n    const networkClients = this.getNetworkClientRegistry();\n    const networkClientEntry = Object.entries(networkClients).find(\n      ([_, networkClient]) => networkClient.configuration.chainId === chainId,\n    );\n    if (networkClientEntry === undefined) {\n      throw new Error(\"Couldn't find networkClientId for chainId\");\n    }\n    return networkClientEntry[0];\n  }\n\n  /**\n   * Before accessing or switching the network, the registry of network clients\n   * needs to be populated. Otherwise, `#applyNetworkSelection` and\n   * `getNetworkClientRegistry` will throw an error. This method checks to see if the\n   * population step has happened yet, and if not, makes it happen.\n   *\n   * @returns The populated network client registry.\n   */\n  #ensureAutoManagedNetworkClientRegistryPopulated(): AutoManagedNetworkClientRegistry {\n    const autoManagedNetworkClientRegistry =\n      this.#autoManagedNetworkClientRegistry ??\n      this.#createAutoManagedNetworkClientRegistry();\n    this.#autoManagedNetworkClientRegistry = autoManagedNetworkClientRegistry;\n    return autoManagedNetworkClientRegistry;\n  }\n\n  /**\n   * Constructs the registry of network clients based on the set of built-in\n   * networks as well as the custom networks in state.\n   *\n   * @returns The network clients keyed by ID.\n   */\n  #createAutoManagedNetworkClientRegistry(): AutoManagedNetworkClientRegistry {\n    return [\n      ...this.#buildIdentifiedInfuraNetworkClientConfigurations(),\n      ...this.#buildIdentifiedCustomNetworkClientConfigurations(),\n      ...this.#buildIdentifiedNetworkClientConfigurationsFromProviderConfig(),\n    ].reduce(\n      (\n        registry,\n        [networkClientType, networkClientId, networkClientConfiguration],\n      ) => {\n        const autoManagedNetworkClient = createAutoManagedNetworkClient(\n          networkClientConfiguration,\n        );\n        if (networkClientId in registry[networkClientType]) {\n          return registry;\n        }\n        return {\n          ...registry,\n          [networkClientType]: {\n            ...registry[networkClientType],\n            [networkClientId]: autoManagedNetworkClient,\n          },\n        };\n      },\n      {\n        [NetworkClientType.Infura]: {},\n        [NetworkClientType.Custom]: {},\n      },\n    ) as AutoManagedNetworkClientRegistry;\n  }\n\n  /**\n   * Constructs the list of network clients for built-in networks (that is,\n   * the subset of the networks we know Infura supports that consumers do not\n   * need to explicitly add).\n   *\n   * @returns The network clients.\n   */\n  #buildIdentifiedInfuraNetworkClientConfigurations(): [\n    NetworkClientType.Infura,\n    BuiltInNetworkClientId,\n    InfuraNetworkClientConfiguration,\n  ][] {\n    return knownKeysOf(InfuraNetworkType).map((network) => {\n      const networkClientId = buildInfuraNetworkClientId(network);\n      const networkClientConfiguration: InfuraNetworkClientConfiguration = {\n        type: NetworkClientType.Infura,\n        network,\n        infuraProjectId: this.#infuraProjectId,\n        chainId: BUILT_IN_NETWORKS[network].chainId,\n        ticker: BUILT_IN_NETWORKS[network].ticker,\n      };\n      return [\n        NetworkClientType.Infura,\n        networkClientId,\n        networkClientConfiguration,\n      ];\n    });\n  }\n\n  /**\n   * Constructs the list of network clients for custom networks (that is, those\n   * which consumers have added via `networkConfigurations`).\n   *\n   * @returns The network clients.\n   */\n  #buildIdentifiedCustomNetworkClientConfigurations(): [\n    NetworkClientType.Custom,\n    CustomNetworkClientId,\n    CustomNetworkClientConfiguration,\n  ][] {\n    return Object.entries(this.state.networkConfigurations).map(\n      ([networkConfigurationId, networkConfiguration]) => {\n        if (networkConfiguration.chainId === undefined) {\n          throw new Error('chainId must be provided for custom RPC endpoints');\n        }\n        if (networkConfiguration.rpcUrl === undefined) {\n          throw new Error('rpcUrl must be provided for custom RPC endpoints');\n        }\n        const networkClientId = buildCustomNetworkClientId(\n          networkConfigurationId,\n        );\n        const networkClientConfiguration: CustomNetworkClientConfiguration = {\n          type: NetworkClientType.Custom,\n          chainId: networkConfiguration.chainId,\n          rpcUrl: networkConfiguration.rpcUrl,\n          ticker: networkConfiguration.ticker,\n        };\n        return [\n          NetworkClientType.Custom,\n          networkClientId,\n          networkClientConfiguration,\n        ];\n      },\n    );\n  }\n\n  /**\n   * Converts the provider config object in state to a network client\n   * configuration object.\n   *\n   * @returns The network client config.\n   * @throws If the provider config is of type \"rpc\" and lacks either a\n   * `chainId` or an `rpcUrl`.\n   */\n  #buildIdentifiedNetworkClientConfigurationsFromProviderConfig():\n    | [\n        [\n          NetworkClientType.Custom,\n          CustomNetworkClientId,\n          CustomNetworkClientConfiguration,\n        ],\n      ]\n    | [] {\n    const { providerConfig } = this.state;\n\n    if (isCustomProviderConfig(providerConfig)) {\n      validateCustomProviderConfig(providerConfig);\n      const networkClientId = buildCustomNetworkClientId(\n        providerConfig,\n        this.state.networkConfigurations,\n      );\n      const networkClientConfiguration: CustomNetworkClientConfiguration = {\n        chainId: providerConfig.chainId,\n        rpcUrl: providerConfig.rpcUrl,\n        type: NetworkClientType.Custom,\n        ticker: providerConfig.ticker,\n      };\n      return [\n        [NetworkClientType.Custom, networkClientId, networkClientConfiguration],\n      ];\n    }\n\n    if (isInfuraProviderConfig(providerConfig)) {\n      return [];\n    }\n\n    throw new Error(`Unrecognized network type: '${providerConfig.type}'`);\n  }\n\n  /**\n   * Uses the information in the provider config object to look up a known and\n   * preinitialized network client. Once a network client is found, updates the\n   * provider and block tracker proxy to point to those from the network client,\n   * then finally creates an EthQuery that points to the provider proxy.\n   *\n   * @throws If no network client could be found matching the current provider\n   * config.\n   */\n  #applyNetworkSelection() {\n    if (!this.#autoManagedNetworkClientRegistry) {\n      throw new Error(\n        'initializeProvider must be called first in order to switch the network',\n      );\n    }\n\n    const { providerConfig } = this.state;\n\n    let autoManagedNetworkClient: AutoManagedNetworkClient<NetworkClientConfiguration>;\n\n    let networkClientId: NetworkClientId;\n    if (isInfuraProviderConfig(providerConfig)) {\n      const networkClientType = NetworkClientType.Infura;\n      networkClientId = buildInfuraNetworkClientId(providerConfig);\n      const builtInNetworkClientRegistry =\n        this.#autoManagedNetworkClientRegistry[networkClientType];\n      autoManagedNetworkClient =\n        builtInNetworkClientRegistry[networkClientId as BuiltInNetworkClientId];\n      if (!autoManagedNetworkClient) {\n        throw new Error(\n          `Could not find custom network matching ${networkClientId}`,\n        );\n      }\n    } else if (isCustomProviderConfig(providerConfig)) {\n      validateCustomProviderConfig(providerConfig);\n      const networkClientType = NetworkClientType.Custom;\n      networkClientId = buildCustomNetworkClientId(\n        providerConfig,\n        this.state.networkConfigurations,\n      );\n      const customNetworkClientRegistry =\n        this.#autoManagedNetworkClientRegistry[networkClientType];\n      autoManagedNetworkClient = customNetworkClientRegistry[networkClientId];\n      if (!autoManagedNetworkClient) {\n        throw new Error(\n          `Could not find built-in network matching ${networkClientId}`,\n        );\n      }\n    } else {\n      throw new Error('Could not determine type of provider config');\n    }\n\n    this.update((state) => {\n      state.selectedNetworkClientId = networkClientId;\n      if (state.networksMetadata[networkClientId] === undefined) {\n        state.networksMetadata[networkClientId] = {\n          status: NetworkStatus.Unknown,\n          EIPS: {},\n        };\n      }\n    });\n\n    const { provider, blockTracker } = autoManagedNetworkClient;\n\n    if (this.#providerProxy) {\n      this.#providerProxy.setTarget(provider);\n    } else {\n      this.#providerProxy = createEventEmitterProxy(provider);\n    }\n\n    if (this.#blockTrackerProxy) {\n      this.#blockTrackerProxy.setTarget(blockTracker);\n    } else {\n      this.#blockTrackerProxy = createEventEmitterProxy(blockTracker, {\n        eventFilter: 'skipInternal',\n      });\n    }\n\n    this.#ethQuery = new EthQuery(this.#providerProxy);\n  }\n}\n"],"mappings":"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","names":[]}
\ No newline at end of file
diff --git a/dist/index.js b/dist/index.js
index 0b9f596a1c5578661119cde327659b34b74098bf..d557db2b2c8587e15d6bff1de06bbaad681156c8 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -2,7 +2,7 @@
 
 
 
-var _chunk4ZD3DTQ7js = require('./chunk-4ZD3DTQ7.js');
+var _chunkPC5HTMUEjs = require('./chunk-PC5HTMUE.js');
 
 
 
@@ -21,5 +21,5 @@ require('./chunk-Z4BLTVTB.js');
 
 
 
-exports.INFURA_BLOCKED_KEY = _chunkZKNI7MD3js.INFURA_BLOCKED_KEY; exports.NetworkClientType = _chunkKHZTS7TFjs.NetworkClientType; exports.NetworkController = _chunk4ZD3DTQ7js.NetworkController; exports.NetworkStatus = _chunkZKNI7MD3js.NetworkStatus; exports.defaultState = _chunk4ZD3DTQ7js.defaultState; exports.knownKeysOf = _chunk4ZD3DTQ7js.knownKeysOf;
+exports.INFURA_BLOCKED_KEY = _chunkZKNI7MD3js.INFURA_BLOCKED_KEY; exports.NetworkClientType = _chunkKHZTS7TFjs.NetworkClientType; exports.NetworkController = _chunkPC5HTMUEjs.NetworkController; exports.NetworkStatus = _chunkZKNI7MD3js.NetworkStatus; exports.defaultState = _chunkPC5HTMUEjs.defaultState; exports.knownKeysOf = _chunkPC5HTMUEjs.knownKeysOf;
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/dist/index.mjs b/dist/index.mjs
index 6ffee6a778d284fa495ccae61fb85d1bb0cec078..46f1b1f8e003966853717df79bf37e942ee86c9f 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -2,7 +2,7 @@ import {
   NetworkController,
   defaultState,
   knownKeysOf
-} from "./chunk-UG2NYGJD.mjs";
+} from "./chunk-6EXWS63D.mjs";
 import {
   INFURA_BLOCKED_KEY,
   NetworkStatus
diff --git a/dist/tsconfig.build.tsbuildinfo b/dist/tsconfig.build.tsbuildinfo
index 6213b054b05eb6d05e69866be4ef4490340c7be2..46cbdf2e9a5701b1a39a444e7e775e3bfbbab396 100644
--- a/dist/tsconfig.build.tsbuildinfo
+++ b/dist/tsconfig.build.tsbuildinfo
@@ -1 +1 @@
-{"program":{"fileNames":["../../../node_modules/typescript/lib/lib.es5.d.ts","../../../node_modules/typescript/lib/lib.es2015.d.ts","../../../node_modules/typescript/lib/lib.es2016.d.ts","../../../node_modules/typescript/lib/lib.es2017.d.ts","../../../node_modules/typescript/lib/lib.es2018.d.ts","../../../node_modules/typescript/lib/lib.es2019.d.ts","../../../node_modules/typescript/lib/lib.es2020.d.ts","../../../node_modules/typescript/lib/lib.dom.d.ts","../../../node_modules/typescript/lib/lib.es2015.core.d.ts","../../../node_modules/typescript/lib/lib.es2015.collection.d.ts","../../../node_modules/typescript/lib/lib.es2015.generator.d.ts","../../../node_modules/typescript/lib/lib.es2015.iterable.d.ts","../../../node_modules/typescript/lib/lib.es2015.promise.d.ts","../../../node_modules/typescript/lib/lib.es2015.proxy.d.ts","../../../node_modules/typescript/lib/lib.es2015.reflect.d.ts","../../../node_modules/typescript/lib/lib.es2015.symbol.d.ts","../../../node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts","../../../node_modules/typescript/lib/lib.es2016.array.include.d.ts","../../../node_modules/typescript/lib/lib.es2017.object.d.ts","../../../node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2017.string.d.ts","../../../node_modules/typescript/lib/lib.es2017.intl.d.ts","../../../node_modules/typescript/lib/lib.es2017.typedarrays.d.ts","../../../node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts","../../../node_modules/typescript/lib/lib.es2018.asynciterable.d.ts","../../../node_modules/typescript/lib/lib.es2018.intl.d.ts","../../../node_modules/typescript/lib/lib.es2018.promise.d.ts","../../../node_modules/typescript/lib/lib.es2018.regexp.d.ts","../../../node_modules/typescript/lib/lib.es2019.array.d.ts","../../../node_modules/typescript/lib/lib.es2019.object.d.ts","../../../node_modules/typescript/lib/lib.es2019.string.d.ts","../../../node_modules/typescript/lib/lib.es2019.symbol.d.ts","../../../node_modules/typescript/lib/lib.es2019.intl.d.ts","../../../node_modules/typescript/lib/lib.es2020.bigint.d.ts","../../../node_modules/typescript/lib/lib.es2020.date.d.ts","../../../node_modules/typescript/lib/lib.es2020.promise.d.ts","../../../node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2020.string.d.ts","../../../node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts","../../../node_modules/typescript/lib/lib.es2020.intl.d.ts","../../../node_modules/typescript/lib/lib.es2020.number.d.ts","../../../node_modules/typescript/lib/lib.esnext.intl.d.ts","../../../types/eth-ens-namehash.d.ts","../../../types/ethereum-ens-network-map.d.ts","../../../types/global.d.ts","../../../types/single-call-balance-checker-abi.d.ts","../../../types/@metamask/contract-metadata.d.ts","../../../types/@metamask/eth-hd-keyring.d.ts","../../../types/@metamask/eth-simple-keyring.d.ts","../../../types/@metamask/ethjs-provider-http.d.ts","../../../types/@metamask/ethjs-unit.d.ts","../../../types/@metamask/metamask-eth-abis.d.ts","../../../types/eth-json-rpc-infura/src/createProvider.d.ts","../../../types/eth-phishing-detect/src/config.json.d.ts","../../../types/eth-phishing-detect/src/detector.d.ts","../../base-controller/dist/types/BaseControllerV1.d.ts","../../../node_modules/superstruct/dist/error.d.ts","../../../node_modules/superstruct/dist/utils.d.ts","../../../node_modules/superstruct/dist/struct.d.ts","../../../node_modules/superstruct/dist/structs/coercions.d.ts","../../../node_modules/superstruct/dist/structs/refinements.d.ts","../../../node_modules/superstruct/dist/structs/types.d.ts","../../../node_modules/superstruct/dist/structs/utilities.d.ts","../../../node_modules/superstruct/dist/index.d.ts","../../../node_modules/@metamask/utils/dist/types/assert.d.ts","../../../node_modules/@metamask/utils/dist/types/base64.d.ts","../../../node_modules/@metamask/utils/dist/types/hex.d.ts","../../../node_modules/@metamask/utils/dist/types/bytes.d.ts","../../../node_modules/@metamask/utils/dist/types/caip-types.d.ts","../../../node_modules/@metamask/utils/dist/types/checksum.d.ts","../../../node_modules/@metamask/utils/dist/types/coercers.d.ts","../../../node_modules/@metamask/utils/dist/types/collections.d.ts","../../../node_modules/@metamask/utils/dist/types/encryption-types.d.ts","../../../node_modules/@metamask/utils/dist/types/errors.d.ts","../../../node_modules/@metamask/utils/dist/types/json.d.ts","../../../node_modules/@types/node/assert.d.ts","../../../node_modules/@types/node/assert/strict.d.ts","../../../node_modules/@types/node/globals.d.ts","../../../node_modules/@types/node/async_hooks.d.ts","../../../node_modules/@types/node/buffer.d.ts","../../../node_modules/@types/node/child_process.d.ts","../../../node_modules/@types/node/cluster.d.ts","../../../node_modules/@types/node/console.d.ts","../../../node_modules/@types/node/constants.d.ts","../../../node_modules/@types/node/crypto.d.ts","../../../node_modules/@types/node/dgram.d.ts","../../../node_modules/@types/node/diagnostics_channel.d.ts","../../../node_modules/@types/node/dns.d.ts","../../../node_modules/@types/node/dns/promises.d.ts","../../../node_modules/@types/node/dom-events.d.ts","../../../node_modules/@types/node/domain.d.ts","../../../node_modules/@types/node/events.d.ts","../../../node_modules/@types/node/fs.d.ts","../../../node_modules/@types/node/fs/promises.d.ts","../../../node_modules/@types/node/http.d.ts","../../../node_modules/@types/node/http2.d.ts","../../../node_modules/@types/node/https.d.ts","../../../node_modules/@types/node/inspector.d.ts","../../../node_modules/@types/node/module.d.ts","../../../node_modules/@types/node/net.d.ts","../../../node_modules/@types/node/os.d.ts","../../../node_modules/@types/node/path.d.ts","../../../node_modules/@types/node/perf_hooks.d.ts","../../../node_modules/@types/node/process.d.ts","../../../node_modules/@types/node/punycode.d.ts","../../../node_modules/@types/node/querystring.d.ts","../../../node_modules/@types/node/readline.d.ts","../../../node_modules/@types/node/repl.d.ts","../../../node_modules/@types/node/stream.d.ts","../../../node_modules/@types/node/stream/promises.d.ts","../../../node_modules/@types/node/stream/consumers.d.ts","../../../node_modules/@types/node/stream/web.d.ts","../../../node_modules/@types/node/string_decoder.d.ts","../../../node_modules/@types/node/test.d.ts","../../../node_modules/@types/node/timers.d.ts","../../../node_modules/@types/node/timers/promises.d.ts","../../../node_modules/@types/node/tls.d.ts","../../../node_modules/@types/node/trace_events.d.ts","../../../node_modules/@types/node/tty.d.ts","../../../node_modules/@types/node/url.d.ts","../../../node_modules/@types/node/util.d.ts","../../../node_modules/@types/node/v8.d.ts","../../../node_modules/@types/node/vm.d.ts","../../../node_modules/@types/node/wasi.d.ts","../../../node_modules/@types/node/worker_threads.d.ts","../../../node_modules/@types/node/zlib.d.ts","../../../node_modules/@types/node/globals.global.d.ts","../../../node_modules/@types/node/index.d.ts","../../../node_modules/@ethereumjs/common/dist/enums.d.ts","../../../node_modules/@ethereumjs/common/dist/types.d.ts","../../../node_modules/buffer/index.d.ts","../../../node_modules/@ethereumjs/util/dist/constants.d.ts","../../../node_modules/@ethereumjs/util/dist/units.d.ts","../../../node_modules/@ethereumjs/util/dist/address.d.ts","../../../node_modules/@ethereumjs/util/dist/bytes.d.ts","../../../node_modules/@ethereumjs/util/dist/types.d.ts","../../../node_modules/@ethereumjs/util/dist/account.d.ts","../../../node_modules/@ethereumjs/util/dist/withdrawal.d.ts","../../../node_modules/@ethereumjs/util/dist/signature.d.ts","../../../node_modules/@ethereumjs/util/dist/encoding.d.ts","../../../node_modules/@ethereumjs/util/dist/asyncEventEmitter.d.ts","../../../node_modules/@ethereumjs/util/dist/internal.d.ts","../../../node_modules/@ethereumjs/util/dist/lock.d.ts","../../../node_modules/@ethereumjs/util/dist/provider.d.ts","../../../node_modules/@ethereumjs/util/dist/index.d.ts","../../../node_modules/@ethereumjs/common/dist/common.d.ts","../../../node_modules/@ethereumjs/common/dist/utils.d.ts","../../../node_modules/@ethereumjs/common/dist/index.d.ts","../../../node_modules/@ethereumjs/tx/dist/eip2930Transaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/legacyTransaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/types.d.ts","../../../node_modules/@ethereumjs/tx/dist/baseTransaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/eip1559Transaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/transactionFactory.d.ts","../../../node_modules/@ethereumjs/tx/dist/index.d.ts","../../../node_modules/@metamask/utils/dist/types/keyring.d.ts","../../../node_modules/@types/ms/index.d.ts","../../../node_modules/@types/debug/index.d.ts","../../../node_modules/@metamask/utils/dist/types/logging.d.ts","../../../node_modules/@metamask/utils/dist/types/misc.d.ts","../../../node_modules/@metamask/utils/dist/types/number.d.ts","../../../node_modules/@metamask/utils/dist/types/opaque.d.ts","../../../node_modules/@metamask/utils/dist/types/promise.d.ts","../../../node_modules/@metamask/utils/dist/types/time.d.ts","../../../node_modules/@metamask/utils/dist/types/transaction-types.d.ts","../../../node_modules/@metamask/utils/dist/types/versions.d.ts","../../../node_modules/@metamask/utils/dist/types/index.d.ts","../../../node_modules/immer/dist/utils/env.d.ts","../../../node_modules/immer/dist/utils/errors.d.ts","../../../node_modules/immer/dist/types/types-external.d.ts","../../../node_modules/immer/dist/types/types-internal.d.ts","../../../node_modules/immer/dist/utils/common.d.ts","../../../node_modules/immer/dist/utils/plugins.d.ts","../../../node_modules/immer/dist/core/scope.d.ts","../../../node_modules/immer/dist/core/finalize.d.ts","../../../node_modules/immer/dist/core/proxy.d.ts","../../../node_modules/immer/dist/core/immerClass.d.ts","../../../node_modules/immer/dist/core/current.d.ts","../../../node_modules/immer/dist/internal.d.ts","../../../node_modules/immer/dist/plugins/es5.d.ts","../../../node_modules/immer/dist/plugins/patches.d.ts","../../../node_modules/immer/dist/plugins/mapset.d.ts","../../../node_modules/immer/dist/plugins/all.d.ts","../../../node_modules/immer/dist/immer.d.ts","../../base-controller/dist/types/RestrictedControllerMessenger.d.ts","../../base-controller/dist/types/ControllerMessenger.d.ts","../../base-controller/dist/types/BaseControllerV2.d.ts","../../base-controller/dist/types/index.d.ts","../../controller-utils/dist/types/types.d.ts","../../controller-utils/dist/types/constants.d.ts","../../../node_modules/@metamask/eth-query/index.d.ts","../../../node_modules/@types/bn.js/index.d.ts","../../controller-utils/dist/types/util.d.ts","../../../node_modules/@spruceid/siwe-parser/dist/abnf.d.ts","../../../node_modules/@spruceid/siwe-parser/dist/utils.d.ts","../../../node_modules/@spruceid/siwe-parser/dist/parsers.d.ts","../../controller-utils/dist/types/siwe.d.ts","../../controller-utils/dist/types/index.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/utils.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/classes.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/errors.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/error-constants.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/index.d.ts","../../../node_modules/@metamask/swappable-obj-proxy/dist/types.d.ts","../../../node_modules/@metamask/swappable-obj-proxy/dist/createEventEmitterProxy.d.ts","../../../node_modules/@metamask/swappable-obj-proxy/dist/createSwappableProxy.d.ts","../../../node_modules/@metamask/swappable-obj-proxy/dist/index.d.ts","../../../node_modules/@types/uuid/index.d.ts","../src/constants.ts","../../../node_modules/@metamask/safe-event-emitter/dist/cjs/index.d.ts","../../json-rpc-engine/dist/types/JsonRpcEngine.d.ts","../../json-rpc-engine/dist/types/createAsyncMiddleware.d.ts","../../json-rpc-engine/dist/types/createScaffoldMiddleware.d.ts","../../json-rpc-engine/dist/types/getUniqueId.d.ts","../../json-rpc-engine/dist/types/idRemapMiddleware.d.ts","../../json-rpc-engine/dist/types/mergeMiddleware.d.ts","../../json-rpc-engine/dist/types/index.d.ts","../../eth-json-rpc-provider/dist/types/safe-event-emitter-provider.d.ts","../../eth-json-rpc-provider/dist/types/provider-from-engine.d.ts","../../eth-json-rpc-provider/dist/types/provider-from-middleware.d.ts","../../eth-json-rpc-provider/dist/types/index.d.ts","../../../node_modules/@metamask/eth-block-tracker/dist/BlockTracker.d.ts","../../../node_modules/@metamask/eth-block-tracker/dist/PollingBlockTracker.d.ts","../../../node_modules/@metamask/eth-block-tracker/dist/SubscribeBlockTracker.d.ts","../../../node_modules/@metamask/eth-block-tracker/dist/index.d.ts","../../../node_modules/@metamask/eth-json-rpc-infura/dist/types.d.ts","../../../node_modules/@metamask/eth-json-rpc-infura/dist/create-infura-middleware.d.ts","../../../node_modules/@metamask/eth-json-rpc-infura/dist/fetch-config-from-req.d.ts","../../../node_modules/@metamask/eth-json-rpc-infura/dist/create-provider.d.ts","../../../node_modules/@metamask/eth-json-rpc-infura/dist/index.d.ts","../../../node_modules/@metamask/eth-json-rpc-middleware/dist/types.d.ts","../../../node_modules/@metamask/eth-json-rpc-middleware/dist/block-cache.d.ts","../../../node_modules/@metamask/eth-json-rpc-middleware/dist/block-ref-rewrite.d.ts","../../../node_modules/@metamask/eth-json-rpc-middleware/dist/block-ref.d.ts","../../../node_modules/@metamask/eth-json-rpc-middleware/dist/block-tracker-inspector.d.ts","../../../node_modules/@metamask/eth-json-rpc-middleware/dist/fetch.d.ts","../../../node_modules/@metamask/eth-json-rpc-middleware/dist/inflight-cache.d.ts","../../../node_modules/@metamask/eth-json-rpc-middleware/dist/providerAsMiddleware.d.ts","../../../node_modules/@metamask/eth-json-rpc-middleware/dist/retryOnEmpty.d.ts","../../../node_modules/@metamask/eth-json-rpc-middleware/dist/wallet.d.ts","../../../node_modules/@metamask/eth-json-rpc-middleware/dist/index.d.ts","../src/types.ts","../src/create-network-client.ts","../src/create-auto-managed-network-client.ts","../src/logger.ts","../src/NetworkController.ts","../src/index.ts","../../../node_modules/@babel/types/lib/index.d.ts","../../../node_modules/@types/babel__generator/index.d.ts","../../../node_modules/@babel/parser/typings/babel-parser.d.ts","../../../node_modules/@types/babel__template/index.d.ts","../../../node_modules/@types/babel__traverse/index.d.ts","../../../node_modules/@types/babel__core/index.d.ts","../../../node_modules/@types/deep-freeze-strict/index.d.ts","../../../node_modules/@types/eslint/helpers.d.ts","../../../node_modules/@types/estree/index.d.ts","../../../node_modules/@types/json-schema/index.d.ts","../../../node_modules/@types/eslint/index.d.ts","../../../node_modules/@types/graceful-fs/index.d.ts","../../../node_modules/@types/istanbul-lib-coverage/index.d.ts","../../../node_modules/@types/istanbul-lib-report/index.d.ts","../../../node_modules/@types/istanbul-reports/index.d.ts","../../../node_modules/chalk/index.d.ts","../../../node_modules/jest-diff/build/cleanupSemantic.d.ts","../../../node_modules/pretty-format/build/types.d.ts","../../../node_modules/pretty-format/build/index.d.ts","../../../node_modules/jest-diff/build/types.d.ts","../../../node_modules/jest-diff/build/diffLines.d.ts","../../../node_modules/jest-diff/build/printDiffs.d.ts","../../../node_modules/jest-diff/build/index.d.ts","../../../node_modules/jest-matcher-utils/build/index.d.ts","../../../node_modules/@types/jest/index.d.ts","../../../node_modules/@types/jest-when/index.d.ts","../../../node_modules/@types/json5/index.d.ts","../../../node_modules/@types/lodash/common/common.d.ts","../../../node_modules/@types/lodash/common/array.d.ts","../../../node_modules/@types/lodash/common/collection.d.ts","../../../node_modules/@types/lodash/common/date.d.ts","../../../node_modules/@types/lodash/common/function.d.ts","../../../node_modules/@types/lodash/common/lang.d.ts","../../../node_modules/@types/lodash/common/math.d.ts","../../../node_modules/@types/lodash/common/number.d.ts","../../../node_modules/@types/lodash/common/object.d.ts","../../../node_modules/@types/lodash/common/seq.d.ts","../../../node_modules/@types/lodash/common/string.d.ts","../../../node_modules/@types/lodash/common/util.d.ts","../../../node_modules/@types/lodash/index.d.ts","../../../node_modules/@types/minimatch/index.d.ts","../../../node_modules/@types/parse-json/index.d.ts","../../../node_modules/@types/pbkdf2/index.d.ts","../../../node_modules/@types/prettier/index.d.ts","../../../node_modules/@types/punycode/index.d.ts","../../../node_modules/@types/readable-stream/node_modules/safe-buffer/index.d.ts","../../../node_modules/@types/readable-stream/index.d.ts","../../../node_modules/@types/secp256k1/index.d.ts","../../../node_modules/@types/semver/classes/semver.d.ts","../../../node_modules/@types/semver/functions/parse.d.ts","../../../node_modules/@types/semver/functions/valid.d.ts","../../../node_modules/@types/semver/functions/clean.d.ts","../../../node_modules/@types/semver/functions/inc.d.ts","../../../node_modules/@types/semver/functions/diff.d.ts","../../../node_modules/@types/semver/functions/major.d.ts","../../../node_modules/@types/semver/functions/minor.d.ts","../../../node_modules/@types/semver/functions/patch.d.ts","../../../node_modules/@types/semver/functions/prerelease.d.ts","../../../node_modules/@types/semver/functions/compare.d.ts","../../../node_modules/@types/semver/functions/rcompare.d.ts","../../../node_modules/@types/semver/functions/compare-loose.d.ts","../../../node_modules/@types/semver/functions/compare-build.d.ts","../../../node_modules/@types/semver/functions/sort.d.ts","../../../node_modules/@types/semver/functions/rsort.d.ts","../../../node_modules/@types/semver/functions/gt.d.ts","../../../node_modules/@types/semver/functions/lt.d.ts","../../../node_modules/@types/semver/functions/eq.d.ts","../../../node_modules/@types/semver/functions/neq.d.ts","../../../node_modules/@types/semver/functions/gte.d.ts","../../../node_modules/@types/semver/functions/lte.d.ts","../../../node_modules/@types/semver/functions/cmp.d.ts","../../../node_modules/@types/semver/functions/coerce.d.ts","../../../node_modules/@types/semver/classes/comparator.d.ts","../../../node_modules/@types/semver/classes/range.d.ts","../../../node_modules/@types/semver/functions/satisfies.d.ts","../../../node_modules/@types/semver/ranges/max-satisfying.d.ts","../../../node_modules/@types/semver/ranges/min-satisfying.d.ts","../../../node_modules/@types/semver/ranges/to-comparators.d.ts","../../../node_modules/@types/semver/ranges/min-version.d.ts","../../../node_modules/@types/semver/ranges/valid.d.ts","../../../node_modules/@types/semver/ranges/outside.d.ts","../../../node_modules/@types/semver/ranges/gtr.d.ts","../../../node_modules/@types/semver/ranges/ltr.d.ts","../../../node_modules/@types/semver/ranges/intersects.d.ts","../../../node_modules/@types/semver/ranges/simplify.d.ts","../../../node_modules/@types/semver/ranges/subset.d.ts","../../../node_modules/@types/semver/internals/identifiers.d.ts","../../../node_modules/@types/semver/index.d.ts","../../../node_modules/@types/sinonjs__fake-timers/index.d.ts","../../../node_modules/@types/sinon/index.d.ts","../../../node_modules/@types/stack-utils/index.d.ts","../../../node_modules/@types/yargs-parser/index.d.ts","../../../node_modules/@types/yargs/index.d.ts"],"fileInfos":[{"version":"8730f4bf322026ff5229336391a18bcaa1f94d4f82416c8b2f3954e2ccaae2ba","affectsGlobalScope":true},"dc47c4fa66b9b9890cf076304de2a9c5201e94b740cffdf09f87296d877d71f6","7a387c58583dfca701b6c85e0adaf43fb17d590fb16d5b2dc0a2fbd89f35c467","8a12173c586e95f4433e0c6dc446bc88346be73ffe9ca6eec7aa63c8f3dca7f9","5f4e733ced4e129482ae2186aae29fde948ab7182844c3a5a51dd346182c7b06","4b421cbfb3a38a27c279dec1e9112c3d1da296f77a1a85ddadf7e7a425d45d18","1fc5ab7a764205c68fa10d381b08417795fc73111d6dd16b5b1ed36badb743d9",{"version":"3aafcb693fe5b5c3bd277bd4c3a617b53db474fe498fc5df067c5603b1eebde7","affectsGlobalScope":true},{"version":"adb996790133eb33b33aadb9c09f15c2c575e71fb57a62de8bf74dbf59ec7dfb","affectsGlobalScope":true},{"version":"8cc8c5a3bac513368b0157f3d8b31cfdcfe78b56d3724f30f80ed9715e404af8","affectsGlobalScope":true},{"version":"cdccba9a388c2ee3fd6ad4018c640a471a6c060e96f1232062223063b0a5ac6a","affectsGlobalScope":true},{"version":"c5c05907c02476e4bde6b7e76a79ffcd948aedd14b6a8f56e4674221b0417398","affectsGlobalScope":true},{"version":"5f406584aef28a331c36523df688ca3650288d14f39c5d2e555c95f0d2ff8f6f","affectsGlobalScope":true},{"version":"22f230e544b35349cfb3bd9110b6ef37b41c6d6c43c3314a31bd0d9652fcec72","affectsGlobalScope":true},{"version":"7ea0b55f6b315cf9ac2ad622b0a7813315bb6e97bf4bb3fbf8f8affbca7dc695","affectsGlobalScope":true},{"version":"3013574108c36fd3aaca79764002b3717da09725a36a6fc02eac386593110f93","affectsGlobalScope":true},{"version":"eb26de841c52236d8222f87e9e6a235332e0788af8c87a71e9e210314300410a","affectsGlobalScope":true},{"version":"3be5a1453daa63e031d266bf342f3943603873d890ab8b9ada95e22389389006","affectsGlobalScope":true},{"version":"17bb1fc99591b00515502d264fa55dc8370c45c5298f4a5c2083557dccba5a2a","affectsGlobalScope":true},{"version":"7ce9f0bde3307ca1f944119f6365f2d776d281a393b576a18a2f2893a2d75c98","affectsGlobalScope":true},{"version":"6a6b173e739a6a99629a8594bfb294cc7329bfb7b227f12e1f7c11bc163b8577","affectsGlobalScope":true},{"version":"81cac4cbc92c0c839c70f8ffb94eb61e2d32dc1c3cf6d95844ca099463cf37ea","affectsGlobalScope":true},{"version":"b0124885ef82641903d232172577f2ceb5d3e60aed4da1153bab4221e1f6dd4e","affectsGlobalScope":true},{"version":"0eb85d6c590b0d577919a79e0084fa1744c1beba6fd0d4e951432fa1ede5510a","affectsGlobalScope":true},{"version":"da233fc1c8a377ba9e0bed690a73c290d843c2c3d23a7bd7ec5cd3d7d73ba1e0","affectsGlobalScope":true},{"version":"d154ea5bb7f7f9001ed9153e876b2d5b8f5c2bb9ec02b3ae0d239ec769f1f2ae","affectsGlobalScope":true},{"version":"bb2d3fb05a1d2ffbca947cc7cbc95d23e1d053d6595391bd325deb265a18d36c","affectsGlobalScope":true},{"version":"c80df75850fea5caa2afe43b9949338ce4e2de086f91713e9af1a06f973872b8","affectsGlobalScope":true},{"version":"9d57b2b5d15838ed094aa9ff1299eecef40b190722eb619bac4616657a05f951","affectsGlobalScope":true},{"version":"6c51b5dd26a2c31dbf37f00cfc32b2aa6a92e19c995aefb5b97a3a64f1ac99de","affectsGlobalScope":true},{"version":"6e7997ef61de3132e4d4b2250e75343f487903ddf5370e7ce33cf1b9db9a63ed","affectsGlobalScope":true},{"version":"2ad234885a4240522efccd77de6c7d99eecf9b4de0914adb9a35c0c22433f993","affectsGlobalScope":true},{"version":"5e5e095c4470c8bab227dbbc61374878ecead104c74ab9960d3adcccfee23205","affectsGlobalScope":true},{"version":"09aa50414b80c023553090e2f53827f007a301bc34b0495bfb2c3c08ab9ad1eb","affectsGlobalScope":true},{"version":"d7f680a43f8cd12a6b6122c07c54ba40952b0c8aa140dcfcf32eb9e6cb028596","affectsGlobalScope":true},{"version":"3787b83e297de7c315d55d4a7c546ae28e5f6c0a361b7a1dcec1f1f50a54ef11","affectsGlobalScope":true},{"version":"e7e8e1d368290e9295ef18ca23f405cf40d5456fa9f20db6373a61ca45f75f40","affectsGlobalScope":true},{"version":"faf0221ae0465363c842ce6aa8a0cbda5d9296940a8e26c86e04cc4081eea21e","affectsGlobalScope":true},{"version":"06393d13ea207a1bfe08ec8d7be562549c5e2da8983f2ee074e00002629d1871","affectsGlobalScope":true},{"version":"2768ef564cfc0689a1b76106c421a2909bdff0acbe87da010785adab80efdd5c","affectsGlobalScope":true},{"version":"b248e32ca52e8f5571390a4142558ae4f203ae2f94d5bac38a3084d529ef4e58","affectsGlobalScope":true},{"version":"52d1bb7ab7a3306fd0375c8bff560feed26ed676a5b0457fa8027b563aecb9a4","affectsGlobalScope":true},"70bbfaec021ac4a0c805374225b55d70887f987df8b8dd7711d79464bb7b4385","869089d60b67219f63e6aca810284c89bae1b384b5cbc7ce64e53d82ad223ed5",{"version":"18338b6a4b920ec7d49b4ffafcbf0fa8a86b4bfd432966efd722dab611157cf4","affectsGlobalScope":true},"62a0875a0397b35a2364f1d401c0ce17975dfa4d47bf6844de858ae04da349f9","ee7491d0318d1fafcba97d5b72b450eb52671570f7a4ecd9e8898d40eaae9472","e3e7d217d89b380c1f34395eadc9289542851b0f0a64007dfe1fb7cf7423d24e","fd79909e93b4d50fd0ed9f3d39ddf8ba0653290bac25c295aac49f6befbd081b","345a9cc2945406f53051cd0e9b51f82e1e53929848eab046fdda91ee8aa7da31","9debe2de883da37a914e5e784a7be54c201b8f1d783822ad6f443ff409a5ea21","dee5d5c5440cda1f3668f11809a5503c30db0476ad117dd450f7ba5a45300e8f","f5e396c1424c391078c866d6f84afe0b4d2f7f85a160b9c756cd63b5b1775d93","5caa6f4fff16066d377d4e254f6c34c16540da3809cd66cd626a303bc33c419f","730d055528bdf12c8524870bb33d237991be9084c57634e56e5d8075f6605e02","75b22c74010ba649de1a1676a4c4b8b5bb4294fecd05089e2094429b16d7840c","5615ccf831db2ffc82145243081ebdb60ea8e1005ee8f975d1c0c1401a9c894e","38682ed3630bb6ecdace80d5a9adc811fc20a419f1940446e306c3a020d083b9","cc182e6e4f691cd6f7bf7cb491247a4c7818f9f1cb2db1d45c65ff906e3f741b","a50599c08934a62f11657bdbe0dc929ab66da1b1f09974408fd9a33ec1bb8060","5a20e7d6c630b91be15e9b837853173829d00273197481dc8d3e94df61105a71","8d478048d71cc16f806d4b71b252ecb67c7444ccf4f4b09b29a312712184f859","e0eda929c6b9b628cdeb0e54cd3582cb97e64f28aab34612fc1431c545899584","9df4662ca3dbc2522bc115833ee04faa1afbb4e249a85ef4a0a09c621346bd08","b25d9065cf1c1f537a140bbc508e953ed2262f77134574c432d206ff36f4bdbf","1b103313097041aa9cd705a682c652f08613cb5cf8663321061c0902f845e81c","68ccec8662818911d8a12b8ed028bc5729fb4f1d34793c4701265ba60bc73cf4","5f85b8b79dc4d36af672c035b2beb71545de63a5d60bccbeee64c260941672ab","b3d48529ae61dc27d0bfbfa2cb3e0dff8189644bd155bdf5df1e8e14669f7043","40fe4b689225816b31fe5794c0fbf3534568819709e40295ead998a2bc1ab237","f65b5e33b9ad545a1eebbd6afe857314725ad42aaf069913e33f928ab3e4990a","fb6f2a87beb7fb1f4c2b762d0c76a9459fc91f557231569b0ee21399e22aa13d","31c858dc85996fac4b7fa944e1016d5c72f514930a72357ab5001097bf6511c7","3de30a871b3340be8b679c52aa12f90dd1c8c60874517be58968fdbcc4d79445","6fd985bd31eaf77542625306fb0404d32bff978990f0a06428e5f0b9a3b58109","5b3cd03ae354ea96eff1f74d7c410fe4852e6382227e8b0ecf87ab5e3a5bbcd4","7394959e5a741b185456e1ef5d64599c36c60a323207450991e7a42e08911419",{"version":"056097110efd16869ec118cedb44ecbac9a019576eee808d61304ca6d5cb2cbe","affectsGlobalScope":true},"f51b4042a3ac86f1f707500a9768f88d0b0c1fc3f3e45a73333283dea720cdc6",{"version":"6fb8358e10ed92a7f515b7d79da3904c955a3ffd4e14aa9df6f0ea113041f1cf","affectsGlobalScope":true},"45c831238c6dac21c72da5f335747736a56a3847192bf03c84b958a7e9ec93e2","661a11d16ad2e3543a77c53bcd4017ee9a450f47ab7def3ab493a86eae4d550c",{"version":"8cdc646cec7819581ef343b83855b1bfe4fe674f2c84f4fb8dc90d82fb56bd3a","affectsGlobalScope":true},"a40826e8476694e90da94aa008283a7de50d1dafd37beada623863f1901cb7fb","9dd56225cc2d8cb8fe5ceb0043ff386987637e12fecc6078896058a99deae284","2375ed4b439215aa3b6d0c6fd175c78a4384b30cb43cbadaecbf0a18954c98cb","7693b90b3075deaccafd5efb467bf9f2b747a3075be888652ef73e64396d8628","41231da15bb5e3e806a8395bd15c7befd2ec90f9f4e3c9d0ae1356bccb76dbb0","fccfef201d057cb407fa515311bd608549bab6c7b8adcf8f2df31f5d3b796478",{"version":"ee1ee365d88c4c6c0c0a5a5701d66ebc27ccd0bcfcfaa482c6e2e7fe7b98edf7","affectsGlobalScope":true},"5f20d20b7607174caf1a6da9141aeb9f2142159ae2410ca30c7a0fccd1d19c99",{"version":"464762c6213566d072f1ced5e8e9a954785ec5e53883b7397198abb5ef5b8f71","affectsGlobalScope":true},"6387920dc3e18927335b086deec75bf8e50f879a5e273d32ee7bb7a55ba50572","9bba37424094688c4663c177a1379b229f919b8912889a472f32fdc5f08ddb4d","29a4be13b3a30d3e66667b75c58ec61fb2df8fa0422534fdee3cfb30c5dbf450","83366d901beda79d6eb37aaaf6ca248dcd88946302b2a7d975590783be51e88e","bf268a0aea37ad4ae3b7a9b58559190b6fc01ea16a31e35cd05817a0a60f895a","43ec77c369473e92e2ecebf0554a0fdaa9c256644a6070f28228dfcceec77351",{"version":"d7dad6db394a3d9f7b49755e4b610fbf8ed6eb0c9810ae5f1a119f6b5d76de45","affectsGlobalScope":true},"95ed02bacb4502c985b69742ec82a4576d4ff4a6620ecc91593f611d502ae546","bf755525c4e6f85a970b98c4755d98e8aa1b6dbd83a5d8fcc57d3d497351b936","dd67d2b5e4e8a182a38de8e69fb736945eaa4588e0909c14e01a14bd3cc1fd1e",{"version":"28084e15b63e6211769db2fe646d8bc5c4c6776321e0deffe2d12eefd52cb6b9","affectsGlobalScope":true},{"version":"aed37dabf86c99d6c8508700576ecede86688397bc12523541858705a0c737c2","affectsGlobalScope":true},"cc6ef5733d4ea6d2e06310a32dffd2c16418b467c5033d49cecc4f3a25de7497","94768454c3348b6ebe48e45fbad8c92e2bb7af4a35243edbe2b90823d0bd7f9a","0be79b3ff0f16b6c2f9bc8c4cc7097ea417d8d67f8267f7e1eec8e32b548c2ff","1c61ffa3a71b77363b30d19832c269ef62fba787f5610cac7254728d3b69ab2e","84da3c28344e621fd1d591f2c09e9595292d2b70018da28a553268ac122597d4","269929a24b2816343a178008ac9ae9248304d92a8ba8e233055e0ed6dbe6ef71","6e191fea1db6e9e4fa828259cf489e820ec9170effff57fb081a2f3295db4722","aed943465fbce1efe49ee16b5ea409050f15cd8eaf116f6fadb64ef0772e7d95","70d08483a67bf7050dbedace398ef3fee9f436fcd60517c97c4c1e22e3c6f3e8","c40fdf7b2e18df49ce0568e37f0292c12807a0748be79e272745e7216bed2606",{"version":"e933de8143e1d12dd51d89b398760fd5a9081896be366dad88a922d0b29f3c69","affectsGlobalScope":true},"4e228e78c1e9b0a75c70588d59288f63a6258e8b1fe4a67b0c53fe03461421d9","b38d55d08708c2410a3039687db70b4a5bfa69fc4845617c313b5a10d9c5c637","205d50c24359ead003dc537b9b65d2a64208dfdffe368f403cf9e0357831db9e","1265fddcd0c68be9d2a3b29805d0280484c961264dd95e0b675f7bd91f777e78",{"version":"a05e2d784c9be7051c4ac87a407c66d2106e23490c18c038bbd0712bde7602fd","affectsGlobalScope":true},{"version":"df90b9d0e9980762da8daf8adf6ffa0c853e76bfd269c377be0d07a9ad87acd2","affectsGlobalScope":true},"cf434b5c04792f62d6f4bdd5e2c8673f36e638e910333c172614d5def9b17f98","1d65d4798df9c2df008884035c41d3e67731f29db5ecb64cd7378797c7c53a2f","0faee6b555890a1cb106e2adc5d3ffd89545b1da894d474e9d436596d654998f","c6c01ea1c42508edf11a36d13b70f6e35774f74355ba5d358354d4a77cc67ea1","867f95abf1df444aab146b19847391fc2f922a55f6a970a27ed8226766cee29f",{"version":"ab9b9a36e5284fd8d3bf2f7d5fcbc60052f25f27e4d20954782099282c60d23e","affectsGlobalScope":true},"b0297b09e607bec9698cac7cf55463d6731406efb1161ee4d448293b47397c84","175323e2a79a6076e0bada8a390d535a3ea817158bf1b1f46e31efca9028a0a2","7a10053aadc19335532a4d02756db4865974fd69bea5439ddcc5bfdf062d9476","4967529644e391115ca5592184d4b63980569adf60ee685f968fd59ab1557188","aed9e712a9b168345362e8f3a949f16c99ca1e05d21328f05735dfdbb24414ef","b04fe6922ed3db93afdbd49cdda8576aa75f744592fceea96fb0d5f32158c4f5","ed8d6c8de90fc2a4faaebc28e91f2469928738efd5208fb75ade0fa607e892b7","d7c52b198d680fe65b1a8d1b001f0173ffa2536ca2e7082431d726ce1f6714cd","c07f251e1c4e415a838e5498380b55cfea94f3513229de292d2aa85ae52fc3e9","0ed401424892d6bf294a5374efe512d6951b54a71e5dd0290c55b6d0d915f6f7","b945be6da6a3616ef3a250bfe223362b1c7c6872e775b0c4d82a1bf7a28ff902","beea49237dd7c7110fabf3c7509919c9cb9da841d847c53cac162dc3479e2f87","0f45f8a529c450d8f394106cc622bff79e44a1716e1ac9c3cc68b43f7ecf65ee","c624ce90b04c27ce4f318ba6330d39bde3d4e306f0f497ce78d4bda5ab8e22ca","9b8253aa5cb2c82d505f72afdbf96e83b15cc6b9a6f4fadbbbab46210d5f1977","86a8f52e4b1ac49155e889376bcfa8528a634c90c27fec65aa0e949f77b740c5","aab5dd41c1e2316cc0b42a7dd15684f8582d5a1d16c0516276a2a8a7d0fecd9c","59948226626ee210045296ba1fc6cb0fe748d1ff613204e08e7157ab6862dee7","ec3e54d8b713c170fdc8110a7e4a6a97513a7ab6b05ac9e1100cb064d2bb7349","43beb30ecb39a603fde4376554887310b0699f25f7f39c5c91e3147b51bb3a26","666b77d7f06f49da114b090a399abbfa66d5b6c01a3fd9dc4f063a52ace28507","31997714a93fbc570f52d47d6a8ebfb021a34a68ea9ba58bbb69cdec9565657e","6032e4262822160128e644de3fc4410bcd7517c2f137525fd2623d2bb23cb0d3","8bd5c9b1016629c144fd228983395b9dbf0676a576716bc3d316cab612c33cd5","2ed90bd3925b23aed8f859ffd0e885250be0424ca2b57e9866dabef152e1d6b7","93f6bd17d92dab9db7897e1430a5aeaa03bcf51623156213d8397710367a76ce","3f62b770a42e8c47c7008726f95aa383e69d97e85e680d237b99fcb0ee601dd8","5b84cfe78028c35c3bb89c042f18bf08d09da11e82d275c378ae4d07d8477e6c","980d21b0081cbf81774083b1e3a46f4bbdcd2b68858df0f66d7fad9c82bc34bc","68cc8d6fcc2f270d7108f02f3ebc59480a54615be3e09a47e14527f349e9d53e","3eb11dbf3489064a47a2e1cf9d261b1f100ef0b3b50ffca6c44dd99d6dd81ac1","b17f3bb7d8333479c7e45e5f3d876761b9bca58f97594eca3f6a944fd825e632","3c1f1236cce6d6e0c4e2c1b4371e6f72d7c14842ecd76a98ed0748ee5730c8f3","6d7f58d5ea72d7834946fd7104a734dc7d40661be8b2e1eaced1ddce3268ebaf","4c26222991e6c97d5a8f541d4f2c67585eda9e8b33cf9f52931b098045236e88","277983d414aa99d78655186c3ee1e1c38c302e336aff1d77b47fcdc39d8273fe","47383b45796d525a4039cd22d2840ac55a1ff03a43d027f7f867ba7314a9cf53","6548773b3abbc18de29176c2141f766d4e437e40596ee480447abf83575445ad","6ddd27af0436ce59dd4c1896e2bfdb2bdb2529847d078b83ce67a144dff05491","816264799aef3fd5a09a3b6c25217d5ec26a9dfc7465eac7d6073bcdc7d88f3f","4df0891b133884cd9ed752d31c7d0ec0a09234e9ed5394abffd3c660761598db","b603b62d3dcd31ef757dc7339b4fa8acdbca318b0fb9ac485f9a1351955615f9","e642bd47b75ad6b53cbf0dfd7ddfa0f120bd10193f0c58ec37d87b59bf604aca","be90b24d2ee6f875ce3aaa482e7c41a54278856b03d04212681c4032df62baf9","78f5ff400b3cb37e7b90eef1ff311253ed31c8cb66505e9828fad099bffde021","372c47090e1131305d163469a895ff2938f33fa73aad988df31cd31743f9efb6","71c67dc6987bdbd5599353f90009ff825dd7db0450ef9a0aee5bb0c574d18512","6f12403b5eca6ae7ca8e3efe3eeb9c683b06ce3e3844ccfd04098d83cd7e4957","282c535df88175d64d9df4550d2fd1176fd940c1c6822f1e7584003237f179d3","c3a4752cf103e4c6034d5bd449c8f9d5e7b352d22a5f8f9a41a8efb11646f9c2","11a9e38611ac3c77c74240c58b6bd64a0032128b29354e999650f1de1e034b1c","4ed103ca6fff9cb244f7c4b86d1eb28ce8069c32db720784329946731badb5bb","d738f282842970e058672663311c6875482ee36607c88b98ffb6604fba99cb2a","ec859cd8226aa623e41bbb47c249a55ee16dc1b8647359585244d57d3a5ed0c7","8891c6e959d253a66434ff5dc9ae46058fb3493e84b4ca39f710ef2d350656b1","c4463cf02535444dcbc3e67ecd29f1972490f74e49957d6fd4282a1013796ba6","0cb0a957ff02de0b25fd0f3f37130ca7f22d1e0dea256569c714c1f73c6791f8","2f5075dc512d51786b1ba3b1696565641dfaae3ac854f5f13d61fa12ef81a47e","ca3353cc82b1981f0d25d71d7432d583a6ef882ccdea82d65fbe49af37be51cb","50679a8e27aacf72f8c40bcab15d7ef5e83494089b4726b83eec4554344d5cdc","45351e0d51780b6f4088277a4457b9879506ee2720a887de232df0f1efcb33d8","5d697a4b315cc5bb3042ae869abffd10c3b0d7b182cda0e4c45d8819937e5796","89b040dec8fcfc1de98827e1f4d4977e6ff5d3302c6790e9f10b54b916e1c742","6ee58aa536dabb19b09bc036f1abe83feb51e13d63b23d30b2d0631a2de99b8f","8aceb205dcc6f814ad99635baf1e40b6e01d06d3fe27b72fd766c6d0b8c0c600","299567f84bfedd1468dca2755a829cb19e607a6811673788807dc8921e211bc9","795d9fb85aad92221504db74dd179b506bd189bba0c104426f7e7bb8a66ffee5","1311bc194e0a69fe61031e852c1c0b439e2a2a3d1d5e2d8ff795499b9f283459","4b7ce19369d7e7fae76720c2c6c7f671bf3fa0f7093edb864f1ac358ca7c456c","c972ef44deca1fa8fab465915ffa00f82e126aacf3dfc8979c03b1b066ce5bb6","30285a1011c6d6b52f3ba3abb0a984be8148c05cdefb8eb6eb562335a3991f35","9f9e5bae412fa5909fae636d6733aee27a108cc2ed5b13980611016336774d3c","662fe197bba64bd3f17ee118058cd2d0d2dbe33d7c0c865fd6365d90bfc44e1e","030519c351f800551cac2658038804969ca4584d2c0175a710602ac234ca1340","0278a6939ca83cd040b08ff8c5fc7838b6693ddc52f22526bf158e6b10e0246c","c2d6206e5ba4fd3063b01218c2b3b997afc1cfbeb49fcee991fa8595842ce53d","8e7adb22c0adecf7464861fc58ae3fc617b41ffbd70c97aa8493dc0966a82273","755f3cd1d9c1b564cff090e3b0e29200ae55690a91b87cb9e7a64c2dbeb314d3","d6bb7e0a6877b7856c183bff13d09dd9ae599ea43c6f6b33d3d5f72a830ed460","f1b51ae93c762d7c43f559933cd4842dd870367e8d92e90704ffa685dd5b29a3","fab58e600970e66547644a44bc9918e3223aa2cbd9e8763cec004b2cfb48827e",{"version":"12accaad8d0630e27afcee6db467be3587027b92d8a78a5ea40d98ce879db790","signature":"e3539189d512442af177f3c8c49e9cc56834ae05f3ed125491baae619d4c526f"},"fcc8beef29f39f09b1d9c9f99c42f9fed605ab1c28d2a630185f732b9ba53763","d6e6620a30d582182acc3f0a992a0c311adc589f111096aea11ab83fc09a5ccc","6213b8f686f56beab22b59a0f468590fd3a4c5fa931236a017efeca91d7c9584","c451cec9a588b1f105a5ea2c6063d4fca112b9d70105cacdadda0e1ef67e9379","cb047832dc68f5a2c41c62c5e95ddcacbae3a8b034d40cd15319a8cb7f25104a","980336ccdfc3c08f3c3b201aa6662e6016e20f15847f8465b68f3e8e67b4665c","5a3493939995f46ff3d9073cd534fb8961c3bf4e08c71db27066ff03d906dea8","bb5a2ac327605ebebf831c469b05bd34a33a6a46ee8c1edd9f3310aad32cf6a1","bf5d041f2440b4a9391e2b5eb3b8d94cbf1e3b8ff4703b6539d4e65e758c8f37","8516469eb90e723b0eb03df1be098f7e6a4709f6f48fd4532868d20a0a934f6e","d60e9ab369a72d234aac49adbe2900d8ef1408a6ea4db552cf2a48c9d8d6a1bc","0ebb4698803f01e2e7df6acce572fff068f4a20c47221721dafd70a27e372831","03460a54d0e0481d1e11097f66ad43f054bc95efdafe5f81bbc7a82be181af75","ded24ddc7157689a5aa14bd651272ab8cd6e7812da2196a65d8c5e63131cfb23","2cea9689efa8591732096235abe7f084fc29c92badd5b0897a5e876b77e71887","4ed4e504126014fee13aaef5e3fc140f2ff7031ff3a8b5386717905820ea2d09","9f99927996dec2b673c7dcf314ad3fc2d96b3097016d99e28ca25314e19df2c1","accf5b0acb7a341cf9699960157059c95c40842b7b3312ab19053c610cbde977","8d27ef959532cab3f4313ba2f1e66d9c1c159539faa653c3cef848a457939726","a4fcdbc70e4d139fb80f8c99789aea5ad42e18c8ffd034bfe44ab63644471cc7","81859dcda72b45168a93fefe8bf6d62a4eb4032694def53a3c2ccb7f07326d8f","827abdfc5e85e0d5b1959167928bd2f9ca5a684a2b64e054d291571f7e632d4c","84605b003c9b842f5d4d5d068f7d92f382d3b5c1565375eef3136ed5f03d7ee4","1679f0a7b02d9f185ac1ea0ef4c9197d4c6d299de3e433ce4b8679a58e34c9e5","66ee590a1a296344449ac904bf56c03b3075c4f3c2479db655cc1ce9407eb58b","d067e051d72e0d79389c52cb28bb23d11b97c2bd7dfaba12083ea544d924ab7a","1d44112639c6691d697eaa88c1bf738a4438063f1ecbfbc1208b6d3040d39eb7","f957b018293727b85e13d0a0c8f15556e97cf6fa6cd6b3c5c47a18d9173155b1","0763c0248d05cfd5fea25f97aa10d51084a36a8893985e0537c48e4ab1376326","b4608db340ab2c69bc4d426d06c3bf4f8a04f4e2c40fa30905581336bf3f242c","a55ab6e38e964b1000ab2fbab89e41996375c83c9d1c79d2f243c5df901289b9","4f07dc7f29a2f794c62996d32f148e973ba146ce59a16d4ad3e01c5e3018891f",{"version":"9eb6c0f28550944f99f6d1fc1985f29ac121ba0b57a399db12a59f53e0d327d8","signature":"689e53365e2e5af801be2af3fad66936b989c4fffa9dfd94f91885f11afa05d2"},{"version":"86ee1535397ec5bc983ffe847ed6ea66c704084745fafc0b81ef2e2b9ea0a6c4","signature":"2901396d9707d63ee1d6dcd60cfe70fe64bdd78b13696cddefd8872393d1b96a"},{"version":"3d42a9b4218d715d9909898927a2f6ab7f1738178e7eb81ddd3d7f7b1392e8e9","signature":"e10b1f5cd5b943bdffdfa8165d796837e13b58718a1faee5485652a0fbedde58"},{"version":"ddfd4bd8fb8f640b88a39262cde2d22c73b0149b3cbe1574bc2da48a176f612c","signature":"7bd3844e77367d48f1f9ea69d39b92ff9d086dc499da91fe8df78406b2e3f1fc"},{"version":"c6d0c102c423c94e7fe1efef045e7e0cb056c3acea9508ed2e9c45d9568ce199","signature":"2c72440feb99d0bdbb94a41fce555c92a8eb25aa4f3ef48fa7de55897ce24ad7"},"d68cb13e3cde9d7fc02ecc3f258de77f5e7da54b6f5513ae075f2fd8e1f0d5d9","4489c6a9fde8934733aa7df6f7911461ee6e9e4ad092736bd416f6b2cc20b2c6","2c8e55457aaf4902941dfdba4061935922e8ee6e120539c9801cd7b400fae050","8041cfce439ff29d339742389de04c136e3029d6b1817f07b2d7fcbfb7534990","670a76db379b27c8ff42f1ba927828a22862e2ab0b0908e38b671f0e912cc5ed","9d38964b57191567a14b396422c87488cecd48f405c642daa734159875ee81d9","069bebfee29864e3955378107e243508b163e77ab10de6a5ee03ae06939f0bb9","8c95f96ccd4be0674944077aec1e4f2cccd515ca06d4327562dd017250e7d3fc",{"version":"64d4b35c5456adf258d2cf56c341e203a073253f229ef3208fc0d5020253b241","affectsGlobalScope":true},"ee7d8894904b465b072be0d2e4b45cf6b887cdba16a467645c4e200982ece7ea","f3d8c757e148ad968f0d98697987db363070abada5f503da3c06aefd9d4248c1","bc3cba7b0af2d52e7425299aee518db479d44004eff6fbbd206d1ee7e5ec3fb5","afe73051ff6a03a9565cbd8ebb0e956ee3df5e913ad5c1ded64218aabfa3dcb5","035a5df183489c2e22f3cf59fc1ed2b043d27f357eecc0eb8d8e840059d44245","a4809f4d92317535e6b22b01019437030077a76fec1d93b9881c9ed4738fcc54","5f53fa0bd22096d2a78533f94e02c899143b8f0f9891a46965294ee8b91a9434","0d14fa22c41fdc7277e6f71473b20ebc07f40f00e38875142335d5b63cdfc9d2","d8aab31ba8e618cc3eea10b0945de81cb93b7e8150a013a482332263b9305322","462bccdf75fcafc1ae8c30400c9425e1a4681db5d605d1a0edb4f990a54d8094","5923d8facbac6ecf7c84739a5c701a57af94a6f6648d6229a6c768cf28f0f8cb","7adecb2c3238794c378d336a8182d4c3dd2c4fa6fa1785e2797a3db550edea62","dc12dc0e5aa06f4e1a7692149b78f89116af823b9e1f1e4eae140cd3e0e674e6","1bfc6565b90c8771615cd8cfcf9b36efc0275e5e83ac7d9181307e96eb495161","8a8a96898906f065f296665e411f51010b51372fa260d5373bf9f64356703190","7f82ef88bdb67d9a850dd1c7cd2d690f33e0f0acd208e3c9eba086f3670d4f73",{"version":"ccfd8774cd9b929f63ff7dcf657977eb0652e3547f1fcac1b3a1dc5db22d4d58","affectsGlobalScope":true},"d92dc90fecd2552db74d8dc3c6fb4db9145b2aa0efe2c127236ba035969068d4","96d14f21b7652903852eef49379d04dbda28c16ed36468f8c9fa08f7c14c9538","b8442e9db28157344d1bc5d8a5a256f1692de213f0c0ddeb84359834015a008c","458111fc89d11d2151277c822dfdc1a28fa5b6b2493cf942e37d4cd0a6ee5f22","da2b6356b84a40111aaecb18304ea4e4fcb43d70efb1c13ca7d7a906445ee0d3","187119ff4f9553676a884e296089e131e8cc01691c546273b1d0089c3533ce42","febf0b2de54781102b00f61653b21377390a048fbf5262718c91860d11ff34a6","6f294731b495c65ecf46a5694f0082954b961cf05463bea823f8014098eaffa0","0aaef8cded245bf5036a7a40b65622dd6c4da71f7a35343112edbe112b348a1e","00baffbe8a2f2e4875367479489b5d43b5fc1429ecb4a4cc98cfc3009095f52a","68a0d0c508e1b6d8d23a519a8a0a3303dc5baa4849ca049f21e5bad41945e3fc","3c92b6dfd43cc1c2485d9eba5ff0b74a19bb8725b692773ef1d66dac48cda4bd","b03afe4bec768ae333582915146f48b161e567a81b5ebc31c4d78af089770ac9","df996e25faa505f85aeb294d15ebe61b399cf1d1e49959cdfaf2cc0815c203f9","4f6a12044ee6f458db11964153830abbc499e73d065c51c329ec97407f4b13dd","8841e2aa774b89bd23302dede20663306dc1b9902431ac64b24be8b8d0e3f649","916be7d770b0ae0406be9486ac12eb9825f21514961dd050594c4b250617d5a8","254d9fb8c872d73d34594be8a200fd7311dbfa10a4116bfc465fba408052f2b3","d88a5e779faf033be3d52142a04fbe1cb96009868e3bbdd296b2bc6c59e06c0e","2ccea88888048bbfcacbc9531a5596ea48a3e7dcd0a25f531a81bb717903ba4f","5e379df3d61561c2ed7789b5995b9ba2143bbba21a905e2381e16efe7d1fa424","f07a137bbe2de7a122c37bfea00e761975fb264c49f18003d398d71b3fb35a5f","d8f7109e14f20eb735225a62fd3f8366da1a8349e90331cdad57f4b04caf6c5a","cf3d384d082b933d987c4e2fe7bfb8710adfd9dc8155190056ed6695a25a559e","9871b7ee672bc16c78833bdab3052615834b08375cb144e4d2cba74473f4a589","c863198dae89420f3c552b5a03da6ed6d0acfa3807a64772b895db624b0de707","8b03a5e327d7db67112ebbc93b4f744133eda2c1743dbb0a990c61a8007823ef","86c73f2ee1752bac8eeeece234fd05dfcf0637a4fbd8032e4f5f43102faa8eec","42fad1f540271e35ca37cecda12c4ce2eef27f0f5cf0f8dd761d723c744d3159","ff3743a5de32bee10906aff63d1de726f6a7fd6ee2da4b8229054dfa69de2c34","83acd370f7f84f203e71ebba33ba61b7f1291ca027d7f9a662c6307d74e4ac22","1445cec898f90bdd18b2949b9590b3c012f5b7e1804e6e329fb0fe053946d5ec","0e5318ec2275d8da858b541920d9306650ae6ac8012f0e872fe66eb50321a669","cf530297c3fb3a92ec9591dd4fa229d58b5981e45fe6702a0bd2bea53a5e59be","c1f6f7d08d42148ddfe164d36d7aba91f467dbcb3caa715966ff95f55048b3a4","f4e9bf9103191ef3b3612d3ec0044ca4044ca5be27711fe648ada06fad4bcc85","0c1ee27b8f6a00097c2d6d91a21ee4d096ab52c1e28350f6362542b55380059a","7677d5b0db9e020d3017720f853ba18f415219fb3a9597343b1b1012cfd699f7","bc1c6bc119c1784b1a2be6d9c47addec0d83ef0d52c8fbe1f14a51b4dfffc675","52cf2ce99c2a23de70225e252e9822a22b4e0adb82643ab0b710858810e00bf1","770625067bb27a20b9826255a8d47b6b5b0a2d3dfcbd21f89904c731f671ba77","d1ed6765f4d7906a05968fb5cd6d1db8afa14dbe512a4884e8ea5c0f5e142c80","799c0f1b07c092626cf1efd71d459997635911bb5f7fc1196efe449bba87e965","2a184e4462b9914a30b1b5c41cf80c6d3428f17b20d3afb711fff3f0644001fd","9eabde32a3aa5d80de34af2c2206cdc3ee094c6504a8d0c2d6d20c7c179503cc","397c8051b6cfcb48aa22656f0faca2553c5f56187262135162ee79d2b2f6c966","a8ead142e0c87dcd5dc130eba1f8eeed506b08952d905c47621dc2f583b1bff9","a02f10ea5f73130efca046429254a4e3c06b5475baecc8f7b99a0014731be8b3","c2576a4083232b0e2d9bd06875dd43d371dee2e090325a9eac0133fd5650c1cb","4c9a0564bb317349de6a24eb4efea8bb79898fa72ad63a1809165f5bd42970dd","f40ac11d8859092d20f953aae14ba967282c3bb056431a37fced1866ec7a2681","cc11e9e79d4746cc59e0e17473a59d6f104692fd0eeea1bdb2e206eabed83b03","b444a410d34fb5e98aa5ee2b381362044f4884652e8bc8a11c8fe14bbd85518e","c35808c1f5e16d2c571aa65067e3cb95afeff843b259ecfa2fc107a9519b5392","14d5dc055143e941c8743c6a21fa459f961cbc3deedf1bfe47b11587ca4b3ef5","a3ad4e1fc542751005267d50a6298e6765928c0c3a8dce1572f2ba6ca518661c","f237e7c97a3a89f4591afd49ecb3bd8d14f51a1c4adc8fcae3430febedff5eb6","3ffdfbec93b7aed71082af62b8c3e0cc71261cc68d796665faa1e91604fbae8f","662201f943ed45b1ad600d03a90dffe20841e725203ced8b708c91fcd7f9379a","c9ef74c64ed051ea5b958621e7fb853fe3b56e8787c1587aefc6ea988b3c7e79","2462ccfac5f3375794b861abaa81da380f1bbd9401de59ffa43119a0b644253d","34baf65cfee92f110d6653322e2120c2d368ee64b3c7981dff08ed105c4f19b0","7d8ddf0f021c53099e34ee831a06c394d50371816caa98684812f089b4c6b3d4","7d2a0ba1297be385a89b5515b88cd31b4a1eeef5236f710166dc1b36b1741e1b","9d92b037978bb9525bc4b673ebddd443277542e010c0aef019c03a170ccdaa73","ab82804a14454734010dcdcd43f564ff7b0389bee4c5692eec76ff5b30d4cf66","bae8d023ef6b23df7da26f51cea44321f95817c190342a36882e93b80d07a960","ae271d475b632ce7b03fea6d9cf6da72439e57a109672671cbc79f54e1386938"],"options":{"composite":true,"declaration":true,"declarationMap":true,"emitDeclarationOnly":true,"esModuleInterop":true,"inlineSources":true,"module":1,"outDir":"./types","rootDir":"../src","sourceMap":true,"strict":true,"target":7},"fileIdsList":[[248],[92,128,129,130,145],[129,130,146,147],[128,129],[128,145,148,151],[128,148,151,152],[149,150,151,153,154],[128,151],[128,145,148,149,150,153],[128,136],[128],[92,128],[80,128],[132,133,134,135,136,137,138,139,140,141,142,143,144],[128,134,135],[128,134,136],[210],[210,221,222],[222,223,224],[167,217,226],[221,227],[167,226],[227,228,229],[167],[167,225,231],[167,217,225],[167,217,221,225],[167,217],[232,233,234,235,236,237,238,239,240],[167,231],[167,217,221],[167,217,231],[167,199],[199,200],[199,200,201,202],[204],[204,205,206],[64],[67],[64,67],[65,66,67,68,69,70,71,72,73,74,75,156,159,160,161,162,163,164,165,166],[58,64,65],[67,73,75,155],[158],[67,68],[64,162],[194,195],[248,249,250,251,252],[248,250],[157],[255,256,257],[93,128],[260],[261],[272],[266,271],[275,277,278,279,280,281,282,283,284,285,286,287],[275,276,278,279,280,281,282,283,284,285,286,287],[276,277,278,279,280,281,282,283,284,285,286,287],[275,276,277,279,280,281,282,283,284,285,286,287],[275,276,277,278,280,281,282,283,284,285,286,287],[275,276,277,278,279,281,282,283,284,285,286,287],[275,276,277,278,279,280,282,283,284,285,286,287],[275,276,277,278,279,280,281,283,284,285,286,287],[275,276,277,278,279,280,281,282,284,285,286,287],[275,276,277,278,279,280,281,282,283,285,286,287],[275,276,277,278,279,280,281,282,283,284,286,287],[275,276,277,278,279,280,281,282,283,284,285,287],[275,276,277,278,279,280,281,282,283,284,285,286],[76],[79],[80,85,112],[81,92,93,100,109,120],[81,82,92,100],[83,121],[84,85,93,101],[85,109,117],[86,88,92,100],[87],[88,89],[92],[91,92],[79,92],[92,93,94,109,120],[92,93,94,109],[92,95,100,109,120],[92,93,95,96,100,109,117,120],[95,97,109,117,120],[76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127],[92,98],[99,120,125],[88,92,100,109],[101],[102],[79,103],[104,119,125],[105],[106],[92,107],[107,108,121,123],[80,92,109,110,111],[80,109,111],[109,110],[112],[113],[92,115,116],[115,116],[85,100,109,117],[118],[100,119],[80,95,106,120],[85,121],[109,122],[123],[124],[80,85,92,94,103,109,120,123,125],[109,126],[128,293],[296,335],[296,320,335],[335],[296],[296,321,335],[296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334],[321,335],[336],[339],[179],[179,180,181,182,183],[168,169,170,171,172,173,174,175,176,177,178],[264,267],[264,267,268,269],[266],[263,270],[265],[57,59,60,61,62,63],[57,58],[59],[58,59],[57,59],[167,184,185,186],[185],[186],[56,185,186,187],[189],[189,190,193,197],[196],[167,191,192],[218,219,220],[217,218],[167,217,218],[167,210,217],[167,210],[167,211],[211,212,213,214,215,216],[76,167,188,191,198,203,207,208,209,242,244,245],[242,243],[167,198,217,221,225,230,241,242],[209,242,243,246],[167,198,221,225],[167,188,191,198,207,209,242,244],[242],[158,167]],"referencedMap":[[250,1],[146,2],[148,3],[130,4],[152,5],[153,6],[149,6],[155,7],[150,6],[154,8],[151,9],[137,10],[134,11],[141,12],[135,10],[132,13],[145,14],[139,11],[136,15],[138,16],[222,17],[223,18],[224,18],[225,19],[227,20],[229,21],[228,22],[230,23],[226,24],[232,25],[233,26],[234,27],[235,26],[236,28],[241,29],[237,30],[238,31],[239,27],[231,28],[240,32],[200,33],[201,34],[203,35],[199,24],[210,12],[205,36],[206,36],[207,37],[65,38],[66,38],[68,39],[69,38],[70,38],[71,40],[67,38],[167,41],[75,42],[156,43],[159,44],[165,45],[166,46],[196,47],[253,48],[249,1],[251,49],[252,1],[192,11],[158,50],[258,51],[259,52],[261,53],[262,54],[273,55],[272,56],[276,57],[277,58],[275,59],[278,60],[279,61],[280,62],[281,63],[282,64],[283,65],[284,66],[285,67],[286,68],[287,69],[76,70],[77,70],[79,71],[80,72],[81,73],[82,74],[83,75],[84,76],[85,77],[86,78],[87,79],[88,80],[89,80],[90,81],[91,82],[92,83],[93,84],[94,85],[95,86],[96,87],[97,88],[128,89],[98,90],[99,91],[100,92],[101,93],[102,94],[103,95],[104,96],[105,97],[106,98],[107,99],[108,100],[109,101],[111,102],[110,103],[112,104],[113,105],[115,106],[116,107],[117,108],[118,109],[119,110],[120,111],[121,112],[122,113],[123,114],[124,115],[125,116],[126,117],[290,11],[294,118],[295,11],[320,119],[321,120],[296,121],[299,121],[318,119],[319,119],[309,119],[308,122],[306,119],[301,119],[314,119],[312,119],[316,119],[300,119],[313,119],[317,119],[302,119],[303,119],[315,119],[297,119],[304,119],[305,119],[307,119],[311,119],[322,123],[310,119],[298,119],[335,124],[329,123],[331,125],[330,123],[323,123],[324,123],[326,123],[328,123],[332,125],[333,125],[325,125],[327,125],[337,126],[340,127],[175,128],[177,128],[176,128],[174,128],[184,129],[179,130],[170,128],[171,128],[172,128],[173,128],[268,131],[270,132],[269,131],[267,133],[271,134],[266,135],[64,136],[59,137],[60,138],[61,138],[62,139],[63,139],[58,140],[187,141],[186,142],[185,143],[188,144],[190,145],[198,146],[197,147],[193,148],[221,149],[219,150],[220,151],[218,152],[211,153],[212,154],[213,154],[215,154],[217,155],[216,154],[246,156],[244,157],[243,158],[247,159],[245,24],[242,160]],"exportedModulesMap":[[250,1],[146,2],[148,3],[130,4],[152,5],[153,6],[149,6],[155,7],[150,6],[154,8],[151,9],[137,10],[134,11],[141,12],[135,10],[132,13],[145,14],[139,11],[136,15],[138,16],[222,17],[223,18],[224,18],[225,19],[227,20],[229,21],[228,22],[230,23],[226,24],[232,25],[233,26],[234,27],[235,26],[236,28],[241,29],[237,30],[238,31],[239,27],[231,28],[240,32],[200,33],[201,34],[203,35],[199,24],[210,12],[205,36],[206,36],[207,37],[65,38],[66,38],[68,39],[69,38],[70,38],[71,40],[67,38],[167,41],[75,42],[156,43],[159,44],[165,45],[166,46],[196,47],[253,48],[249,1],[251,49],[252,1],[192,11],[158,50],[258,51],[259,52],[261,53],[262,54],[273,55],[272,56],[276,57],[277,58],[275,59],[278,60],[279,61],[280,62],[281,63],[282,64],[283,65],[284,66],[285,67],[286,68],[287,69],[76,70],[77,70],[79,71],[80,72],[81,73],[82,74],[83,75],[84,76],[85,77],[86,78],[87,79],[88,80],[89,80],[90,81],[91,82],[92,83],[93,84],[94,85],[95,86],[96,87],[97,88],[128,89],[98,90],[99,91],[100,92],[101,93],[102,94],[103,95],[104,96],[105,97],[106,98],[107,99],[108,100],[109,101],[111,102],[110,103],[112,104],[113,105],[115,106],[116,107],[117,108],[118,109],[119,110],[120,111],[121,112],[122,113],[123,114],[124,115],[125,116],[126,117],[290,11],[294,118],[295,11],[320,119],[321,120],[296,121],[299,121],[318,119],[319,119],[309,119],[308,122],[306,119],[301,119],[314,119],[312,119],[316,119],[300,119],[313,119],[317,119],[302,119],[303,119],[315,119],[297,119],[304,119],[305,119],[307,119],[311,119],[322,123],[310,119],[298,119],[335,124],[329,123],[331,125],[330,123],[323,123],[324,123],[326,123],[328,123],[332,125],[333,125],[325,125],[327,125],[337,126],[340,127],[175,128],[177,128],[176,128],[174,128],[184,129],[179,130],[170,128],[171,128],[172,128],[173,128],[268,131],[270,132],[269,131],[267,133],[271,134],[266,135],[64,136],[59,137],[60,138],[61,138],[62,139],[63,139],[58,140],[187,141],[186,142],[185,143],[188,144],[190,145],[198,146],[197,147],[193,148],[221,149],[219,150],[220,151],[218,152],[211,153],[212,154],[213,154],[215,154],[217,155],[216,154],[246,161],[244,162],[243,162],[247,159],[245,163],[242,160]],"semanticDiagnosticsPerFile":[250,248,146,129,148,130,147,152,153,149,155,150,154,151,137,134,141,135,132,140,145,142,143,144,139,136,133,138,222,223,224,225,227,229,228,230,226,232,233,234,235,236,241,237,238,239,231,240,191,200,202,201,203,199,210,205,206,207,204,65,66,68,69,70,71,72,73,74,67,167,75,156,159,160,161,162,163,164,165,166,194,196,195,253,249,251,252,192,158,254,255,258,256,259,260,261,262,273,272,257,274,276,277,275,278,279,280,281,282,283,284,285,286,287,288,157,76,77,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,78,127,95,96,97,128,98,99,100,101,102,103,104,105,106,107,108,109,111,110,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,289,290,291,292,294,293,295,320,321,296,299,318,319,309,308,306,301,314,312,316,300,313,317,302,303,315,297,304,305,307,311,322,310,298,335,334,329,331,330,323,324,326,328,332,333,325,327,337,336,338,208,339,340,131,263,178,175,177,176,174,184,179,183,180,182,181,170,171,172,168,169,173,264,268,270,269,267,271,266,265,57,64,59,60,61,62,63,58,8,10,9,2,11,12,13,14,15,16,17,18,3,4,22,19,20,21,23,24,25,5,26,27,28,29,6,33,30,31,32,34,7,35,40,41,36,37,38,39,1,42,56,187,186,185,188,190,198,197,189,193,221,219,220,218,211,212,213,214,215,217,216,246,209,244,243,247,245,242,47,48,49,50,51,52,43,53,54,55,44,45,46],"latestChangedDtsFile":"./types/index.d.ts"},"version":"4.9.5"}
\ No newline at end of file
+{"program":{"fileNames":["../../../node_modules/typescript/lib/lib.es5.d.ts","../../../node_modules/typescript/lib/lib.es2015.d.ts","../../../node_modules/typescript/lib/lib.es2016.d.ts","../../../node_modules/typescript/lib/lib.es2017.d.ts","../../../node_modules/typescript/lib/lib.es2018.d.ts","../../../node_modules/typescript/lib/lib.es2019.d.ts","../../../node_modules/typescript/lib/lib.es2020.d.ts","../../../node_modules/typescript/lib/lib.dom.d.ts","../../../node_modules/typescript/lib/lib.es2015.core.d.ts","../../../node_modules/typescript/lib/lib.es2015.collection.d.ts","../../../node_modules/typescript/lib/lib.es2015.generator.d.ts","../../../node_modules/typescript/lib/lib.es2015.iterable.d.ts","../../../node_modules/typescript/lib/lib.es2015.promise.d.ts","../../../node_modules/typescript/lib/lib.es2015.proxy.d.ts","../../../node_modules/typescript/lib/lib.es2015.reflect.d.ts","../../../node_modules/typescript/lib/lib.es2015.symbol.d.ts","../../../node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts","../../../node_modules/typescript/lib/lib.es2016.array.include.d.ts","../../../node_modules/typescript/lib/lib.es2017.object.d.ts","../../../node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2017.string.d.ts","../../../node_modules/typescript/lib/lib.es2017.intl.d.ts","../../../node_modules/typescript/lib/lib.es2017.typedarrays.d.ts","../../../node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts","../../../node_modules/typescript/lib/lib.es2018.asynciterable.d.ts","../../../node_modules/typescript/lib/lib.es2018.intl.d.ts","../../../node_modules/typescript/lib/lib.es2018.promise.d.ts","../../../node_modules/typescript/lib/lib.es2018.regexp.d.ts","../../../node_modules/typescript/lib/lib.es2019.array.d.ts","../../../node_modules/typescript/lib/lib.es2019.object.d.ts","../../../node_modules/typescript/lib/lib.es2019.string.d.ts","../../../node_modules/typescript/lib/lib.es2019.symbol.d.ts","../../../node_modules/typescript/lib/lib.es2019.intl.d.ts","../../../node_modules/typescript/lib/lib.es2020.bigint.d.ts","../../../node_modules/typescript/lib/lib.es2020.date.d.ts","../../../node_modules/typescript/lib/lib.es2020.promise.d.ts","../../../node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2020.string.d.ts","../../../node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts","../../../node_modules/typescript/lib/lib.es2020.intl.d.ts","../../../node_modules/typescript/lib/lib.es2020.number.d.ts","../../../node_modules/typescript/lib/lib.esnext.intl.d.ts","../../../types/eth-ens-namehash.d.ts","../../../types/ethereum-ens-network-map.d.ts","../../../types/global.d.ts","../../../types/single-call-balance-checker-abi.d.ts","../../../types/@metamask/contract-metadata.d.ts","../../../types/@metamask/eth-hd-keyring.d.ts","../../../types/@metamask/eth-simple-keyring.d.ts","../../../types/@metamask/ethjs-provider-http.d.ts","../../../types/@metamask/ethjs-unit.d.ts","../../../types/@metamask/metamask-eth-abis.d.ts","../../../types/eth-json-rpc-infura/src/createprovider.d.ts","../../../types/eth-phishing-detect/src/config.json.d.ts","../../../types/eth-phishing-detect/src/detector.d.ts","../../base-controller/dist/types/basecontrollerv1.d.ts","../../../node_modules/superstruct/dist/error.d.ts","../../../node_modules/superstruct/dist/utils.d.ts","../../../node_modules/superstruct/dist/struct.d.ts","../../../node_modules/superstruct/dist/structs/coercions.d.ts","../../../node_modules/superstruct/dist/structs/refinements.d.ts","../../../node_modules/superstruct/dist/structs/types.d.ts","../../../node_modules/superstruct/dist/structs/utilities.d.ts","../../../node_modules/superstruct/dist/index.d.ts","../../../node_modules/@metamask/utils/dist/types/assert.d.ts","../../../node_modules/@metamask/utils/dist/types/base64.d.ts","../../../node_modules/@metamask/utils/dist/types/hex.d.ts","../../../node_modules/@metamask/utils/dist/types/bytes.d.ts","../../../node_modules/@metamask/utils/dist/types/caip-types.d.ts","../../../node_modules/@metamask/utils/dist/types/checksum.d.ts","../../../node_modules/@metamask/utils/dist/types/coercers.d.ts","../../../node_modules/@metamask/utils/dist/types/collections.d.ts","../../../node_modules/@metamask/utils/dist/types/encryption-types.d.ts","../../../node_modules/@metamask/utils/dist/types/errors.d.ts","../../../node_modules/@metamask/utils/dist/types/json.d.ts","../../../node_modules/@types/node/assert.d.ts","../../../node_modules/@types/node/assert/strict.d.ts","../../../node_modules/@types/node/globals.d.ts","../../../node_modules/@types/node/async_hooks.d.ts","../../../node_modules/@types/node/buffer.d.ts","../../../node_modules/@types/node/child_process.d.ts","../../../node_modules/@types/node/cluster.d.ts","../../../node_modules/@types/node/console.d.ts","../../../node_modules/@types/node/constants.d.ts","../../../node_modules/@types/node/crypto.d.ts","../../../node_modules/@types/node/dgram.d.ts","../../../node_modules/@types/node/diagnostics_channel.d.ts","../../../node_modules/@types/node/dns.d.ts","../../../node_modules/@types/node/dns/promises.d.ts","../../../node_modules/@types/node/dom-events.d.ts","../../../node_modules/@types/node/domain.d.ts","../../../node_modules/@types/node/events.d.ts","../../../node_modules/@types/node/fs.d.ts","../../../node_modules/@types/node/fs/promises.d.ts","../../../node_modules/@types/node/http.d.ts","../../../node_modules/@types/node/http2.d.ts","../../../node_modules/@types/node/https.d.ts","../../../node_modules/@types/node/inspector.d.ts","../../../node_modules/@types/node/module.d.ts","../../../node_modules/@types/node/net.d.ts","../../../node_modules/@types/node/os.d.ts","../../../node_modules/@types/node/path.d.ts","../../../node_modules/@types/node/perf_hooks.d.ts","../../../node_modules/@types/node/process.d.ts","../../../node_modules/@types/node/punycode.d.ts","../../../node_modules/@types/node/querystring.d.ts","../../../node_modules/@types/node/readline.d.ts","../../../node_modules/@types/node/repl.d.ts","../../../node_modules/@types/node/stream.d.ts","../../../node_modules/@types/node/stream/promises.d.ts","../../../node_modules/@types/node/stream/consumers.d.ts","../../../node_modules/@types/node/stream/web.d.ts","../../../node_modules/@types/node/string_decoder.d.ts","../../../node_modules/@types/node/test.d.ts","../../../node_modules/@types/node/timers.d.ts","../../../node_modules/@types/node/timers/promises.d.ts","../../../node_modules/@types/node/tls.d.ts","../../../node_modules/@types/node/trace_events.d.ts","../../../node_modules/@types/node/tty.d.ts","../../../node_modules/@types/node/url.d.ts","../../../node_modules/@types/node/util.d.ts","../../../node_modules/@types/node/v8.d.ts","../../../node_modules/@types/node/vm.d.ts","../../../node_modules/@types/node/wasi.d.ts","../../../node_modules/@types/node/worker_threads.d.ts","../../../node_modules/@types/node/zlib.d.ts","../../../node_modules/@types/node/globals.global.d.ts","../../../node_modules/@types/node/index.d.ts","../../../node_modules/@ethereumjs/common/dist/enums.d.ts","../../../node_modules/@ethereumjs/common/dist/types.d.ts","../../../node_modules/buffer/index.d.ts","../../../node_modules/@ethereumjs/util/dist/constants.d.ts","../../../node_modules/@ethereumjs/util/dist/units.d.ts","../../../node_modules/@ethereumjs/util/dist/address.d.ts","../../../node_modules/@ethereumjs/util/dist/bytes.d.ts","../../../node_modules/@ethereumjs/util/dist/types.d.ts","../../../node_modules/@ethereumjs/util/dist/account.d.ts","../../../node_modules/@ethereumjs/util/dist/withdrawal.d.ts","../../../node_modules/@ethereumjs/util/dist/signature.d.ts","../../../node_modules/@ethereumjs/util/dist/encoding.d.ts","../../../node_modules/@ethereumjs/util/dist/asynceventemitter.d.ts","../../../node_modules/@ethereumjs/util/dist/internal.d.ts","../../../node_modules/@ethereumjs/util/dist/lock.d.ts","../../../node_modules/@ethereumjs/util/dist/provider.d.ts","../../../node_modules/@ethereumjs/util/dist/index.d.ts","../../../node_modules/@ethereumjs/common/dist/common.d.ts","../../../node_modules/@ethereumjs/common/dist/utils.d.ts","../../../node_modules/@ethereumjs/common/dist/index.d.ts","../../../node_modules/@ethereumjs/tx/dist/eip2930transaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/legacytransaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/types.d.ts","../../../node_modules/@ethereumjs/tx/dist/basetransaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/eip1559transaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/transactionfactory.d.ts","../../../node_modules/@ethereumjs/tx/dist/index.d.ts","../../../node_modules/@metamask/utils/dist/types/keyring.d.ts","../../../node_modules/@types/ms/index.d.ts","../../../node_modules/@types/debug/index.d.ts","../../../node_modules/@metamask/utils/dist/types/logging.d.ts","../../../node_modules/@metamask/utils/dist/types/misc.d.ts","../../../node_modules/@metamask/utils/dist/types/number.d.ts","../../../node_modules/@metamask/utils/dist/types/opaque.d.ts","../../../node_modules/@metamask/utils/dist/types/promise.d.ts","../../../node_modules/@metamask/utils/dist/types/time.d.ts","../../../node_modules/@metamask/utils/dist/types/transaction-types.d.ts","../../../node_modules/@metamask/utils/dist/types/versions.d.ts","../../../node_modules/@metamask/utils/dist/types/index.d.ts","../../../node_modules/immer/dist/utils/env.d.ts","../../../node_modules/immer/dist/utils/errors.d.ts","../../../node_modules/immer/dist/types/types-external.d.ts","../../../node_modules/immer/dist/types/types-internal.d.ts","../../../node_modules/immer/dist/utils/common.d.ts","../../../node_modules/immer/dist/utils/plugins.d.ts","../../../node_modules/immer/dist/core/scope.d.ts","../../../node_modules/immer/dist/core/finalize.d.ts","../../../node_modules/immer/dist/core/proxy.d.ts","../../../node_modules/immer/dist/core/immerclass.d.ts","../../../node_modules/immer/dist/core/current.d.ts","../../../node_modules/immer/dist/internal.d.ts","../../../node_modules/immer/dist/plugins/es5.d.ts","../../../node_modules/immer/dist/plugins/patches.d.ts","../../../node_modules/immer/dist/plugins/mapset.d.ts","../../../node_modules/immer/dist/plugins/all.d.ts","../../../node_modules/immer/dist/immer.d.ts","../../base-controller/dist/types/restrictedcontrollermessenger.d.ts","../../base-controller/dist/types/controllermessenger.d.ts","../../base-controller/dist/types/basecontrollerv2.d.ts","../../base-controller/dist/types/index.d.ts","../../controller-utils/dist/types/types.d.ts","../../controller-utils/dist/types/constants.d.ts","../../../node_modules/@metamask/eth-query/index.d.ts","../../../node_modules/@types/bn.js/index.d.ts","../../controller-utils/dist/types/util.d.ts","../../../node_modules/@spruceid/siwe-parser/dist/abnf.d.ts","../../../node_modules/@spruceid/siwe-parser/dist/utils.d.ts","../../../node_modules/@spruceid/siwe-parser/dist/parsers.d.ts","../../controller-utils/dist/types/siwe.d.ts","../../controller-utils/dist/types/index.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/utils.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/classes.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/errors.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/error-constants.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/index.d.ts","../../../node_modules/@metamask/swappable-obj-proxy/dist/types.d.ts","../../../node_modules/@metamask/swappable-obj-proxy/dist/createeventemitterproxy.d.ts","../../../node_modules/@metamask/swappable-obj-proxy/dist/createswappableproxy.d.ts","../../../node_modules/@metamask/swappable-obj-proxy/dist/index.d.ts","../../../node_modules/@types/uuid/index.d.ts","../src/constants.ts","../../../node_modules/@metamask/safe-event-emitter/dist/cjs/index.d.ts","../../json-rpc-engine/dist/types/jsonrpcengine.d.ts","../../json-rpc-engine/dist/types/createasyncmiddleware.d.ts","../../json-rpc-engine/dist/types/createscaffoldmiddleware.d.ts","../../json-rpc-engine/dist/types/getuniqueid.d.ts","../../json-rpc-engine/dist/types/idremapmiddleware.d.ts","../../json-rpc-engine/dist/types/mergemiddleware.d.ts","../../json-rpc-engine/dist/types/index.d.ts","../../eth-json-rpc-provider/dist/types/safe-event-emitter-provider.d.ts","../../eth-json-rpc-provider/dist/types/provider-from-engine.d.ts","../../eth-json-rpc-provider/dist/types/provider-from-middleware.d.ts","../../eth-json-rpc-provider/dist/types/index.d.ts","../../../node_modules/@metamask/eth-block-tracker/dist/blocktracker.d.ts","../../../node_modules/@metamask/eth-block-tracker/dist/pollingblocktracker.d.ts","../../../node_modules/@metamask/eth-block-tracker/dist/subscribeblocktracker.d.ts","../../../node_modules/@metamask/eth-block-tracker/dist/index.d.ts","../../../node_modules/@metamask/eth-json-rpc-infura/dist/types.d.ts","../../../node_modules/@metamask/eth-json-rpc-infura/dist/create-infura-middleware.d.ts","../../../node_modules/@metamask/eth-json-rpc-infura/dist/fetch-config-from-req.d.ts","../../../node_modules/@metamask/eth-json-rpc-infura/dist/create-provider.d.ts","../../../node_modules/@metamask/eth-json-rpc-infura/dist/index.d.ts","../../../node_modules/@metamask/eth-json-rpc-middleware/dist/types.d.ts","../../../node_modules/@metamask/eth-json-rpc-middleware/dist/block-cache.d.ts","../../../node_modules/@metamask/eth-json-rpc-middleware/dist/block-ref-rewrite.d.ts","../../../node_modules/@metamask/eth-json-rpc-middleware/dist/block-ref.d.ts","../../../node_modules/@metamask/eth-json-rpc-middleware/dist/block-tracker-inspector.d.ts","../../../node_modules/@metamask/eth-json-rpc-middleware/dist/fetch.d.ts","../../../node_modules/@metamask/eth-json-rpc-middleware/dist/inflight-cache.d.ts","../../../node_modules/@metamask/eth-json-rpc-middleware/dist/providerasmiddleware.d.ts","../../../node_modules/@metamask/eth-json-rpc-middleware/dist/retryonempty.d.ts","../../../node_modules/@metamask/eth-json-rpc-middleware/dist/wallet.d.ts","../../../node_modules/@metamask/eth-json-rpc-middleware/dist/index.d.ts","../src/types.ts","../src/create-network-client.ts","../src/create-auto-managed-network-client.ts","../src/logger.ts","../src/networkcontroller.ts","../src/index.ts","../../../node_modules/@babel/types/lib/index.d.ts","../../../node_modules/@types/babel__generator/index.d.ts","../../../node_modules/@babel/parser/typings/babel-parser.d.ts","../../../node_modules/@types/babel__template/index.d.ts","../../../node_modules/@types/babel__traverse/index.d.ts","../../../node_modules/@types/babel__core/index.d.ts","../../../node_modules/@types/deep-freeze-strict/index.d.ts","../../../node_modules/@types/eslint/helpers.d.ts","../../../node_modules/@types/estree/index.d.ts","../../../node_modules/@types/json-schema/index.d.ts","../../../node_modules/@types/eslint/index.d.ts","../../../node_modules/@types/graceful-fs/index.d.ts","../../../node_modules/@types/istanbul-lib-coverage/index.d.ts","../../../node_modules/@types/istanbul-lib-report/index.d.ts","../../../node_modules/@types/istanbul-reports/index.d.ts","../../../node_modules/chalk/index.d.ts","../../../node_modules/jest-diff/build/cleanupsemantic.d.ts","../../../node_modules/pretty-format/build/types.d.ts","../../../node_modules/pretty-format/build/index.d.ts","../../../node_modules/jest-diff/build/types.d.ts","../../../node_modules/jest-diff/build/difflines.d.ts","../../../node_modules/jest-diff/build/printdiffs.d.ts","../../../node_modules/jest-diff/build/index.d.ts","../../../node_modules/jest-matcher-utils/build/index.d.ts","../../../node_modules/@types/jest/index.d.ts","../../../node_modules/@types/jest-when/index.d.ts","../../../node_modules/@types/json5/index.d.ts","../../../node_modules/@types/lodash/common/common.d.ts","../../../node_modules/@types/lodash/common/array.d.ts","../../../node_modules/@types/lodash/common/collection.d.ts","../../../node_modules/@types/lodash/common/date.d.ts","../../../node_modules/@types/lodash/common/function.d.ts","../../../node_modules/@types/lodash/common/lang.d.ts","../../../node_modules/@types/lodash/common/math.d.ts","../../../node_modules/@types/lodash/common/number.d.ts","../../../node_modules/@types/lodash/common/object.d.ts","../../../node_modules/@types/lodash/common/seq.d.ts","../../../node_modules/@types/lodash/common/string.d.ts","../../../node_modules/@types/lodash/common/util.d.ts","../../../node_modules/@types/lodash/index.d.ts","../../../node_modules/@types/minimatch/index.d.ts","../../../node_modules/@types/parse-json/index.d.ts","../../../node_modules/@types/pbkdf2/index.d.ts","../../../node_modules/@types/prettier/index.d.ts","../../../node_modules/@types/punycode/index.d.ts","../../../node_modules/@types/readable-stream/node_modules/safe-buffer/index.d.ts","../../../node_modules/@types/readable-stream/index.d.ts","../../../node_modules/@types/secp256k1/index.d.ts","../../../node_modules/@types/semver/classes/semver.d.ts","../../../node_modules/@types/semver/functions/parse.d.ts","../../../node_modules/@types/semver/functions/valid.d.ts","../../../node_modules/@types/semver/functions/clean.d.ts","../../../node_modules/@types/semver/functions/inc.d.ts","../../../node_modules/@types/semver/functions/diff.d.ts","../../../node_modules/@types/semver/functions/major.d.ts","../../../node_modules/@types/semver/functions/minor.d.ts","../../../node_modules/@types/semver/functions/patch.d.ts","../../../node_modules/@types/semver/functions/prerelease.d.ts","../../../node_modules/@types/semver/functions/compare.d.ts","../../../node_modules/@types/semver/functions/rcompare.d.ts","../../../node_modules/@types/semver/functions/compare-loose.d.ts","../../../node_modules/@types/semver/functions/compare-build.d.ts","../../../node_modules/@types/semver/functions/sort.d.ts","../../../node_modules/@types/semver/functions/rsort.d.ts","../../../node_modules/@types/semver/functions/gt.d.ts","../../../node_modules/@types/semver/functions/lt.d.ts","../../../node_modules/@types/semver/functions/eq.d.ts","../../../node_modules/@types/semver/functions/neq.d.ts","../../../node_modules/@types/semver/functions/gte.d.ts","../../../node_modules/@types/semver/functions/lte.d.ts","../../../node_modules/@types/semver/functions/cmp.d.ts","../../../node_modules/@types/semver/functions/coerce.d.ts","../../../node_modules/@types/semver/classes/comparator.d.ts","../../../node_modules/@types/semver/classes/range.d.ts","../../../node_modules/@types/semver/functions/satisfies.d.ts","../../../node_modules/@types/semver/ranges/max-satisfying.d.ts","../../../node_modules/@types/semver/ranges/min-satisfying.d.ts","../../../node_modules/@types/semver/ranges/to-comparators.d.ts","../../../node_modules/@types/semver/ranges/min-version.d.ts","../../../node_modules/@types/semver/ranges/valid.d.ts","../../../node_modules/@types/semver/ranges/outside.d.ts","../../../node_modules/@types/semver/ranges/gtr.d.ts","../../../node_modules/@types/semver/ranges/ltr.d.ts","../../../node_modules/@types/semver/ranges/intersects.d.ts","../../../node_modules/@types/semver/ranges/simplify.d.ts","../../../node_modules/@types/semver/ranges/subset.d.ts","../../../node_modules/@types/semver/internals/identifiers.d.ts","../../../node_modules/@types/semver/index.d.ts","../../../node_modules/@types/sinonjs__fake-timers/index.d.ts","../../../node_modules/@types/sinon/index.d.ts","../../../node_modules/@types/stack-utils/index.d.ts","../../../node_modules/@types/yargs-parser/index.d.ts","../../../node_modules/@types/yargs/index.d.ts"],"fileInfos":[{"version":"8730f4bf322026ff5229336391a18bcaa1f94d4f82416c8b2f3954e2ccaae2ba","affectsGlobalScope":true},"dc47c4fa66b9b9890cf076304de2a9c5201e94b740cffdf09f87296d877d71f6","7a387c58583dfca701b6c85e0adaf43fb17d590fb16d5b2dc0a2fbd89f35c467","8a12173c586e95f4433e0c6dc446bc88346be73ffe9ca6eec7aa63c8f3dca7f9","5f4e733ced4e129482ae2186aae29fde948ab7182844c3a5a51dd346182c7b06","4b421cbfb3a38a27c279dec1e9112c3d1da296f77a1a85ddadf7e7a425d45d18","1fc5ab7a764205c68fa10d381b08417795fc73111d6dd16b5b1ed36badb743d9",{"version":"3aafcb693fe5b5c3bd277bd4c3a617b53db474fe498fc5df067c5603b1eebde7","affectsGlobalScope":true},{"version":"adb996790133eb33b33aadb9c09f15c2c575e71fb57a62de8bf74dbf59ec7dfb","affectsGlobalScope":true},{"version":"8cc8c5a3bac513368b0157f3d8b31cfdcfe78b56d3724f30f80ed9715e404af8","affectsGlobalScope":true},{"version":"cdccba9a388c2ee3fd6ad4018c640a471a6c060e96f1232062223063b0a5ac6a","affectsGlobalScope":true},{"version":"c5c05907c02476e4bde6b7e76a79ffcd948aedd14b6a8f56e4674221b0417398","affectsGlobalScope":true},{"version":"5f406584aef28a331c36523df688ca3650288d14f39c5d2e555c95f0d2ff8f6f","affectsGlobalScope":true},{"version":"22f230e544b35349cfb3bd9110b6ef37b41c6d6c43c3314a31bd0d9652fcec72","affectsGlobalScope":true},{"version":"7ea0b55f6b315cf9ac2ad622b0a7813315bb6e97bf4bb3fbf8f8affbca7dc695","affectsGlobalScope":true},{"version":"3013574108c36fd3aaca79764002b3717da09725a36a6fc02eac386593110f93","affectsGlobalScope":true},{"version":"eb26de841c52236d8222f87e9e6a235332e0788af8c87a71e9e210314300410a","affectsGlobalScope":true},{"version":"3be5a1453daa63e031d266bf342f3943603873d890ab8b9ada95e22389389006","affectsGlobalScope":true},{"version":"17bb1fc99591b00515502d264fa55dc8370c45c5298f4a5c2083557dccba5a2a","affectsGlobalScope":true},{"version":"7ce9f0bde3307ca1f944119f6365f2d776d281a393b576a18a2f2893a2d75c98","affectsGlobalScope":true},{"version":"6a6b173e739a6a99629a8594bfb294cc7329bfb7b227f12e1f7c11bc163b8577","affectsGlobalScope":true},{"version":"81cac4cbc92c0c839c70f8ffb94eb61e2d32dc1c3cf6d95844ca099463cf37ea","affectsGlobalScope":true},{"version":"b0124885ef82641903d232172577f2ceb5d3e60aed4da1153bab4221e1f6dd4e","affectsGlobalScope":true},{"version":"0eb85d6c590b0d577919a79e0084fa1744c1beba6fd0d4e951432fa1ede5510a","affectsGlobalScope":true},{"version":"da233fc1c8a377ba9e0bed690a73c290d843c2c3d23a7bd7ec5cd3d7d73ba1e0","affectsGlobalScope":true},{"version":"d154ea5bb7f7f9001ed9153e876b2d5b8f5c2bb9ec02b3ae0d239ec769f1f2ae","affectsGlobalScope":true},{"version":"bb2d3fb05a1d2ffbca947cc7cbc95d23e1d053d6595391bd325deb265a18d36c","affectsGlobalScope":true},{"version":"c80df75850fea5caa2afe43b9949338ce4e2de086f91713e9af1a06f973872b8","affectsGlobalScope":true},{"version":"9d57b2b5d15838ed094aa9ff1299eecef40b190722eb619bac4616657a05f951","affectsGlobalScope":true},{"version":"6c51b5dd26a2c31dbf37f00cfc32b2aa6a92e19c995aefb5b97a3a64f1ac99de","affectsGlobalScope":true},{"version":"6e7997ef61de3132e4d4b2250e75343f487903ddf5370e7ce33cf1b9db9a63ed","affectsGlobalScope":true},{"version":"2ad234885a4240522efccd77de6c7d99eecf9b4de0914adb9a35c0c22433f993","affectsGlobalScope":true},{"version":"5e5e095c4470c8bab227dbbc61374878ecead104c74ab9960d3adcccfee23205","affectsGlobalScope":true},{"version":"09aa50414b80c023553090e2f53827f007a301bc34b0495bfb2c3c08ab9ad1eb","affectsGlobalScope":true},{"version":"d7f680a43f8cd12a6b6122c07c54ba40952b0c8aa140dcfcf32eb9e6cb028596","affectsGlobalScope":true},{"version":"3787b83e297de7c315d55d4a7c546ae28e5f6c0a361b7a1dcec1f1f50a54ef11","affectsGlobalScope":true},{"version":"e7e8e1d368290e9295ef18ca23f405cf40d5456fa9f20db6373a61ca45f75f40","affectsGlobalScope":true},{"version":"faf0221ae0465363c842ce6aa8a0cbda5d9296940a8e26c86e04cc4081eea21e","affectsGlobalScope":true},{"version":"06393d13ea207a1bfe08ec8d7be562549c5e2da8983f2ee074e00002629d1871","affectsGlobalScope":true},{"version":"2768ef564cfc0689a1b76106c421a2909bdff0acbe87da010785adab80efdd5c","affectsGlobalScope":true},{"version":"b248e32ca52e8f5571390a4142558ae4f203ae2f94d5bac38a3084d529ef4e58","affectsGlobalScope":true},{"version":"52d1bb7ab7a3306fd0375c8bff560feed26ed676a5b0457fa8027b563aecb9a4","affectsGlobalScope":true},"70bbfaec021ac4a0c805374225b55d70887f987df8b8dd7711d79464bb7b4385","869089d60b67219f63e6aca810284c89bae1b384b5cbc7ce64e53d82ad223ed5",{"version":"18338b6a4b920ec7d49b4ffafcbf0fa8a86b4bfd432966efd722dab611157cf4","affectsGlobalScope":true},"62a0875a0397b35a2364f1d401c0ce17975dfa4d47bf6844de858ae04da349f9","ee7491d0318d1fafcba97d5b72b450eb52671570f7a4ecd9e8898d40eaae9472","e3e7d217d89b380c1f34395eadc9289542851b0f0a64007dfe1fb7cf7423d24e","fd79909e93b4d50fd0ed9f3d39ddf8ba0653290bac25c295aac49f6befbd081b","345a9cc2945406f53051cd0e9b51f82e1e53929848eab046fdda91ee8aa7da31","9debe2de883da37a914e5e784a7be54c201b8f1d783822ad6f443ff409a5ea21","dee5d5c5440cda1f3668f11809a5503c30db0476ad117dd450f7ba5a45300e8f","f5e396c1424c391078c866d6f84afe0b4d2f7f85a160b9c756cd63b5b1775d93","5caa6f4fff16066d377d4e254f6c34c16540da3809cd66cd626a303bc33c419f","730d055528bdf12c8524870bb33d237991be9084c57634e56e5d8075f6605e02","75b22c74010ba649de1a1676a4c4b8b5bb4294fecd05089e2094429b16d7840c","5615ccf831db2ffc82145243081ebdb60ea8e1005ee8f975d1c0c1401a9c894e","38682ed3630bb6ecdace80d5a9adc811fc20a419f1940446e306c3a020d083b9","cc182e6e4f691cd6f7bf7cb491247a4c7818f9f1cb2db1d45c65ff906e3f741b","a50599c08934a62f11657bdbe0dc929ab66da1b1f09974408fd9a33ec1bb8060","5a20e7d6c630b91be15e9b837853173829d00273197481dc8d3e94df61105a71","8d478048d71cc16f806d4b71b252ecb67c7444ccf4f4b09b29a312712184f859","e0eda929c6b9b628cdeb0e54cd3582cb97e64f28aab34612fc1431c545899584","9df4662ca3dbc2522bc115833ee04faa1afbb4e249a85ef4a0a09c621346bd08","b25d9065cf1c1f537a140bbc508e953ed2262f77134574c432d206ff36f4bdbf","1b103313097041aa9cd705a682c652f08613cb5cf8663321061c0902f845e81c","68ccec8662818911d8a12b8ed028bc5729fb4f1d34793c4701265ba60bc73cf4","5f85b8b79dc4d36af672c035b2beb71545de63a5d60bccbeee64c260941672ab","b3d48529ae61dc27d0bfbfa2cb3e0dff8189644bd155bdf5df1e8e14669f7043","40fe4b689225816b31fe5794c0fbf3534568819709e40295ead998a2bc1ab237","f65b5e33b9ad545a1eebbd6afe857314725ad42aaf069913e33f928ab3e4990a","fb6f2a87beb7fb1f4c2b762d0c76a9459fc91f557231569b0ee21399e22aa13d","31c858dc85996fac4b7fa944e1016d5c72f514930a72357ab5001097bf6511c7","3de30a871b3340be8b679c52aa12f90dd1c8c60874517be58968fdbcc4d79445","6fd985bd31eaf77542625306fb0404d32bff978990f0a06428e5f0b9a3b58109","5b3cd03ae354ea96eff1f74d7c410fe4852e6382227e8b0ecf87ab5e3a5bbcd4","7394959e5a741b185456e1ef5d64599c36c60a323207450991e7a42e08911419",{"version":"056097110efd16869ec118cedb44ecbac9a019576eee808d61304ca6d5cb2cbe","affectsGlobalScope":true},"f51b4042a3ac86f1f707500a9768f88d0b0c1fc3f3e45a73333283dea720cdc6",{"version":"6fb8358e10ed92a7f515b7d79da3904c955a3ffd4e14aa9df6f0ea113041f1cf","affectsGlobalScope":true},"45c831238c6dac21c72da5f335747736a56a3847192bf03c84b958a7e9ec93e2","661a11d16ad2e3543a77c53bcd4017ee9a450f47ab7def3ab493a86eae4d550c",{"version":"8cdc646cec7819581ef343b83855b1bfe4fe674f2c84f4fb8dc90d82fb56bd3a","affectsGlobalScope":true},"a40826e8476694e90da94aa008283a7de50d1dafd37beada623863f1901cb7fb","9dd56225cc2d8cb8fe5ceb0043ff386987637e12fecc6078896058a99deae284","2375ed4b439215aa3b6d0c6fd175c78a4384b30cb43cbadaecbf0a18954c98cb","7693b90b3075deaccafd5efb467bf9f2b747a3075be888652ef73e64396d8628","41231da15bb5e3e806a8395bd15c7befd2ec90f9f4e3c9d0ae1356bccb76dbb0","fccfef201d057cb407fa515311bd608549bab6c7b8adcf8f2df31f5d3b796478",{"version":"ee1ee365d88c4c6c0c0a5a5701d66ebc27ccd0bcfcfaa482c6e2e7fe7b98edf7","affectsGlobalScope":true},"5f20d20b7607174caf1a6da9141aeb9f2142159ae2410ca30c7a0fccd1d19c99",{"version":"464762c6213566d072f1ced5e8e9a954785ec5e53883b7397198abb5ef5b8f71","affectsGlobalScope":true},"6387920dc3e18927335b086deec75bf8e50f879a5e273d32ee7bb7a55ba50572","9bba37424094688c4663c177a1379b229f919b8912889a472f32fdc5f08ddb4d","29a4be13b3a30d3e66667b75c58ec61fb2df8fa0422534fdee3cfb30c5dbf450","83366d901beda79d6eb37aaaf6ca248dcd88946302b2a7d975590783be51e88e","bf268a0aea37ad4ae3b7a9b58559190b6fc01ea16a31e35cd05817a0a60f895a","43ec77c369473e92e2ecebf0554a0fdaa9c256644a6070f28228dfcceec77351",{"version":"d7dad6db394a3d9f7b49755e4b610fbf8ed6eb0c9810ae5f1a119f6b5d76de45","affectsGlobalScope":true},"95ed02bacb4502c985b69742ec82a4576d4ff4a6620ecc91593f611d502ae546","bf755525c4e6f85a970b98c4755d98e8aa1b6dbd83a5d8fcc57d3d497351b936","dd67d2b5e4e8a182a38de8e69fb736945eaa4588e0909c14e01a14bd3cc1fd1e",{"version":"28084e15b63e6211769db2fe646d8bc5c4c6776321e0deffe2d12eefd52cb6b9","affectsGlobalScope":true},{"version":"aed37dabf86c99d6c8508700576ecede86688397bc12523541858705a0c737c2","affectsGlobalScope":true},"cc6ef5733d4ea6d2e06310a32dffd2c16418b467c5033d49cecc4f3a25de7497","94768454c3348b6ebe48e45fbad8c92e2bb7af4a35243edbe2b90823d0bd7f9a","0be79b3ff0f16b6c2f9bc8c4cc7097ea417d8d67f8267f7e1eec8e32b548c2ff","1c61ffa3a71b77363b30d19832c269ef62fba787f5610cac7254728d3b69ab2e","84da3c28344e621fd1d591f2c09e9595292d2b70018da28a553268ac122597d4","269929a24b2816343a178008ac9ae9248304d92a8ba8e233055e0ed6dbe6ef71","6e191fea1db6e9e4fa828259cf489e820ec9170effff57fb081a2f3295db4722","aed943465fbce1efe49ee16b5ea409050f15cd8eaf116f6fadb64ef0772e7d95","70d08483a67bf7050dbedace398ef3fee9f436fcd60517c97c4c1e22e3c6f3e8","c40fdf7b2e18df49ce0568e37f0292c12807a0748be79e272745e7216bed2606",{"version":"e933de8143e1d12dd51d89b398760fd5a9081896be366dad88a922d0b29f3c69","affectsGlobalScope":true},"4e228e78c1e9b0a75c70588d59288f63a6258e8b1fe4a67b0c53fe03461421d9","b38d55d08708c2410a3039687db70b4a5bfa69fc4845617c313b5a10d9c5c637","205d50c24359ead003dc537b9b65d2a64208dfdffe368f403cf9e0357831db9e","1265fddcd0c68be9d2a3b29805d0280484c961264dd95e0b675f7bd91f777e78",{"version":"a05e2d784c9be7051c4ac87a407c66d2106e23490c18c038bbd0712bde7602fd","affectsGlobalScope":true},{"version":"df90b9d0e9980762da8daf8adf6ffa0c853e76bfd269c377be0d07a9ad87acd2","affectsGlobalScope":true},"cf434b5c04792f62d6f4bdd5e2c8673f36e638e910333c172614d5def9b17f98","1d65d4798df9c2df008884035c41d3e67731f29db5ecb64cd7378797c7c53a2f","0faee6b555890a1cb106e2adc5d3ffd89545b1da894d474e9d436596d654998f","c6c01ea1c42508edf11a36d13b70f6e35774f74355ba5d358354d4a77cc67ea1","867f95abf1df444aab146b19847391fc2f922a55f6a970a27ed8226766cee29f",{"version":"ab9b9a36e5284fd8d3bf2f7d5fcbc60052f25f27e4d20954782099282c60d23e","affectsGlobalScope":true},"b0297b09e607bec9698cac7cf55463d6731406efb1161ee4d448293b47397c84","175323e2a79a6076e0bada8a390d535a3ea817158bf1b1f46e31efca9028a0a2","7a10053aadc19335532a4d02756db4865974fd69bea5439ddcc5bfdf062d9476","4967529644e391115ca5592184d4b63980569adf60ee685f968fd59ab1557188","aed9e712a9b168345362e8f3a949f16c99ca1e05d21328f05735dfdbb24414ef","b04fe6922ed3db93afdbd49cdda8576aa75f744592fceea96fb0d5f32158c4f5","ed8d6c8de90fc2a4faaebc28e91f2469928738efd5208fb75ade0fa607e892b7","d7c52b198d680fe65b1a8d1b001f0173ffa2536ca2e7082431d726ce1f6714cd","c07f251e1c4e415a838e5498380b55cfea94f3513229de292d2aa85ae52fc3e9","0ed401424892d6bf294a5374efe512d6951b54a71e5dd0290c55b6d0d915f6f7","b945be6da6a3616ef3a250bfe223362b1c7c6872e775b0c4d82a1bf7a28ff902","beea49237dd7c7110fabf3c7509919c9cb9da841d847c53cac162dc3479e2f87","0f45f8a529c450d8f394106cc622bff79e44a1716e1ac9c3cc68b43f7ecf65ee","c624ce90b04c27ce4f318ba6330d39bde3d4e306f0f497ce78d4bda5ab8e22ca","9b8253aa5cb2c82d505f72afdbf96e83b15cc6b9a6f4fadbbbab46210d5f1977","86a8f52e4b1ac49155e889376bcfa8528a634c90c27fec65aa0e949f77b740c5","aab5dd41c1e2316cc0b42a7dd15684f8582d5a1d16c0516276a2a8a7d0fecd9c","59948226626ee210045296ba1fc6cb0fe748d1ff613204e08e7157ab6862dee7","ec3e54d8b713c170fdc8110a7e4a6a97513a7ab6b05ac9e1100cb064d2bb7349","43beb30ecb39a603fde4376554887310b0699f25f7f39c5c91e3147b51bb3a26","666b77d7f06f49da114b090a399abbfa66d5b6c01a3fd9dc4f063a52ace28507","31997714a93fbc570f52d47d6a8ebfb021a34a68ea9ba58bbb69cdec9565657e","6032e4262822160128e644de3fc4410bcd7517c2f137525fd2623d2bb23cb0d3","8bd5c9b1016629c144fd228983395b9dbf0676a576716bc3d316cab612c33cd5","2ed90bd3925b23aed8f859ffd0e885250be0424ca2b57e9866dabef152e1d6b7","93f6bd17d92dab9db7897e1430a5aeaa03bcf51623156213d8397710367a76ce","3f62b770a42e8c47c7008726f95aa383e69d97e85e680d237b99fcb0ee601dd8","5b84cfe78028c35c3bb89c042f18bf08d09da11e82d275c378ae4d07d8477e6c","980d21b0081cbf81774083b1e3a46f4bbdcd2b68858df0f66d7fad9c82bc34bc","68cc8d6fcc2f270d7108f02f3ebc59480a54615be3e09a47e14527f349e9d53e","3eb11dbf3489064a47a2e1cf9d261b1f100ef0b3b50ffca6c44dd99d6dd81ac1","b17f3bb7d8333479c7e45e5f3d876761b9bca58f97594eca3f6a944fd825e632","3c1f1236cce6d6e0c4e2c1b4371e6f72d7c14842ecd76a98ed0748ee5730c8f3","6d7f58d5ea72d7834946fd7104a734dc7d40661be8b2e1eaced1ddce3268ebaf","4c26222991e6c97d5a8f541d4f2c67585eda9e8b33cf9f52931b098045236e88","277983d414aa99d78655186c3ee1e1c38c302e336aff1d77b47fcdc39d8273fe","47383b45796d525a4039cd22d2840ac55a1ff03a43d027f7f867ba7314a9cf53","6548773b3abbc18de29176c2141f766d4e437e40596ee480447abf83575445ad","6ddd27af0436ce59dd4c1896e2bfdb2bdb2529847d078b83ce67a144dff05491","816264799aef3fd5a09a3b6c25217d5ec26a9dfc7465eac7d6073bcdc7d88f3f","4df0891b133884cd9ed752d31c7d0ec0a09234e9ed5394abffd3c660761598db","b603b62d3dcd31ef757dc7339b4fa8acdbca318b0fb9ac485f9a1351955615f9","e642bd47b75ad6b53cbf0dfd7ddfa0f120bd10193f0c58ec37d87b59bf604aca","be90b24d2ee6f875ce3aaa482e7c41a54278856b03d04212681c4032df62baf9","78f5ff400b3cb37e7b90eef1ff311253ed31c8cb66505e9828fad099bffde021","372c47090e1131305d163469a895ff2938f33fa73aad988df31cd31743f9efb6","71c67dc6987bdbd5599353f90009ff825dd7db0450ef9a0aee5bb0c574d18512","6f12403b5eca6ae7ca8e3efe3eeb9c683b06ce3e3844ccfd04098d83cd7e4957","282c535df88175d64d9df4550d2fd1176fd940c1c6822f1e7584003237f179d3","c3a4752cf103e4c6034d5bd449c8f9d5e7b352d22a5f8f9a41a8efb11646f9c2","11a9e38611ac3c77c74240c58b6bd64a0032128b29354e999650f1de1e034b1c","4ed103ca6fff9cb244f7c4b86d1eb28ce8069c32db720784329946731badb5bb","d738f282842970e058672663311c6875482ee36607c88b98ffb6604fba99cb2a","ec859cd8226aa623e41bbb47c249a55ee16dc1b8647359585244d57d3a5ed0c7","8891c6e959d253a66434ff5dc9ae46058fb3493e84b4ca39f710ef2d350656b1","c4463cf02535444dcbc3e67ecd29f1972490f74e49957d6fd4282a1013796ba6","0cb0a957ff02de0b25fd0f3f37130ca7f22d1e0dea256569c714c1f73c6791f8","2f5075dc512d51786b1ba3b1696565641dfaae3ac854f5f13d61fa12ef81a47e","ca3353cc82b1981f0d25d71d7432d583a6ef882ccdea82d65fbe49af37be51cb","50679a8e27aacf72f8c40bcab15d7ef5e83494089b4726b83eec4554344d5cdc","45351e0d51780b6f4088277a4457b9879506ee2720a887de232df0f1efcb33d8","5d697a4b315cc5bb3042ae869abffd10c3b0d7b182cda0e4c45d8819937e5796","89b040dec8fcfc1de98827e1f4d4977e6ff5d3302c6790e9f10b54b916e1c742","6ee58aa536dabb19b09bc036f1abe83feb51e13d63b23d30b2d0631a2de99b8f","8aceb205dcc6f814ad99635baf1e40b6e01d06d3fe27b72fd766c6d0b8c0c600","299567f84bfedd1468dca2755a829cb19e607a6811673788807dc8921e211bc9","795d9fb85aad92221504db74dd179b506bd189bba0c104426f7e7bb8a66ffee5","1311bc194e0a69fe61031e852c1c0b439e2a2a3d1d5e2d8ff795499b9f283459","4b7ce19369d7e7fae76720c2c6c7f671bf3fa0f7093edb864f1ac358ca7c456c","c972ef44deca1fa8fab465915ffa00f82e126aacf3dfc8979c03b1b066ce5bb6","30285a1011c6d6b52f3ba3abb0a984be8148c05cdefb8eb6eb562335a3991f35","9f9e5bae412fa5909fae636d6733aee27a108cc2ed5b13980611016336774d3c","662fe197bba64bd3f17ee118058cd2d0d2dbe33d7c0c865fd6365d90bfc44e1e","030519c351f800551cac2658038804969ca4584d2c0175a710602ac234ca1340","0278a6939ca83cd040b08ff8c5fc7838b6693ddc52f22526bf158e6b10e0246c","c2d6206e5ba4fd3063b01218c2b3b997afc1cfbeb49fcee991fa8595842ce53d","8e7adb22c0adecf7464861fc58ae3fc617b41ffbd70c97aa8493dc0966a82273","755f3cd1d9c1b564cff090e3b0e29200ae55690a91b87cb9e7a64c2dbeb314d3","d6bb7e0a6877b7856c183bff13d09dd9ae599ea43c6f6b33d3d5f72a830ed460","f1b51ae93c762d7c43f559933cd4842dd870367e8d92e90704ffa685dd5b29a3","fab58e600970e66547644a44bc9918e3223aa2cbd9e8763cec004b2cfb48827e",{"version":"12accaad8d0630e27afcee6db467be3587027b92d8a78a5ea40d98ce879db790","signature":"e3539189d512442af177f3c8c49e9cc56834ae05f3ed125491baae619d4c526f"},"fcc8beef29f39f09b1d9c9f99c42f9fed605ab1c28d2a630185f732b9ba53763","d6e6620a30d582182acc3f0a992a0c311adc589f111096aea11ab83fc09a5ccc","6213b8f686f56beab22b59a0f468590fd3a4c5fa931236a017efeca91d7c9584","c451cec9a588b1f105a5ea2c6063d4fca112b9d70105cacdadda0e1ef67e9379","cb047832dc68f5a2c41c62c5e95ddcacbae3a8b034d40cd15319a8cb7f25104a","980336ccdfc3c08f3c3b201aa6662e6016e20f15847f8465b68f3e8e67b4665c","5a3493939995f46ff3d9073cd534fb8961c3bf4e08c71db27066ff03d906dea8","bb5a2ac327605ebebf831c469b05bd34a33a6a46ee8c1edd9f3310aad32cf6a1","bf5d041f2440b4a9391e2b5eb3b8d94cbf1e3b8ff4703b6539d4e65e758c8f37","8516469eb90e723b0eb03df1be098f7e6a4709f6f48fd4532868d20a0a934f6e","d60e9ab369a72d234aac49adbe2900d8ef1408a6ea4db552cf2a48c9d8d6a1bc","0ebb4698803f01e2e7df6acce572fff068f4a20c47221721dafd70a27e372831","03460a54d0e0481d1e11097f66ad43f054bc95efdafe5f81bbc7a82be181af75","ded24ddc7157689a5aa14bd651272ab8cd6e7812da2196a65d8c5e63131cfb23","2cea9689efa8591732096235abe7f084fc29c92badd5b0897a5e876b77e71887","4ed4e504126014fee13aaef5e3fc140f2ff7031ff3a8b5386717905820ea2d09","9f99927996dec2b673c7dcf314ad3fc2d96b3097016d99e28ca25314e19df2c1","accf5b0acb7a341cf9699960157059c95c40842b7b3312ab19053c610cbde977","8d27ef959532cab3f4313ba2f1e66d9c1c159539faa653c3cef848a457939726","a4fcdbc70e4d139fb80f8c99789aea5ad42e18c8ffd034bfe44ab63644471cc7","81859dcda72b45168a93fefe8bf6d62a4eb4032694def53a3c2ccb7f07326d8f","827abdfc5e85e0d5b1959167928bd2f9ca5a684a2b64e054d291571f7e632d4c","84605b003c9b842f5d4d5d068f7d92f382d3b5c1565375eef3136ed5f03d7ee4","1679f0a7b02d9f185ac1ea0ef4c9197d4c6d299de3e433ce4b8679a58e34c9e5","66ee590a1a296344449ac904bf56c03b3075c4f3c2479db655cc1ce9407eb58b","d067e051d72e0d79389c52cb28bb23d11b97c2bd7dfaba12083ea544d924ab7a","1d44112639c6691d697eaa88c1bf738a4438063f1ecbfbc1208b6d3040d39eb7","f957b018293727b85e13d0a0c8f15556e97cf6fa6cd6b3c5c47a18d9173155b1","0763c0248d05cfd5fea25f97aa10d51084a36a8893985e0537c48e4ab1376326","b4608db340ab2c69bc4d426d06c3bf4f8a04f4e2c40fa30905581336bf3f242c","a55ab6e38e964b1000ab2fbab89e41996375c83c9d1c79d2f243c5df901289b9","4f07dc7f29a2f794c62996d32f148e973ba146ce59a16d4ad3e01c5e3018891f",{"version":"9eb6c0f28550944f99f6d1fc1985f29ac121ba0b57a399db12a59f53e0d327d8","signature":"689e53365e2e5af801be2af3fad66936b989c4fffa9dfd94f91885f11afa05d2"},{"version":"86ee1535397ec5bc983ffe847ed6ea66c704084745fafc0b81ef2e2b9ea0a6c4","signature":"2901396d9707d63ee1d6dcd60cfe70fe64bdd78b13696cddefd8872393d1b96a"},{"version":"3d42a9b4218d715d9909898927a2f6ab7f1738178e7eb81ddd3d7f7b1392e8e9","signature":"e10b1f5cd5b943bdffdfa8165d796837e13b58718a1faee5485652a0fbedde58"},{"version":"ddfd4bd8fb8f640b88a39262cde2d22c73b0149b3cbe1574bc2da48a176f612c","signature":"7bd3844e77367d48f1f9ea69d39b92ff9d086dc499da91fe8df78406b2e3f1fc"},{"version":"44ed40f003326a345304c67531c21af1657e57dad346928d1b94f667832b75d5","signature":"f68ac7de59127ba50080e323e1e16606b761939cc3b82079f2db9170592fa997"},"d68cb13e3cde9d7fc02ecc3f258de77f5e7da54b6f5513ae075f2fd8e1f0d5d9","4489c6a9fde8934733aa7df6f7911461ee6e9e4ad092736bd416f6b2cc20b2c6","2c8e55457aaf4902941dfdba4061935922e8ee6e120539c9801cd7b400fae050","8041cfce439ff29d339742389de04c136e3029d6b1817f07b2d7fcbfb7534990","670a76db379b27c8ff42f1ba927828a22862e2ab0b0908e38b671f0e912cc5ed","9d38964b57191567a14b396422c87488cecd48f405c642daa734159875ee81d9","069bebfee29864e3955378107e243508b163e77ab10de6a5ee03ae06939f0bb9","8c95f96ccd4be0674944077aec1e4f2cccd515ca06d4327562dd017250e7d3fc",{"version":"64d4b35c5456adf258d2cf56c341e203a073253f229ef3208fc0d5020253b241","affectsGlobalScope":true},"ee7d8894904b465b072be0d2e4b45cf6b887cdba16a467645c4e200982ece7ea","f3d8c757e148ad968f0d98697987db363070abada5f503da3c06aefd9d4248c1","bc3cba7b0af2d52e7425299aee518db479d44004eff6fbbd206d1ee7e5ec3fb5","afe73051ff6a03a9565cbd8ebb0e956ee3df5e913ad5c1ded64218aabfa3dcb5","035a5df183489c2e22f3cf59fc1ed2b043d27f357eecc0eb8d8e840059d44245","a4809f4d92317535e6b22b01019437030077a76fec1d93b9881c9ed4738fcc54","5f53fa0bd22096d2a78533f94e02c899143b8f0f9891a46965294ee8b91a9434","0d14fa22c41fdc7277e6f71473b20ebc07f40f00e38875142335d5b63cdfc9d2","d8aab31ba8e618cc3eea10b0945de81cb93b7e8150a013a482332263b9305322","462bccdf75fcafc1ae8c30400c9425e1a4681db5d605d1a0edb4f990a54d8094","5923d8facbac6ecf7c84739a5c701a57af94a6f6648d6229a6c768cf28f0f8cb","7adecb2c3238794c378d336a8182d4c3dd2c4fa6fa1785e2797a3db550edea62","dc12dc0e5aa06f4e1a7692149b78f89116af823b9e1f1e4eae140cd3e0e674e6","1bfc6565b90c8771615cd8cfcf9b36efc0275e5e83ac7d9181307e96eb495161","8a8a96898906f065f296665e411f51010b51372fa260d5373bf9f64356703190","7f82ef88bdb67d9a850dd1c7cd2d690f33e0f0acd208e3c9eba086f3670d4f73",{"version":"ccfd8774cd9b929f63ff7dcf657977eb0652e3547f1fcac1b3a1dc5db22d4d58","affectsGlobalScope":true},"d92dc90fecd2552db74d8dc3c6fb4db9145b2aa0efe2c127236ba035969068d4","96d14f21b7652903852eef49379d04dbda28c16ed36468f8c9fa08f7c14c9538","b8442e9db28157344d1bc5d8a5a256f1692de213f0c0ddeb84359834015a008c","458111fc89d11d2151277c822dfdc1a28fa5b6b2493cf942e37d4cd0a6ee5f22","da2b6356b84a40111aaecb18304ea4e4fcb43d70efb1c13ca7d7a906445ee0d3","187119ff4f9553676a884e296089e131e8cc01691c546273b1d0089c3533ce42","febf0b2de54781102b00f61653b21377390a048fbf5262718c91860d11ff34a6","6f294731b495c65ecf46a5694f0082954b961cf05463bea823f8014098eaffa0","0aaef8cded245bf5036a7a40b65622dd6c4da71f7a35343112edbe112b348a1e","00baffbe8a2f2e4875367479489b5d43b5fc1429ecb4a4cc98cfc3009095f52a","68a0d0c508e1b6d8d23a519a8a0a3303dc5baa4849ca049f21e5bad41945e3fc","3c92b6dfd43cc1c2485d9eba5ff0b74a19bb8725b692773ef1d66dac48cda4bd","b03afe4bec768ae333582915146f48b161e567a81b5ebc31c4d78af089770ac9","df996e25faa505f85aeb294d15ebe61b399cf1d1e49959cdfaf2cc0815c203f9","4f6a12044ee6f458db11964153830abbc499e73d065c51c329ec97407f4b13dd","8841e2aa774b89bd23302dede20663306dc1b9902431ac64b24be8b8d0e3f649","916be7d770b0ae0406be9486ac12eb9825f21514961dd050594c4b250617d5a8","254d9fb8c872d73d34594be8a200fd7311dbfa10a4116bfc465fba408052f2b3","d88a5e779faf033be3d52142a04fbe1cb96009868e3bbdd296b2bc6c59e06c0e","2ccea88888048bbfcacbc9531a5596ea48a3e7dcd0a25f531a81bb717903ba4f","5e379df3d61561c2ed7789b5995b9ba2143bbba21a905e2381e16efe7d1fa424","f07a137bbe2de7a122c37bfea00e761975fb264c49f18003d398d71b3fb35a5f","d8f7109e14f20eb735225a62fd3f8366da1a8349e90331cdad57f4b04caf6c5a","cf3d384d082b933d987c4e2fe7bfb8710adfd9dc8155190056ed6695a25a559e","9871b7ee672bc16c78833bdab3052615834b08375cb144e4d2cba74473f4a589","c863198dae89420f3c552b5a03da6ed6d0acfa3807a64772b895db624b0de707","8b03a5e327d7db67112ebbc93b4f744133eda2c1743dbb0a990c61a8007823ef","86c73f2ee1752bac8eeeece234fd05dfcf0637a4fbd8032e4f5f43102faa8eec","42fad1f540271e35ca37cecda12c4ce2eef27f0f5cf0f8dd761d723c744d3159","ff3743a5de32bee10906aff63d1de726f6a7fd6ee2da4b8229054dfa69de2c34","83acd370f7f84f203e71ebba33ba61b7f1291ca027d7f9a662c6307d74e4ac22","1445cec898f90bdd18b2949b9590b3c012f5b7e1804e6e329fb0fe053946d5ec","0e5318ec2275d8da858b541920d9306650ae6ac8012f0e872fe66eb50321a669","cf530297c3fb3a92ec9591dd4fa229d58b5981e45fe6702a0bd2bea53a5e59be","c1f6f7d08d42148ddfe164d36d7aba91f467dbcb3caa715966ff95f55048b3a4","f4e9bf9103191ef3b3612d3ec0044ca4044ca5be27711fe648ada06fad4bcc85","0c1ee27b8f6a00097c2d6d91a21ee4d096ab52c1e28350f6362542b55380059a","7677d5b0db9e020d3017720f853ba18f415219fb3a9597343b1b1012cfd699f7","bc1c6bc119c1784b1a2be6d9c47addec0d83ef0d52c8fbe1f14a51b4dfffc675","52cf2ce99c2a23de70225e252e9822a22b4e0adb82643ab0b710858810e00bf1","770625067bb27a20b9826255a8d47b6b5b0a2d3dfcbd21f89904c731f671ba77","d1ed6765f4d7906a05968fb5cd6d1db8afa14dbe512a4884e8ea5c0f5e142c80","799c0f1b07c092626cf1efd71d459997635911bb5f7fc1196efe449bba87e965","2a184e4462b9914a30b1b5c41cf80c6d3428f17b20d3afb711fff3f0644001fd","9eabde32a3aa5d80de34af2c2206cdc3ee094c6504a8d0c2d6d20c7c179503cc","397c8051b6cfcb48aa22656f0faca2553c5f56187262135162ee79d2b2f6c966","a8ead142e0c87dcd5dc130eba1f8eeed506b08952d905c47621dc2f583b1bff9","a02f10ea5f73130efca046429254a4e3c06b5475baecc8f7b99a0014731be8b3","c2576a4083232b0e2d9bd06875dd43d371dee2e090325a9eac0133fd5650c1cb","4c9a0564bb317349de6a24eb4efea8bb79898fa72ad63a1809165f5bd42970dd","f40ac11d8859092d20f953aae14ba967282c3bb056431a37fced1866ec7a2681","cc11e9e79d4746cc59e0e17473a59d6f104692fd0eeea1bdb2e206eabed83b03","b444a410d34fb5e98aa5ee2b381362044f4884652e8bc8a11c8fe14bbd85518e","c35808c1f5e16d2c571aa65067e3cb95afeff843b259ecfa2fc107a9519b5392","14d5dc055143e941c8743c6a21fa459f961cbc3deedf1bfe47b11587ca4b3ef5","a3ad4e1fc542751005267d50a6298e6765928c0c3a8dce1572f2ba6ca518661c","f237e7c97a3a89f4591afd49ecb3bd8d14f51a1c4adc8fcae3430febedff5eb6","3ffdfbec93b7aed71082af62b8c3e0cc71261cc68d796665faa1e91604fbae8f","662201f943ed45b1ad600d03a90dffe20841e725203ced8b708c91fcd7f9379a","c9ef74c64ed051ea5b958621e7fb853fe3b56e8787c1587aefc6ea988b3c7e79","2462ccfac5f3375794b861abaa81da380f1bbd9401de59ffa43119a0b644253d","34baf65cfee92f110d6653322e2120c2d368ee64b3c7981dff08ed105c4f19b0","7d8ddf0f021c53099e34ee831a06c394d50371816caa98684812f089b4c6b3d4","7d2a0ba1297be385a89b5515b88cd31b4a1eeef5236f710166dc1b36b1741e1b","9d92b037978bb9525bc4b673ebddd443277542e010c0aef019c03a170ccdaa73","ab82804a14454734010dcdcd43f564ff7b0389bee4c5692eec76ff5b30d4cf66","bae8d023ef6b23df7da26f51cea44321f95817c190342a36882e93b80d07a960","ae271d475b632ce7b03fea6d9cf6da72439e57a109672671cbc79f54e1386938"],"options":{"composite":true,"declaration":true,"declarationMap":true,"emitDeclarationOnly":true,"esModuleInterop":true,"inlineSources":true,"module":1,"outDir":"./types","rootDir":"../src","sourceMap":true,"strict":true,"target":7},"fileIdsList":[[248],[92,128,129,130,145],[129,130,146,147],[128,129],[128,145,148,151],[128,148,151,152],[149,150,151,153,154],[128,151],[128,145,148,149,150,153],[128,136],[128],[92,128],[80,128],[132,133,134,135,136,137,138,139,140,141,142,143,144],[128,134,135],[128,134,136],[210],[222,223,224],[210,221,222],[167,217,226],[221,227],[167,226],[227,228,229],[167],[167,225,231],[167,217,225],[167,217,221,225],[167,217],[232,233,234,235,236,237,238,239,240],[167,231],[167,217,221],[167,217,231],[167,199],[199,200],[199,200,201,202],[204],[204,205,206],[64],[67],[64,67],[65,66,67,68,69,70,71,72,73,74,75,156,159,160,161,162,163,164,165,166],[58,64,65],[67,73,75,155],[158],[67,68],[64,162],[194,195],[248,249,250,251,252],[248,250],[157],[255,256,257],[93,128],[260],[261],[272],[266,271],[275,277,278,279,280,281,282,283,284,285,286,287],[275,276,278,279,280,281,282,283,284,285,286,287],[276,277,278,279,280,281,282,283,284,285,286,287],[275,276,277,279,280,281,282,283,284,285,286,287],[275,276,277,278,280,281,282,283,284,285,286,287],[275,276,277,278,279,281,282,283,284,285,286,287],[275,276,277,278,279,280,282,283,284,285,286,287],[275,276,277,278,279,280,281,283,284,285,286,287],[275,276,277,278,279,280,281,282,284,285,286,287],[275,276,277,278,279,280,281,282,283,285,286,287],[275,276,277,278,279,280,281,282,283,284,286,287],[275,276,277,278,279,280,281,282,283,284,285,287],[275,276,277,278,279,280,281,282,283,284,285,286],[76],[79],[80,85,112],[81,92,93,100,109,120],[81,82,92,100],[83,121],[84,85,93,101],[85,109,117],[86,88,92,100],[87],[88,89],[92],[91,92],[79,92],[92,93,94,109,120],[92,93,94,109],[92,95,100,109,120],[92,93,95,96,100,109,117,120],[95,97,109,117,120],[76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127],[92,98],[99,120,125],[88,92,100,109],[101],[102],[79,103],[104,119,125],[105],[106],[92,107],[107,108,121,123],[80,92,109,110,111],[80,109,111],[109,110],[112],[113],[92,115,116],[115,116],[85,100,109,117],[118],[100,119],[80,95,106,120],[85,121],[109,122],[123],[124],[80,85,92,94,103,109,120,123,125],[109,126],[128,293],[296,335],[296,320,335],[335],[296],[296,321,335],[296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334],[321,335],[336],[339],[179],[179,180,181,182,183],[168,169,170,171,172,173,174,175,176,177,178],[264,267],[264,267,268,269],[266],[263,270],[265],[57,59,60,61,62,63],[57,58],[59],[58,59],[57,59],[167,184,185,186],[185],[56,185,186,187],[186],[189],[189,190,193,197],[196],[167,191,192],[218,219,220],[217,218],[167,217,218],[167,210,217],[167,211],[211,212,213,214,215,216],[167,210],[242,243],[167,198,217,221,225,230,241,242],[209,242,243,246],[76,167,188,191,198,203,207,208,209,242,244,245],[167,198,221,225],[242],[158,167],[167,188,191,198,207,209,242,244]],"referencedMap":[[250,1],[146,2],[148,3],[130,4],[152,5],[153,6],[149,6],[155,7],[150,6],[154,8],[151,9],[137,10],[134,11],[141,12],[135,10],[132,13],[145,14],[139,11],[136,15],[138,16],[222,17],[225,18],[223,19],[224,19],[227,20],[229,21],[228,22],[230,23],[226,24],[232,25],[233,26],[234,27],[235,26],[236,28],[241,29],[237,30],[238,31],[239,27],[231,28],[240,32],[200,33],[201,34],[203,35],[199,24],[210,12],[205,36],[206,36],[207,37],[65,38],[66,38],[68,39],[69,38],[70,38],[71,40],[67,38],[167,41],[75,42],[156,43],[159,44],[165,45],[166,46],[196,47],[253,48],[249,1],[251,49],[252,1],[192,11],[158,50],[258,51],[259,52],[261,53],[262,54],[273,55],[272,56],[276,57],[277,58],[275,59],[278,60],[279,61],[280,62],[281,63],[282,64],[283,65],[284,66],[285,67],[286,68],[287,69],[76,70],[77,70],[79,71],[80,72],[81,73],[82,74],[83,75],[84,76],[85,77],[86,78],[87,79],[88,80],[89,80],[90,81],[91,82],[92,83],[93,84],[94,85],[95,86],[96,87],[97,88],[128,89],[98,90],[99,91],[100,92],[101,93],[102,94],[103,95],[104,96],[105,97],[106,98],[107,99],[108,100],[109,101],[111,102],[110,103],[112,104],[113,105],[115,106],[116,107],[117,108],[118,109],[119,110],[120,111],[121,112],[122,113],[123,114],[124,115],[125,116],[126,117],[290,11],[294,118],[295,11],[320,119],[321,120],[296,121],[299,121],[318,119],[319,119],[309,119],[308,122],[306,119],[301,119],[314,119],[312,119],[316,119],[300,119],[313,119],[317,119],[302,119],[303,119],[315,119],[297,119],[304,119],[305,119],[307,119],[311,119],[322,123],[310,119],[298,119],[335,124],[329,123],[331,125],[330,123],[323,123],[324,123],[326,123],[328,123],[332,125],[333,125],[325,125],[327,125],[337,126],[340,127],[175,128],[177,128],[176,128],[174,128],[184,129],[179,130],[170,128],[171,128],[172,128],[173,128],[268,131],[270,132],[269,131],[267,133],[271,134],[266,135],[64,136],[59,137],[60,138],[61,138],[62,139],[63,139],[58,140],[187,141],[186,142],[188,143],[185,144],[190,145],[198,146],[197,147],[193,148],[221,149],[219,150],[220,151],[218,152],[212,153],[213,153],[215,153],[217,154],[211,155],[216,153],[244,156],[243,157],[247,158],[245,24],[246,159],[242,160]],"exportedModulesMap":[[250,1],[146,2],[148,3],[130,4],[152,5],[153,6],[149,6],[155,7],[150,6],[154,8],[151,9],[137,10],[134,11],[141,12],[135,10],[132,13],[145,14],[139,11],[136,15],[138,16],[222,17],[225,18],[223,19],[224,19],[227,20],[229,21],[228,22],[230,23],[226,24],[232,25],[233,26],[234,27],[235,26],[236,28],[241,29],[237,30],[238,31],[239,27],[231,28],[240,32],[200,33],[201,34],[203,35],[199,24],[210,12],[205,36],[206,36],[207,37],[65,38],[66,38],[68,39],[69,38],[70,38],[71,40],[67,38],[167,41],[75,42],[156,43],[159,44],[165,45],[166,46],[196,47],[253,48],[249,1],[251,49],[252,1],[192,11],[158,50],[258,51],[259,52],[261,53],[262,54],[273,55],[272,56],[276,57],[277,58],[275,59],[278,60],[279,61],[280,62],[281,63],[282,64],[283,65],[284,66],[285,67],[286,68],[287,69],[76,70],[77,70],[79,71],[80,72],[81,73],[82,74],[83,75],[84,76],[85,77],[86,78],[87,79],[88,80],[89,80],[90,81],[91,82],[92,83],[93,84],[94,85],[95,86],[96,87],[97,88],[128,89],[98,90],[99,91],[100,92],[101,93],[102,94],[103,95],[104,96],[105,97],[106,98],[107,99],[108,100],[109,101],[111,102],[110,103],[112,104],[113,105],[115,106],[116,107],[117,108],[118,109],[119,110],[120,111],[121,112],[122,113],[123,114],[124,115],[125,116],[126,117],[290,11],[294,118],[295,11],[320,119],[321,120],[296,121],[299,121],[318,119],[319,119],[309,119],[308,122],[306,119],[301,119],[314,119],[312,119],[316,119],[300,119],[313,119],[317,119],[302,119],[303,119],[315,119],[297,119],[304,119],[305,119],[307,119],[311,119],[322,123],[310,119],[298,119],[335,124],[329,123],[331,125],[330,123],[323,123],[324,123],[326,123],[328,123],[332,125],[333,125],[325,125],[327,125],[337,126],[340,127],[175,128],[177,128],[176,128],[174,128],[184,129],[179,130],[170,128],[171,128],[172,128],[173,128],[268,131],[270,132],[269,131],[267,133],[271,134],[266,135],[64,136],[59,137],[60,138],[61,138],[62,139],[63,139],[58,140],[187,141],[186,142],[188,143],[185,144],[190,145],[198,146],[197,147],[193,148],[221,149],[219,150],[220,151],[218,152],[212,153],[213,153],[215,153],[217,154],[211,155],[216,153],[244,161],[243,161],[247,158],[245,162],[246,163],[242,160]],"semanticDiagnosticsPerFile":[250,248,146,129,148,130,147,152,153,149,155,150,154,151,137,134,141,135,132,140,145,142,143,144,139,136,133,138,222,225,223,224,227,229,228,230,226,232,233,234,235,236,241,237,238,239,231,240,191,200,202,201,203,199,210,205,206,207,204,65,66,68,69,70,71,72,73,74,67,167,75,156,159,160,161,162,163,164,165,166,194,196,195,253,249,251,252,192,158,254,255,258,256,259,260,261,262,273,272,257,274,276,277,275,278,279,280,281,282,283,284,285,286,287,288,157,76,77,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,78,127,95,96,97,128,98,99,100,101,102,103,104,105,106,107,108,109,111,110,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,289,290,291,292,294,293,295,320,321,296,299,318,319,309,308,306,301,314,312,316,300,313,317,302,303,315,297,304,305,307,311,322,310,298,335,334,329,331,330,323,324,326,328,332,333,325,327,337,336,338,208,339,340,131,263,178,175,177,176,174,184,179,183,180,182,181,170,171,172,168,169,173,264,268,270,269,267,271,266,265,57,64,59,60,61,62,63,58,8,10,9,2,11,12,13,14,15,16,17,18,3,4,22,19,20,21,23,24,25,5,26,27,28,29,6,33,30,31,32,34,7,35,40,41,36,37,38,39,1,42,56,187,186,188,185,190,198,197,189,193,221,219,220,218,212,213,214,215,217,211,216,209,244,243,247,245,246,242,47,48,49,50,51,52,43,53,54,55,44,45,46],"latestChangedDtsFile":"./types/index.d.ts"},"version":"4.9.5"}
\ No newline at end of file
diff --git a/dist/types/NetworkController.d.ts b/dist/types/NetworkController.d.ts
index 216d1acbf39dd8c0b8d393f2f65fd9b370a2b9a6..34e756dd2f950b4c1eb095821ae039f0bf962d9e 100644
--- a/dist/types/NetworkController.d.ts
+++ b/dist/types/NetworkController.d.ts
@@ -372,7 +372,9 @@ export declare class NetworkController extends BaseController<typeof name, Netwo
      * @param options.setActive - If true, switches to the network upon adding or updating it (default: false).
      * @returns The ID for the added or updated network configuration.
      */
-    upsertNetworkConfiguration(networkConfiguration: NetworkConfiguration, { referrer, source, setActive, }: {
+    upsertNetworkConfiguration(networkConfiguration: NetworkConfiguration & {
+        id?: NetworkConfigurationId;
+    }, { referrer, source, setActive, }: {
         referrer: string;
         source: string;
         setActive?: boolean;
diff --git a/dist/types/NetworkController.d.ts.map b/dist/types/NetworkController.d.ts.map
index 07d5aa4db918e193d38d65966322de2b4967c8d3..ba094f2735d31cc4fa4e48fe504f55d30da005ad 100644
--- a/dist/types/NetworkController.d.ts.map
+++ b/dist/types/NetworkController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"NetworkController.d.ts","sourceRoot":"","sources":["../../src/NetworkController.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,wBAAwB,EACxB,0BAA0B,EAC1B,6BAA6B,EAC9B,MAAM,2BAA2B,CAAC;AACnC,OAAO,EAAE,cAAc,EAAE,MAAM,2BAA2B,CAAC;AAC3D,OAAO,EAIL,iBAAiB,EACjB,WAAW,EAGZ,MAAM,4BAA4B,CAAC;AACpC,OAAO,QAAQ,MAAM,qBAAqB,CAAC;AAG3C,OAAO,KAAK,EAAE,cAAc,EAAE,MAAM,+BAA+B,CAAC;AACpE,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAS3C,OAAO,EAAsB,aAAa,EAAE,MAAM,aAAa,CAAC;AAChE,OAAO,KAAK,EACV,wBAAwB,EACxB,yBAAyB,EAC1B,MAAM,sCAAsC,CAAC;AAI9C,OAAO,KAAK,EACV,YAAY,EACZ,QAAQ,EACR,gCAAgC,EAChC,gCAAgC,EAEjC,MAAM,SAAS,CAAC;AAIjB;;;;;;;;;;GAUG;AACH,MAAM,MAAM,cAAc,GAAG;IAC3B,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,IAAI,EAAE,WAAW,CAAC;IAClB,OAAO,EAAE,GAAG,CAAC;IACb,MAAM,EAAE,MAAM,CAAC;IACf,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,QAAQ,CAAC,EAAE;QAAE,gBAAgB,CAAC,EAAE,MAAM,CAAA;KAAE,CAAC;IACzC,EAAE,CAAC,EAAE,sBAAsB,CAAC;CAC7B,CAAC;AAEF,MAAM,MAAM,KAAK,GAAG;IAClB,aAAa,CAAC,EAAE,MAAM,CAAC;CACxB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,eAAe,GAAG;IAC5B;;OAEG;IACH,IAAI,EAAE;QACJ,CAAC,SAAS,EAAE,MAAM,GAAG,OAAO,CAAC;KAC9B,CAAC;IACF;;OAEG;IACH,MAAM,EAAE,aAAa,CAAC;CACvB,CAAC;AAEF;;;;;;;;GAQG;AACH,MAAM,MAAM,oBAAoB,GAAG;IACjC,MAAM,EAAE,MAAM,CAAC;IACf,OAAO,EAAE,GAAG,CAAC;IACb,MAAM,EAAE,MAAM,CAAC;IACf,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,QAAQ,CAAC,EAAE;QACT,gBAAgB,EAAE,MAAM,CAAC;KAC1B,CAAC;CACH,CAAC;AAEF;;GAEG;AACH,KAAK,qBAAqB,GAAG,MAAM,CACjC,sBAAsB,EACtB,oBAAoB,GAAG;IAAE,EAAE,EAAE,sBAAsB,CAAA;CAAE,CACtD,CAAC;AAEF;;;;;;;;;;;;GAYG;AACH,wBAAgB,WAAW,CAAC,CAAC,SAAS,WAAW,EAG/C,MAAM,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,OAGhC;AAqKD;;GAEG;AACH,MAAM,MAAM,sBAAsB,GAAG,iBAAiB,CAAC;AAEvD;;GAEG;AACH,MAAM,MAAM,qBAAqB,GAAG,MAAM,CAAC;AAE3C;;GAEG;AACH,MAAM,MAAM,eAAe,GAAG,sBAAsB,GAAG,qBAAqB,CAAC;AAE7E;;GAEG;AACH,MAAM,MAAM,gBAAgB,GAAG;IAC7B,CAAC,eAAe,EAAE,eAAe,GAAG,eAAe,CAAC;CACrD,CAAC;AAEF;;;;;;;GAOG;AACH,MAAM,MAAM,YAAY,GAAG;IACzB,uBAAuB,EAAE,eAAe,CAAC;IACzC,cAAc,EAAE,cAAc,CAAC;IAC/B,qBAAqB,EAAE,qBAAqB,CAAC;IAC7C,gBAAgB,EAAE,gBAAgB,CAAC;CACpC,CAAC;AAEF,QAAA,MAAM,IAAI,sBAAsB,CAAC;AAEjC;;;;;;GAMG;AACH,MAAM,MAAM,iBAAiB,GAAG,cAAc,CAC5C,yBAAyB,CAAC,YAAY,CAAC,CACxC,CAAC;AAEF;;;;;;GAMG;AACH,MAAM,MAAM,aAAa,GAAG,cAAc,CAAC,yBAAyB,CAAC,QAAQ,CAAC,CAAC,CAAC;AAEhF,MAAM,MAAM,iCAAiC,GAAG,0BAA0B,CACxE,OAAO,IAAI,EACX,YAAY,CACb,CAAC;AAEF;;;;GAIG;AACH,MAAM,MAAM,uCAAuC,GAAG;IACpD,IAAI,EAAE,qCAAqC,CAAC;IAC5C,OAAO,EAAE,CAAC,YAAY,CAAC,CAAC;CACzB,CAAC;AAEF;;;GAGG;AACH,MAAM,MAAM,sCAAsC,GAAG;IACnD,IAAI,EAAE,oCAAoC,CAAC;IAC3C,OAAO,EAAE,CAAC,YAAY,CAAC,CAAC;CACzB,CAAC;AAEF;;;;GAIG;AACH,MAAM,MAAM,qCAAqC,GAAG;IAClD,IAAI,EAAE,mCAAmC,CAAC;IAC1C,OAAO,EAAE,EAAE,CAAC;CACb,CAAC;AAEF;;;;GAIG;AACH,MAAM,MAAM,uCAAuC,GAAG;IACpD,IAAI,EAAE,qCAAqC,CAAC;IAC5C,OAAO,EAAE,EAAE,CAAC;CACb,CAAC;AAEF,MAAM,MAAM,uBAAuB,GAC/B,iCAAiC,GACjC,uCAAuC,GACvC,sCAAsC,GACtC,qCAAqC,GACrC,uCAAuC,CAAC;AAE5C,MAAM,MAAM,+BAA+B,GAAG,wBAAwB,CACpE,OAAO,IAAI,EACX,YAAY,CACb,CAAC;AAEF,MAAM,MAAM,wCAAwC,GAAG;IACrD,IAAI,EAAE,qCAAqC,CAAC;IAC5C,OAAO,EAAE,MAAM,cAAc,CAAC;CAC/B,CAAC;AAEF,MAAM,MAAM,kCAAkC,GAAG;IAC/C,IAAI,EAAE,+BAA+B,CAAC;IACtC,OAAO,EAAE,MAAM,QAAQ,GAAG,SAAS,CAAC;CACrC,CAAC;AAEF,MAAM,MAAM,2CAA2C,GAAG;IACxD,IAAI,EAAE,wCAAwC,CAAC;IAC/C,OAAO,EAAE,iBAAiB,CAAC,sBAAsB,CAAC,CAAC;CACpD,CAAC;AAEF,MAAM,MAAM,+CAA+C,GAAG;IAC5D,IAAI,EAAE,4CAA4C,CAAC;IACnD,OAAO,EAAE,iBAAiB,CAAC,0BAA0B,CAAC,CAAC;CACxD,CAAC;AAEF,MAAM,MAAM,8CAA8C,GAAG;IAC3D,IAAI,EAAE,2CAA2C,CAAC;IAClD,OAAO,EAAE,iBAAiB,CAAC,yBAAyB,CAAC,CAAC;CACvD,CAAC;AAEF,MAAM,MAAM,mDAAmD,GAAG;IAChE,IAAI,EAAE,gDAAgD,CAAC;IACvD,OAAO,EAAE,iBAAiB,CAAC,8BAA8B,CAAC,CAAC;CAC5D,CAAC;AAEF;;;;;GAKG;AACH,MAAM,MAAM,sCAAsC,GAAG;IACnD,IAAI,EAAE,mCAAmC,CAAC;IAC1C,OAAO,EAAE,iBAAiB,CAAC,iBAAiB,CAAC,CAAC;CAC/C,CAAC;AAEF,MAAM,MAAM,uCAAuC,GAAG;IACpD,IAAI,EAAE,oCAAoC,CAAC;IAC3C,OAAO,EAAE,iBAAiB,CAAC,kBAAkB,CAAC,CAAC;CAChD,CAAC;AAEF,MAAM,MAAM,yDAAyD,GAAG;IACtE,IAAI,EAAE,4DAA4D,CAAC;IACnE,OAAO,EAAE,iBAAiB,CAAC,0CAA0C,CAAC,CAAC;CACxE,CAAC;AAEF,MAAM,MAAM,wBAAwB,GAChC,+BAA+B,GAC/B,wCAAwC,GACxC,kCAAkC,GAClC,2CAA2C,GAC3C,+CAA+C,GAC/C,8CAA8C,GAC9C,mDAAmD,GACnD,uCAAuC,GACvC,sCAAsC,GACtC,yDAAyD,CAAC;AAE9D,MAAM,MAAM,0BAA0B,GAAG,6BAA6B,CACpE,OAAO,IAAI,EACX,wBAAwB,EACxB,uBAAuB,EACvB,KAAK,EACL,KAAK,CACN,CAAC;AAEF,MAAM,MAAM,wBAAwB,GAAG;IACrC,SAAS,EAAE,0BAA0B,CAAC;IACtC,qBAAqB,EAAE,MAAM,IAAI,CAAC;IAClC,eAAe,EAAE,MAAM,CAAC;IACxB,KAAK,CAAC,EAAE,OAAO,CAAC,YAAY,CAAC,CAAC;CAC/B,CAAC;AAEF,eAAO,MAAM,YAAY,EAAE,YAS1B,CAAC;AAeF,KAAK,sBAAsB,GAAG,MAAM,CAAC;AAErC;;GAEG;AACH,KAAK,uCAAuC,GAAG,MAAM,CACnD,sBAAsB,EACtB,wBAAwB,CAAC,gCAAgC,CAAC,CAC3D,CAAC;AAEF;;GAEG;AACH,KAAK,sCAAsC,GAAG,MAAM,CAClD,qBAAqB,EACrB,wBAAwB,CAAC,gCAAgC,CAAC,CAC3D,CAAC;AAWF;;GAEG;AACH,qBAAa,iBAAkB,SAAQ,cAAc,CACnD,OAAO,IAAI,EACX,YAAY,EACZ,0BAA0B,CAC3B;;gBAea,EACV,SAAS,EACT,KAAK,EACL,eAAe,EACf,qBAAqB,GACtB,EAAE,wBAAwB;IAiF3B;;;;OAIG;IACH,0BAA0B,IAAI;QAC5B,QAAQ,EAAE,cAAc,CAAC,yBAAyB,CAAC,QAAQ,CAAC,CAAC,GAAG,SAAS,CAAC;QAC1E,YAAY,EACR,cAAc,CAAC,yBAAyB,CAAC,YAAY,CAAC,CAAC,GACvD,SAAS,CAAC;KACf;IAOD;;;;OAIG;IACH,wBAAwB,IACpB;QACE,QAAQ,EAAE,cAAc,CAAC,yBAAyB,CAAC,QAAQ,CAAC,CAAC,CAAC;QAC9D,YAAY,EAAE,cAAc,CAAC,yBAAyB,CAAC,YAAY,CAAC,CAAC,CAAC;KACvE,GACD,SAAS;IAUb;;;;;;;OAOG;IACH,wBAAwB,IAAI,uCAAuC,GACjE,sCAAsC;IAWxC;;;;;;OAMG;IACH,oBAAoB,CAClB,qBAAqB,EAAE,sBAAsB,GAC5C,wBAAwB,CAAC,gCAAgC,CAAC;IAE7D;;;;;;OAMG;IACH,oBAAoB,CAClB,qBAAqB,EAAE,qBAAqB,GAC3C,wBAAwB,CAAC,gCAAgC,CAAC;IA0D7D;;;OAGG;IACG,kBAAkB;IAOxB;;;;;OAKG;IACG,uBAAuB,CAAC,eAAe,EAAE,eAAe;IAkE9D;;;;;;;;;;;;OAYG;IACG,aAAa,CAAC,eAAe,CAAC,EAAE,eAAe;IAmGrD;;;;;;OAMG;IACG,eAAe,CAAC,IAAI,EAAE,iBAAiB;IAc7C;;;;;OAKG;IACG,gBAAgB,CAAC,4BAA4B,EAAE,MAAM;IAuE3D;;;;;;;;OAQG;IACG,uBAAuB,CAAC,eAAe,CAAC,EAAE,eAAe;IA2BzD,uCAAuC,CAC3C,eAAe,EAAE,eAAe;IAkClC;;OAEG;IACG,eAAe;IAKrB;;;;;;;;;OASG;IACH,wCAAwC,CACtC,eAAe,EAAE,eAAe,GAC/B,oBAAoB,GAAG,SAAS;IAcnC;;;;;;;;;;;;;;;;;;;;;;;OAuBG;IACG,0BAA0B,CAC9B,oBAAoB,EAAE,oBAAoB,EAC1C,EACE,QAAQ,EACR,MAAM,EACN,SAAiB,GAClB,EAAE;QACD,QAAQ,EAAE,MAAM,CAAC;QACjB,MAAM,EAAE,MAAM,CAAC;QACf,SAAS,CAAC,EAAE,OAAO,CAAC;KACrB,GACA,OAAO,CAAC,MAAM,CAAC;IA0GlB;;;;;;;;;OASG;IACH,0BAA0B,CAAC,sBAAsB,EAAE,MAAM;IAuBzD;;;;OAIG;IACG,0BAA0B;IAUhC;;;;OAIG;IACG,OAAO;IAIb;;;;;OAKG;IACH,UAAU,CAAC,EACT,qBAAqB,GACtB,EAAE;QACD,qBAAqB,EAAE,YAAY,CAAC,uBAAuB,CAAC,CAAC;KAC9D,GAAG,IAAI;IASR;;;;;OAKG;IACH,4BAA4B,CAAC,OAAO,EAAE,GAAG,GAAG,eAAe;CA6P5D"}
\ No newline at end of file
+{"version":3,"file":"NetworkController.d.ts","sourceRoot":"","sources":["../../src/NetworkController.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,wBAAwB,EACxB,0BAA0B,EAC1B,6BAA6B,EAC9B,MAAM,2BAA2B,CAAC;AACnC,OAAO,EAAE,cAAc,EAAE,MAAM,2BAA2B,CAAC;AAC3D,OAAO,EAIL,iBAAiB,EACjB,WAAW,EAGZ,MAAM,4BAA4B,CAAC;AACpC,OAAO,QAAQ,MAAM,qBAAqB,CAAC;AAG3C,OAAO,KAAK,EAAE,cAAc,EAAE,MAAM,+BAA+B,CAAC;AACpE,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAS3C,OAAO,EAAsB,aAAa,EAAE,MAAM,aAAa,CAAC;AAChE,OAAO,KAAK,EACV,wBAAwB,EACxB,yBAAyB,EAC1B,MAAM,sCAAsC,CAAC;AAI9C,OAAO,KAAK,EACV,YAAY,EACZ,QAAQ,EACR,gCAAgC,EAChC,gCAAgC,EAEjC,MAAM,SAAS,CAAC;AAIjB;;;;;;;;;;GAUG;AACH,MAAM,MAAM,cAAc,GAAG;IAC3B,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,IAAI,EAAE,WAAW,CAAC;IAClB,OAAO,EAAE,GAAG,CAAC;IACb,MAAM,EAAE,MAAM,CAAC;IACf,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,QAAQ,CAAC,EAAE;QAAE,gBAAgB,CAAC,EAAE,MAAM,CAAA;KAAE,CAAC;IACzC,EAAE,CAAC,EAAE,sBAAsB,CAAC;CAC7B,CAAC;AAEF,MAAM,MAAM,KAAK,GAAG;IAClB,aAAa,CAAC,EAAE,MAAM,CAAC;CACxB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,eAAe,GAAG;IAC5B;;OAEG;IACH,IAAI,EAAE;QACJ,CAAC,SAAS,EAAE,MAAM,GAAG,OAAO,CAAC;KAC9B,CAAC;IACF;;OAEG;IACH,MAAM,EAAE,aAAa,CAAC;CACvB,CAAC;AAEF;;;;;;;;GAQG;AACH,MAAM,MAAM,oBAAoB,GAAG;IACjC,MAAM,EAAE,MAAM,CAAC;IACf,OAAO,EAAE,GAAG,CAAC;IACb,MAAM,EAAE,MAAM,CAAC;IACf,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,QAAQ,CAAC,EAAE;QACT,gBAAgB,EAAE,MAAM,CAAC;KAC1B,CAAC;CACH,CAAC;AAEF;;GAEG;AACH,KAAK,qBAAqB,GAAG,MAAM,CACjC,sBAAsB,EACtB,oBAAoB,GAAG;IAAE,EAAE,EAAE,sBAAsB,CAAA;CAAE,CACtD,CAAC;AAEF;;;;;;;;;;;;GAYG;AACH,wBAAgB,WAAW,CAAC,CAAC,SAAS,WAAW,EAG/C,MAAM,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,OAGhC;AAqKD;;GAEG;AACH,MAAM,MAAM,sBAAsB,GAAG,iBAAiB,CAAC;AAEvD;;GAEG;AACH,MAAM,MAAM,qBAAqB,GAAG,MAAM,CAAC;AAE3C;;GAEG;AACH,MAAM,MAAM,eAAe,GAAG,sBAAsB,GAAG,qBAAqB,CAAC;AAE7E;;GAEG;AACH,MAAM,MAAM,gBAAgB,GAAG;IAC7B,CAAC,eAAe,EAAE,eAAe,GAAG,eAAe,CAAC;CACrD,CAAC;AAEF;;;;;;;GAOG;AACH,MAAM,MAAM,YAAY,GAAG;IACzB,uBAAuB,EAAE,eAAe,CAAC;IACzC,cAAc,EAAE,cAAc,CAAC;IAC/B,qBAAqB,EAAE,qBAAqB,CAAC;IAC7C,gBAAgB,EAAE,gBAAgB,CAAC;CACpC,CAAC;AAEF,QAAA,MAAM,IAAI,sBAAsB,CAAC;AAEjC;;;;;;GAMG;AACH,MAAM,MAAM,iBAAiB,GAAG,cAAc,CAC5C,yBAAyB,CAAC,YAAY,CAAC,CACxC,CAAC;AAEF;;;;;;GAMG;AACH,MAAM,MAAM,aAAa,GAAG,cAAc,CAAC,yBAAyB,CAAC,QAAQ,CAAC,CAAC,CAAC;AAEhF,MAAM,MAAM,iCAAiC,GAAG,0BAA0B,CACxE,OAAO,IAAI,EACX,YAAY,CACb,CAAC;AAEF;;;;GAIG;AACH,MAAM,MAAM,uCAAuC,GAAG;IACpD,IAAI,EAAE,qCAAqC,CAAC;IAC5C,OAAO,EAAE,CAAC,YAAY,CAAC,CAAC;CACzB,CAAC;AAEF;;;GAGG;AACH,MAAM,MAAM,sCAAsC,GAAG;IACnD,IAAI,EAAE,oCAAoC,CAAC;IAC3C,OAAO,EAAE,CAAC,YAAY,CAAC,CAAC;CACzB,CAAC;AAEF;;;;GAIG;AACH,MAAM,MAAM,qCAAqC,GAAG;IAClD,IAAI,EAAE,mCAAmC,CAAC;IAC1C,OAAO,EAAE,EAAE,CAAC;CACb,CAAC;AAEF;;;;GAIG;AACH,MAAM,MAAM,uCAAuC,GAAG;IACpD,IAAI,EAAE,qCAAqC,CAAC;IAC5C,OAAO,EAAE,EAAE,CAAC;CACb,CAAC;AAEF,MAAM,MAAM,uBAAuB,GAC/B,iCAAiC,GACjC,uCAAuC,GACvC,sCAAsC,GACtC,qCAAqC,GACrC,uCAAuC,CAAC;AAE5C,MAAM,MAAM,+BAA+B,GAAG,wBAAwB,CACpE,OAAO,IAAI,EACX,YAAY,CACb,CAAC;AAEF,MAAM,MAAM,wCAAwC,GAAG;IACrD,IAAI,EAAE,qCAAqC,CAAC;IAC5C,OAAO,EAAE,MAAM,cAAc,CAAC;CAC/B,CAAC;AAEF,MAAM,MAAM,kCAAkC,GAAG;IAC/C,IAAI,EAAE,+BAA+B,CAAC;IACtC,OAAO,EAAE,MAAM,QAAQ,GAAG,SAAS,CAAC;CACrC,CAAC;AAEF,MAAM,MAAM,2CAA2C,GAAG;IACxD,IAAI,EAAE,wCAAwC,CAAC;IAC/C,OAAO,EAAE,iBAAiB,CAAC,sBAAsB,CAAC,CAAC;CACpD,CAAC;AAEF,MAAM,MAAM,+CAA+C,GAAG;IAC5D,IAAI,EAAE,4CAA4C,CAAC;IACnD,OAAO,EAAE,iBAAiB,CAAC,0BAA0B,CAAC,CAAC;CACxD,CAAC;AAEF,MAAM,MAAM,8CAA8C,GAAG;IAC3D,IAAI,EAAE,2CAA2C,CAAC;IAClD,OAAO,EAAE,iBAAiB,CAAC,yBAAyB,CAAC,CAAC;CACvD,CAAC;AAEF,MAAM,MAAM,mDAAmD,GAAG;IAChE,IAAI,EAAE,gDAAgD,CAAC;IACvD,OAAO,EAAE,iBAAiB,CAAC,8BAA8B,CAAC,CAAC;CAC5D,CAAC;AAEF;;;;;GAKG;AACH,MAAM,MAAM,sCAAsC,GAAG;IACnD,IAAI,EAAE,mCAAmC,CAAC;IAC1C,OAAO,EAAE,iBAAiB,CAAC,iBAAiB,CAAC,CAAC;CAC/C,CAAC;AAEF,MAAM,MAAM,uCAAuC,GAAG;IACpD,IAAI,EAAE,oCAAoC,CAAC;IAC3C,OAAO,EAAE,iBAAiB,CAAC,kBAAkB,CAAC,CAAC;CAChD,CAAC;AAEF,MAAM,MAAM,yDAAyD,GAAG;IACtE,IAAI,EAAE,4DAA4D,CAAC;IACnE,OAAO,EAAE,iBAAiB,CAAC,0CAA0C,CAAC,CAAC;CACxE,CAAC;AAEF,MAAM,MAAM,wBAAwB,GAChC,+BAA+B,GAC/B,wCAAwC,GACxC,kCAAkC,GAClC,2CAA2C,GAC3C,+CAA+C,GAC/C,8CAA8C,GAC9C,mDAAmD,GACnD,uCAAuC,GACvC,sCAAsC,GACtC,yDAAyD,CAAC;AAE9D,MAAM,MAAM,0BAA0B,GAAG,6BAA6B,CACpE,OAAO,IAAI,EACX,wBAAwB,EACxB,uBAAuB,EACvB,KAAK,EACL,KAAK,CACN,CAAC;AAEF,MAAM,MAAM,wBAAwB,GAAG;IACrC,SAAS,EAAE,0BAA0B,CAAC;IACtC,qBAAqB,EAAE,MAAM,IAAI,CAAC;IAClC,eAAe,EAAE,MAAM,CAAC;IACxB,KAAK,CAAC,EAAE,OAAO,CAAC,YAAY,CAAC,CAAC;CAC/B,CAAC;AAEF,eAAO,MAAM,YAAY,EAAE,YAS1B,CAAC;AAeF,KAAK,sBAAsB,GAAG,MAAM,CAAC;AAErC;;GAEG;AACH,KAAK,uCAAuC,GAAG,MAAM,CACnD,sBAAsB,EACtB,wBAAwB,CAAC,gCAAgC,CAAC,CAC3D,CAAC;AAEF;;GAEG;AACH,KAAK,sCAAsC,GAAG,MAAM,CAClD,qBAAqB,EACrB,wBAAwB,CAAC,gCAAgC,CAAC,CAC3D,CAAC;AAWF;;GAEG;AACH,qBAAa,iBAAkB,SAAQ,cAAc,CACnD,OAAO,IAAI,EACX,YAAY,EACZ,0BAA0B,CAC3B;;gBAea,EACV,SAAS,EACT,KAAK,EACL,eAAe,EACf,qBAAqB,GACtB,EAAE,wBAAwB;IAiF3B;;;;OAIG;IACH,0BAA0B,IAAI;QAC5B,QAAQ,EAAE,cAAc,CAAC,yBAAyB,CAAC,QAAQ,CAAC,CAAC,GAAG,SAAS,CAAC;QAC1E,YAAY,EACR,cAAc,CAAC,yBAAyB,CAAC,YAAY,CAAC,CAAC,GACvD,SAAS,CAAC;KACf;IAOD;;;;OAIG;IACH,wBAAwB,IACpB;QACE,QAAQ,EAAE,cAAc,CAAC,yBAAyB,CAAC,QAAQ,CAAC,CAAC,CAAC;QAC9D,YAAY,EAAE,cAAc,CAAC,yBAAyB,CAAC,YAAY,CAAC,CAAC,CAAC;KACvE,GACD,SAAS;IAUb;;;;;;;OAOG;IACH,wBAAwB,IAAI,uCAAuC,GACjE,sCAAsC;IAWxC;;;;;;OAMG;IACH,oBAAoB,CAClB,qBAAqB,EAAE,sBAAsB,GAC5C,wBAAwB,CAAC,gCAAgC,CAAC;IAE7D;;;;;;OAMG;IACH,oBAAoB,CAClB,qBAAqB,EAAE,qBAAqB,GAC3C,wBAAwB,CAAC,gCAAgC,CAAC;IA0D7D;;;OAGG;IACG,kBAAkB;IAQxB;;;;;OAKG;IACG,uBAAuB,CAAC,eAAe,EAAE,eAAe;IAkE9D;;;;;;;;;;;;OAYG;IACG,aAAa,CAAC,eAAe,CAAC,EAAE,eAAe;IAmGrD;;;;;;OAMG;IACG,eAAe,CAAC,IAAI,EAAE,iBAAiB;IAc7C;;;;;OAKG;IACG,gBAAgB,CAAC,4BAA4B,EAAE,MAAM;IAuE3D;;;;;;;;OAQG;IACG,uBAAuB,CAAC,eAAe,CAAC,EAAE,eAAe;IA2BzD,uCAAuC,CAC3C,eAAe,EAAE,eAAe;IAkClC;;OAEG;IACG,eAAe;IAKrB;;;;;;;;;OASG;IACH,wCAAwC,CACtC,eAAe,EAAE,eAAe,GAC/B,oBAAoB,GAAG,SAAS;IAcnC;;;;;;;;;;;;;;;;;;;;;;;OAuBG;IACG,0BAA0B,CAG9B,oBAAoB,EAAE,oBAAoB,GAAG;QAC3C,EAAE,CAAC,EAAE,sBAAsB,CAAC;KAC7B,EACD,EACE,QAAQ,EACR,MAAM,EACN,SAAiB,GAClB,EAAE;QACD,QAAQ,EAAE,MAAM,CAAC;QACjB,MAAM,EAAE,MAAM,CAAC;QACf,SAAS,CAAC,EAAE,OAAO,CAAC;KACrB,GACA,OAAO,CAAC,MAAM,CAAC;IA2IlB;;;;;;;;;OASG;IACH,0BAA0B,CAAC,sBAAsB,EAAE,MAAM;IAuBzD;;;;OAIG;IACG,0BAA0B;IAUhC;;;;OAIG;IACG,OAAO;IAIb;;;;;OAKG;IACH,UAAU,CAAC,EACT,qBAAqB,GACtB,EAAE;QACD,qBAAqB,EAAE,YAAY,CAAC,uBAAuB,CAAC,CAAC;KAC9D,GAAG,IAAI;IASR;;;;;OAKG;IACH,4BAA4B,CAAC,OAAO,EAAE,GAAG,GAAG,eAAe;CA6P5D"}
\ No newline at end of file
